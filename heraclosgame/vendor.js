! function(t) {
    var e = {};

    function i(n) {
        if (e[n]) return e[n].exports;
        var r = e[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports
    }
    i.m = t, i.c = e, i.d = function(t, e, n) {
        i.o(t, e) || Object.defineProperty(t, e, {
            configurable: !1,
            enumerable: !0,
            get: n
        })
    }, i.r = function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, i.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return i.d(e, "a", e), e
    }, i.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i(i.s = 230)
}([, function(t, e, i) {
    t.exports = r;
    var n = i(25);

    function r(t, e, i) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0
    }
    r.ZERO = new r(0, 0, 0), r.UNIT_X = new r(1, 0, 0), r.UNIT_Y = new r(0, 1, 0), r.UNIT_Z = new r(0, 0, 1), r.prototype.cross = function(t, e) {
        var i = t.x,
            n = t.y,
            o = t.z,
            a = this.x,
            s = this.y,
            l = this.z;
        return (e = e || new r).x = s * o - l * n, e.y = l * i - a * o, e.z = a * n - s * i, e
    }, r.prototype.set = function(t, e, i) {
        return this.x = t, this.y = e, this.z = i, this
    }, r.prototype.setZero = function() {
        this.x = this.y = this.z = 0
    }, r.prototype.vadd = function(t, e) {
        if (!e) return new r(this.x + t.x, this.y + t.y, this.z + t.z);
        e.x = t.x + this.x, e.y = t.y + this.y, e.z = t.z + this.z
    }, r.prototype.vsub = function(t, e) {
        if (!e) return new r(this.x - t.x, this.y - t.y, this.z - t.z);
        e.x = this.x - t.x, e.y = this.y - t.y, e.z = this.z - t.z
    }, r.prototype.crossmat = function() {
        return new n([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0])
    }, r.prototype.normalize = function() {
        var t = this.x,
            e = this.y,
            i = this.z,
            n = Math.sqrt(t * t + e * e + i * i);
        if (n > 0) {
            var r = 1 / n;
            this.x *= r, this.y *= r, this.z *= r
        } else this.x = 0, this.y = 0, this.z = 0;
        return n
    }, r.prototype.unit = function(t) {
        t = t || new r;
        var e = this.x,
            i = this.y,
            n = this.z,
            o = Math.sqrt(e * e + i * i + n * n);
        return o > 0 ? (o = 1 / o, t.x = e * o, t.y = i * o, t.z = n * o) : (t.x = 1, t.y = 0, t.z = 0), t
    }, r.prototype.norm = function() {
        var t = this.x,
            e = this.y,
            i = this.z;
        return Math.sqrt(t * t + e * e + i * i)
    }, r.prototype.length = r.prototype.norm, r.prototype.norm2 = function() {
        return this.dot(this)
    }, r.prototype.lengthSquared = r.prototype.norm2, r.prototype.distanceTo = function(t) {
        var e = this.x,
            i = this.y,
            n = this.z,
            r = t.x,
            o = t.y,
            a = t.z;
        return Math.sqrt((r - e) * (r - e) + (o - i) * (o - i) + (a - n) * (a - n))
    }, r.prototype.distanceSquared = function(t) {
        var e = this.x,
            i = this.y,
            n = this.z,
            r = t.x,
            o = t.y,
            a = t.z;
        return (r - e) * (r - e) + (o - i) * (o - i) + (a - n) * (a - n)
    }, r.prototype.mult = function(t, e) {
        e = e || new r;
        var i = this.x,
            n = this.y,
            o = this.z;
        return e.x = t * i, e.y = t * n, e.z = t * o, e
    }, r.prototype.vmul = function(t, e) {
        return (e = e || new r).x = t.x * this.x, e.y = t.y * this.y, e.z = t.z * this.z, e
    }, r.prototype.scale = r.prototype.mult, r.prototype.addScaledVector = function(t, e, i) {
        return (i = i || new r).x = this.x + t * e.x, i.y = this.y + t * e.y, i.z = this.z + t * e.z, i
    }, r.prototype.dot = function(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
    }, r.prototype.isZero = function() {
        return 0 === this.x && 0 === this.y && 0 === this.z
    }, r.prototype.negate = function(t) {
        return (t = t || new r).x = -this.x, t.y = -this.y, t.z = -this.z, t
    };
    var o = new r,
        a = new r;
    r.prototype.tangents = function(t, e) {
        var i = this.norm();
        if (i > 0) {
            var n = o,
                r = 1 / i;
            n.set(this.x * r, this.y * r, this.z * r);
            var s = a;
            Math.abs(n.x) < .9 ? (s.set(1, 0, 0), n.cross(s, t)) : (s.set(0, 1, 0), n.cross(s, t)), n.cross(t, e)
        } else t.set(1, 0, 0), e.set(0, 1, 0)
    }, r.prototype.toString = function() {
        return this.x + "," + this.y + "," + this.z
    }, r.prototype.toArray = function() {
        return [this.x, this.y, this.z]
    }, r.prototype.copy = function(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
    }, r.prototype.lerp = function(t, e, i) {
        var n = this.x,
            r = this.y,
            o = this.z;
        i.x = n + (t.x - n) * e, i.y = r + (t.y - r) * e, i.z = o + (t.z - o) * e
    }, r.prototype.almostEquals = function(t, e) {
        return void 0 === e && (e = 1e-6), !(Math.abs(this.x - t.x) > e || Math.abs(this.y - t.y) > e || Math.abs(this.z - t.z) > e)
    }, r.prototype.almostZero = function(t) {
        return void 0 === t && (t = 1e-6), !(Math.abs(this.x) > t || Math.abs(this.y) > t || Math.abs(this.z) > t)
    };
    var s = new r;
    r.prototype.isAntiparallelTo = function(t, e) {
        return this.negate(s), s.almostEquals(t, e)
    }, r.prototype.clone = function() {
        return new r(this.x, this.y, this.z)
    }
}, , , , , , , function(t, e, i) {
    t.exports = n;
    var n = i(8);

    function n(t) {
        t = t || {}, this.id = n.idCounter++, this.type = t.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = !t.collisionResponse || t.collisionResponse, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : 1, this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, this.material = t.material ? t.material : null, this.body = null
    }
    i(1), i(13), i(55), n.prototype.constructor = n, n.prototype.updateBoundingSphereRadius = function() {
        throw "computeBoundingSphereRadius() not implemented for shape type " + this.type
    }, n.prototype.volume = function() {
        throw "volume() not implemented for shape type " + this.type
    }, n.prototype.calculateLocalInertia = function(t, e) {
        throw "calculateLocalInertia() not implemented for shape type " + this.type
    }, n.idCounter = 0, n.types = {
        SPHERE: 1,
        PLANE: 2,
        BOX: 4,
        COMPOUND: 8,
        CONVEXPOLYHEDRON: 16,
        HEIGHTFIELD: 32,
        PARTICLE: 64,
        CYLINDER: 128,
        TRIMESH: 256
    }
}, , , , , function(t, e, i) {
    t.exports = r;
    var n = i(1);

    function r(t, e, i, n) {
        this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0, this.z = void 0 !== i ? i : 0, this.w = void 0 !== n ? n : 1
    }
    r.prototype.set = function(t, e, i, n) {
        return this.x = t, this.y = e, this.z = i, this.w = n, this
    }, r.prototype.toString = function() {
        return this.x + "," + this.y + "," + this.z + "," + this.w
    }, r.prototype.toArray = function() {
        return [this.x, this.y, this.z, this.w]
    }, r.prototype.setFromAxisAngle = function(t, e) {
        var i = Math.sin(.5 * e);
        return this.x = t.x * i, this.y = t.y * i, this.z = t.z * i, this.w = Math.cos(.5 * e), this
    }, r.prototype.toAxisAngle = function(t) {
        t = t || new n, this.normalize();
        var e = 2 * Math.acos(this.w),
            i = Math.sqrt(1 - this.w * this.w);
        return i < .001 ? (t.x = this.x, t.y = this.y, t.z = this.z) : (t.x = this.x / i, t.y = this.y / i, t.z = this.z / i), [t, e]
    };
    var o = new n,
        a = new n;
    r.prototype.setFromVectors = function(t, e) {
        if (t.isAntiparallelTo(e)) {
            var i = o,
                n = a;
            t.tangents(i, n), this.setFromAxisAngle(i, Math.PI)
        } else {
            var r = t.cross(e);
            this.x = r.x, this.y = r.y, this.z = r.z, this.w = Math.sqrt(Math.pow(t.norm(), 2) * Math.pow(e.norm(), 2)) + t.dot(e), this.normalize()
        }
        return this
    }, new n, new n, new n, r.prototype.mult = function(t, e) {
        e = e || new r;
        var i = this.x,
            n = this.y,
            o = this.z,
            a = this.w,
            s = t.x,
            l = t.y,
            h = t.z,
            c = t.w;
        return e.x = i * c + a * s + n * h - o * l, e.y = n * c + a * l + o * s - i * h, e.z = o * c + a * h + i * l - n * s, e.w = a * c - i * s - n * l - o * h, e
    }, r.prototype.inverse = function(t) {
        var e = this.x,
            i = this.y,
            n = this.z,
            o = this.w;
        t = t || new r, this.conjugate(t);
        var a = 1 / (e * e + i * i + n * n + o * o);
        return t.x *= a, t.y *= a, t.z *= a, t.w *= a, t
    }, r.prototype.conjugate = function(t) {
        return (t = t || new r).x = -this.x, t.y = -this.y, t.z = -this.z, t.w = this.w, t
    }, r.prototype.normalize = function() {
        var t = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this.w *= t), this
    }, r.prototype.normalizeFast = function() {
        var t = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
        return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t, this.y *= t, this.z *= t, this.w *= t), this
    }, r.prototype.vmult = function(t, e) {
        e = e || new n;
        var i = t.x,
            r = t.y,
            o = t.z,
            a = this.x,
            s = this.y,
            l = this.z,
            h = this.w,
            c = h * i + s * o - l * r,
            u = h * r + l * i - a * o,
            p = h * o + a * r - s * i,
            d = -a * i - s * r - l * o;
        return e.x = c * h + d * -a + u * -l - p * -s, e.y = u * h + d * -s + p * -a - c * -l, e.z = p * h + d * -l + c * -s - u * -a, e
    }, r.prototype.copy = function(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this
    }, r.prototype.toEuler = function(t, e) {
        var i, n, r;
        e = e || "YZX";
        var o = this.x,
            a = this.y,
            s = this.z,
            l = this.w;
        switch (e) {
            case "YZX":
                var h = o * a + s * l;
                if (h > .499 && (i = 2 * Math.atan2(o, l), n = Math.PI / 2, r = 0), h < -.499 && (i = -2 * Math.atan2(o, l), n = -Math.PI / 2, r = 0), isNaN(i)) {
                    var c = o * o,
                        u = a * a,
                        p = s * s;
                    i = Math.atan2(2 * a * l - 2 * o * s, 1 - 2 * u - 2 * p), n = Math.asin(2 * h), r = Math.atan2(2 * o * l - 2 * a * s, 1 - 2 * c - 2 * p)
                }
                break;
            default:
                throw new Error("Euler order " + e + " not supported yet.")
        }
        t.y = i, t.z = n, t.x = r
    }, r.prototype.setFromEuler = function(t, e, i, n) {
        n = n || "XYZ";
        var r = Math.cos(t / 2),
            o = Math.cos(e / 2),
            a = Math.cos(i / 2),
            s = Math.sin(t / 2),
            l = Math.sin(e / 2),
            h = Math.sin(i / 2);
        return "XYZ" === n ? (this.x = s * o * a + r * l * h, this.y = r * l * a - s * o * h, this.z = r * o * h + s * l * a, this.w = r * o * a - s * l * h) : "YXZ" === n ? (this.x = s * o * a + r * l * h, this.y = r * l * a - s * o * h, this.z = r * o * h - s * l * a, this.w = r * o * a + s * l * h) : "ZXY" === n ? (this.x = s * o * a - r * l * h, this.y = r * l * a + s * o * h, this.z = r * o * h + s * l * a, this.w = r * o * a - s * l * h) : "ZYX" === n ? (this.x = s * o * a - r * l * h, this.y = r * l * a + s * o * h, this.z = r * o * h - s * l * a, this.w = r * o * a + s * l * h) : "YZX" === n ? (this.x = s * o * a + r * l * h, this.y = r * l * a + s * o * h, this.z = r * o * h - s * l * a, this.w = r * o * a - s * l * h) : "XZY" === n && (this.x = s * o * a - r * l * h, this.y = r * l * a - s * o * h, this.z = r * o * h + s * l * a, this.w = r * o * a + s * l * h), this
    }, r.prototype.clone = function() {
        return new r(this.x, this.y, this.z, this.w)
    }, r.prototype.slerp = function(t, e, i) {
        i = i || new r;
        var n, o, a, s, l, h = this.x,
            c = this.y,
            u = this.z,
            p = this.w,
            d = t.x,
            f = t.y,
            m = t.z,
            v = t.w;
        return (o = h * d + c * f + u * m + p * v) < 0 && (o = -o, d = -d, f = -f, m = -m, v = -v), 1 - o > 1e-6 ? (n = Math.acos(o), a = Math.sin(n), s = Math.sin((1 - e) * n) / a, l = Math.sin(e * n) / a) : (s = 1 - e, l = e), i.x = s * h + l * d, i.y = s * c + l * f, i.z = s * u + l * m, i.w = s * p + l * v, i
    }, r.prototype.integrate = function(t, e, i, n) {
        n = n || new r;
        var o = t.x * i.x,
            a = t.y * i.y,
            s = t.z * i.z,
            l = this.x,
            h = this.y,
            c = this.z,
            u = this.w,
            p = .5 * e;
        return n.x += p * (o * u + a * c - s * h), n.y += p * (a * u + s * l - o * c), n.z += p * (s * u + o * h - a * l), n.w += p * (-o * l - a * h - s * c), n
    }
}, , , , , function(t, e) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, , , , , , function(t, e, i) {
    t.exports = o;
    var n = i(39),
        r = i(1);

    function o(t, e, i) {
        i = void 0 !== i ? i : 1e6, n.call(this, t, e, 0, i), this.restitution = 0, this.ri = new r, this.rj = new r, this.ni = new r
    }
    i(25), o.prototype = new n, o.prototype.constructor = o;
    var a = new r,
        s = new r,
        l = new r;
    o.prototype.computeB = function(t) {
        var e = this.a,
            i = this.b,
            n = this.bi,
            r = this.bj,
            o = this.ri,
            h = this.rj,
            c = a,
            u = s,
            p = n.velocity,
            d = n.angularVelocity,
            f = (n.force, n.torque, r.velocity),
            m = r.angularVelocity,
            v = (r.force, r.torque, l),
            g = this.jacobianElementA,
            y = this.jacobianElementB,
            _ = this.ni;
        o.cross(_, c), h.cross(_, u), _.negate(g.spatial), c.negate(g.rotational), y.spatial.copy(_), y.rotational.copy(u), v.copy(r.position), v.vadd(h, v), v.vsub(n.position, v), v.vsub(o, v);
        var x = _.dot(v),
            b = this.restitution + 1;
        return -x * e - (b * f.dot(_) - b * p.dot(_) + m.dot(u) - d.dot(c)) * i - t * this.computeGiMf()
    };
    var h = new r,
        c = new r,
        u = new r,
        p = new r,
        d = new r;
    o.prototype.getImpactVelocityAlongNormal = function() {
        var t = h,
            e = c,
            i = u,
            n = p,
            r = d;
        return this.bi.position.vadd(this.ri, i), this.bj.position.vadd(this.rj, n), this.bi.getVelocityAtWorldPoint(i, t), this.bj.getVelocityAtWorldPoint(n, e), t.vsub(e, r), this.ni.dot(r)
    }
}, function(t, e, i) {
    t.exports = r;
    var n = i(1);

    function r(t) {
        this.elements = t || [0, 0, 0, 0, 0, 0, 0, 0, 0]
    }
    r.prototype.identity = function() {
        var t = this.elements;
        t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1
    }, r.prototype.setZero = function() {
        var t = this.elements;
        t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0
    }, r.prototype.setTrace = function(t) {
        var e = this.elements;
        e[0] = t.x, e[4] = t.y, e[8] = t.z
    }, r.prototype.getTrace = function(t) {
        t = t || new n;
        var e = this.elements;
        t.x = e[0], t.y = e[4], t.z = e[8]
    }, r.prototype.vmult = function(t, e) {
        e = e || new n;
        var i = this.elements,
            r = t.x,
            o = t.y,
            a = t.z;
        return e.x = i[0] * r + i[1] * o + i[2] * a, e.y = i[3] * r + i[4] * o + i[5] * a, e.z = i[6] * r + i[7] * o + i[8] * a, e
    }, r.prototype.smult = function(t) {
        for (var e = 0; e < this.elements.length; e++) this.elements[e] *= t
    }, r.prototype.mmult = function(t, e) {
        for (var i = e || new r, n = 0; n < 3; n++)
            for (var o = 0; o < 3; o++) {
                for (var a = 0, s = 0; s < 3; s++) a += t.elements[n + 3 * s] * this.elements[s + 3 * o];
                i.elements[n + 3 * o] = a
            }
        return i
    }, r.prototype.scale = function(t, e) {
        e = e || new r;
        for (var i = this.elements, n = e.elements, o = 0; 3 !== o; o++) n[3 * o + 0] = t.x * i[3 * o + 0], n[3 * o + 1] = t.y * i[3 * o + 1], n[3 * o + 2] = t.z * i[3 * o + 2];
        return e
    }, r.prototype.solve = function(t, e) {
        e = e || new n;
        for (var i, r = [], o = 0; o < 12; o++) r.push(0);
        for (o = 0; o < 3; o++)
            for (i = 0; i < 3; i++) r[o + 4 * i] = this.elements[o + 3 * i];
        r[3] = t.x, r[7] = t.y, r[11] = t.z;
        var a, s, l = 3,
            h = l;
        do {
            if (0 === r[(o = h - l) + 4 * o])
                for (i = o + 1; i < h; i++)
                    if (0 !== r[o + 4 * i]) {
                        a = 4;
                        do {
                            r[(s = 4 - a) + 4 * o] += r[s + 4 * i]
                        } while (--a);
                        break
                    }
            if (0 !== r[o + 4 * o])
                for (i = o + 1; i < h; i++) {
                    var c = r[o + 4 * i] / r[o + 4 * o];
                    a = 4;
                    do {
                        r[(s = 4 - a) + 4 * i] = s <= o ? 0 : r[s + 4 * i] - r[s + 4 * o] * c
                    } while (--a)
                }
        } while (--l);
        if (e.z = r[11] / r[10], e.y = (r[7] - r[6] * e.z) / r[5], e.x = (r[3] - r[2] * e.z - r[1] * e.y) / r[0], isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || e.x === 1 / 0 || e.y === 1 / 0 || e.z === 1 / 0) throw "Could not solve equation! Got x=[" + e.toString() + "], b=[" + t.toString() + "], A=[" + this.toString() + "]";
        return e
    }, r.prototype.e = function(t, e, i) {
        if (void 0 === i) return this.elements[e + 3 * t];
        this.elements[e + 3 * t] = i
    }, r.prototype.copy = function(t) {
        for (var e = 0; e < t.elements.length; e++) this.elements[e] = t.elements[e];
        return this
    }, r.prototype.toString = function() {
        for (var t = "", e = 0; e < 9; e++) t += this.elements[e] + ",";
        return t
    }, r.prototype.reverse = function(t) {
        t = t || new r;
        for (var e, i = [], n = 0; n < 18; n++) i.push(0);
        for (n = 0; n < 3; n++)
            for (e = 0; e < 3; e++) i[n + 6 * e] = this.elements[n + 3 * e];
        i[3] = 1, i[9] = 0, i[15] = 0, i[4] = 0, i[10] = 1, i[16] = 0, i[5] = 0, i[11] = 0, i[17] = 1;
        var o, a, s = 3,
            l = s;
        do {
            if (0 === i[(n = l - s) + 6 * n])
                for (e = n + 1; e < l; e++)
                    if (0 !== i[n + 6 * e]) {
                        o = 6;
                        do {
                            i[(a = 6 - o) + 6 * n] += i[a + 6 * e]
                        } while (--o);
                        break
                    }
            if (0 !== i[n + 6 * n])
                for (e = n + 1; e < l; e++) {
                    var h = i[n + 6 * e] / i[n + 6 * n];
                    o = 6;
                    do {
                        i[(a = 6 - o) + 6 * e] = a <= n ? 0 : i[a + 6 * e] - i[a + 6 * n] * h
                    } while (--o)
                }
        } while (--s);
        n = 2;
        do {
            e = n - 1;
            do {
                h = i[n + 6 * e] / i[n + 6 * n], o = 6;
                do {
                    i[(a = 6 - o) + 6 * e] = i[a + 6 * e] - i[a + 6 * n] * h
                } while (--o)
            } while (e--)
        } while (--n);
        n = 2;
        do {
            h = 1 / i[n + 6 * n], o = 6;
            do {
                i[(a = 6 - o) + 6 * n] = i[a + 6 * n] * h
            } while (--o)
        } while (n--);
        n = 2;
        do {
            e = 2;
            do {
                if (a = i[3 + e + 6 * n], isNaN(a) || a === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                t.e(n, e, a)
            } while (e--)
        } while (n--);
        return t
    }, r.prototype.setRotationFromQuaternion = function(t) {
        var e = t.x,
            i = t.y,
            n = t.z,
            r = t.w,
            o = e + e,
            a = i + i,
            s = n + n,
            l = e * o,
            h = e * a,
            c = e * s,
            u = i * a,
            p = i * s,
            d = n * s,
            f = r * o,
            m = r * a,
            v = r * s,
            g = this.elements;
        return g[0] = 1 - (u + d), g[1] = h - v, g[2] = c + m, g[3] = h + v, g[4] = 1 - (l + d), g[5] = p - f, g[6] = c - m, g[7] = p + f, g[8] = 1 - (l + u), this
    }, r.prototype.transpose = function(t) {
        for (var e = (t = t || new r).elements, i = this.elements, n = 0; 3 !== n; n++)
            for (var o = 0; 3 !== o; o++) e[3 * n + o] = i[3 * o + n];
        return t
    }
}, function(t, e, i) {
    var n = i(1);

    function r(t) {
        t = t || {}, this.lowerBound = new n, t.lowerBound && this.lowerBound.copy(t.lowerBound), this.upperBound = new n, t.upperBound && this.upperBound.copy(t.upperBound)
    }
    i(56), t.exports = r;
    var o = new n;
    r.prototype.setFromPoints = function(t, e, i, n) {
        var r = this.lowerBound,
            a = this.upperBound,
            s = i;
        r.copy(t[0]), s && s.vmult(r, r), a.copy(r);
        for (var l = 1; l < t.length; l++) {
            var h = t[l];
            s && (s.vmult(h, o), h = o), h.x > a.x && (a.x = h.x), h.x < r.x && (r.x = h.x), h.y > a.y && (a.y = h.y), h.y < r.y && (r.y = h.y), h.z > a.z && (a.z = h.z), h.z < r.z && (r.z = h.z)
        }
        return e && (e.vadd(r, r), e.vadd(a, a)), n && (r.x -= n, r.y -= n, r.z -= n, a.x += n, a.y += n, a.z += n), this
    }, r.prototype.copy = function(t) {
        return this.lowerBound.copy(t.lowerBound), this.upperBound.copy(t.upperBound), this
    }, r.prototype.clone = function() {
        return (new r).copy(this)
    }, r.prototype.extend = function(t) {
        this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z)
    }, r.prototype.overlaps = function(t) {
        var e = this.lowerBound,
            i = this.upperBound,
            n = t.lowerBound,
            r = t.upperBound,
            o = n.x <= i.x && i.x <= r.x || e.x <= r.x && r.x <= i.x,
            a = n.y <= i.y && i.y <= r.y || e.y <= r.y && r.y <= i.y,
            s = n.z <= i.z && i.z <= r.z || e.z <= r.z && r.z <= i.z;
        return o && a && s
    }, r.prototype.volume = function() {
        var t = this.lowerBound,
            e = this.upperBound;
        return (e.x - t.x) * (e.y - t.y) * (e.z - t.z)
    }, r.prototype.contains = function(t) {
        var e = this.lowerBound,
            i = this.upperBound,
            n = t.lowerBound,
            r = t.upperBound;
        return e.x <= n.x && i.x >= r.x && e.y <= n.y && i.y >= r.y && e.z <= n.z && i.z >= r.z
    }, r.prototype.getCorners = function(t, e, i, n, r, o, a, s) {
        var l = this.lowerBound,
            h = this.upperBound;
        t.copy(l), e.set(h.x, l.y, l.z), i.set(h.x, h.y, l.z), n.set(l.x, h.y, h.z), r.set(h.x, l.y, l.z), o.set(l.x, h.y, l.z), a.set(l.x, l.y, h.z), s.copy(h)
    };
    var a = [new n, new n, new n, new n, new n, new n, new n, new n];
    r.prototype.toLocalFrame = function(t, e) {
        var i = a,
            n = i[0],
            r = i[1],
            o = i[2],
            s = i[3],
            l = i[4],
            h = i[5],
            c = i[6],
            u = i[7];
        this.getCorners(n, r, o, s, l, h, c, u);
        for (var p = 0; 8 !== p; p++) {
            var d = i[p];
            t.pointToLocal(d, d)
        }
        return e.setFromPoints(i)
    }, r.prototype.toWorldFrame = function(t, e) {
        var i = a,
            n = i[0],
            r = i[1],
            o = i[2],
            s = i[3],
            l = i[4],
            h = i[5],
            c = i[6],
            u = i[7];
        this.getCorners(n, r, o, s, l, h, c, u);
        for (var p = 0; 8 !== p; p++) {
            var d = i[p];
            t.pointToWorld(d, d)
        }
        return e.setFromPoints(i)
    }, r.prototype.overlapsRay = function(t) {
        var e = 1 / t._direction.x,
            i = 1 / t._direction.y,
            n = 1 / t._direction.z,
            r = (this.lowerBound.x - t.from.x) * e,
            o = (this.upperBound.x - t.from.x) * e,
            a = (this.lowerBound.y - t.from.y) * i,
            s = (this.upperBound.y - t.from.y) * i,
            l = (this.lowerBound.z - t.from.z) * n,
            h = (this.upperBound.z - t.from.z) * n,
            c = Math.max(Math.max(Math.min(r, o), Math.min(a, s)), Math.min(l, h)),
            u = Math.min(Math.min(Math.max(r, o), Math.max(a, s)), Math.max(l, h));
        return !(u < 0 || c > u)
    }
}, , , , function(t, e, i) {
    t.exports = h;
    var n = i(90),
        r = (i(8), i(1)),
        o = i(25),
        a = i(13),
        s = (i(55), i(26)),
        l = i(75);

    function h(t) {
        t = t || {}, n.apply(this), this.id = h.idCounter++, this.world = null, this.preStep = null, this.postStep = null, this.vlambda = new r, this.collisionFilterGroup = "number" == typeof t.collisionFilterGroup ? t.collisionFilterGroup : 1, this.collisionFilterMask = "number" == typeof t.collisionFilterMask ? t.collisionFilterMask : -1, this.collisionResponse = !0, this.position = new r, this.previousPosition = new r, this.interpolatedPosition = new r, this.initPosition = new r, t.position && (this.position.copy(t.position), this.previousPosition.copy(t.position), this.interpolatedPosition.copy(t.position), this.initPosition.copy(t.position)), this.velocity = new r, t.velocity && this.velocity.copy(t.velocity), this.initVelocity = new r, this.force = new r;
        var e = "number" == typeof t.mass ? t.mass : 0;
        this.mass = e, this.invMass = e > 0 ? 1 / e : 0, this.material = t.material || null, this.linearDamping = "number" == typeof t.linearDamping ? t.linearDamping : .01, this.type = e <= 0 ? h.STATIC : h.DYNAMIC, typeof t.type == typeof h.STATIC && (this.type = t.type), this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.sleepState = 0, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .1, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new r, this.quaternion = new a, this.initQuaternion = new a, this.previousQuaternion = new a, this.interpolatedQuaternion = new a, t.quaternion && (this.quaternion.copy(t.quaternion), this.initQuaternion.copy(t.quaternion), this.previousQuaternion.copy(t.quaternion), this.interpolatedQuaternion.copy(t.quaternion)), this.angularVelocity = new r, t.angularVelocity && this.angularVelocity.copy(t.angularVelocity), this.initAngularVelocity = new r, this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new r, this.invInertia = new r, this.invInertiaWorld = new o, this.invMassSolve = 0, this.invInertiaSolve = new r, this.invInertiaWorldSolve = new o, this.fixedRotation = void 0 !== t.fixedRotation && t.fixedRotation, this.angularDamping = void 0 !== t.angularDamping ? t.angularDamping : .01, this.linearFactor = new r(1, 1, 1), t.linearFactor && this.linearFactor.copy(t.linearFactor), this.angularFactor = new r(1, 1, 1), t.angularFactor && this.angularFactor.copy(t.angularFactor), this.aabb = new s, this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new r, t.shape && this.addShape(t.shape), this.updateMassProperties()
    }
    h.prototype = new n, h.prototype.constructor = h, h.COLLIDE_EVENT_NAME = "collide", h.DYNAMIC = 1, h.STATIC = 2, h.KINEMATIC = 4, h.AWAKE = 0, h.SLEEPY = 1, h.SLEEPING = 2, h.idCounter = 0, h.wakeupEvent = {
        type: "wakeup"
    }, h.prototype.wakeUp = function() {
        var t = this.sleepState;
        this.sleepState = 0, this._wakeUpAfterNarrowphase = !1, t === h.SLEEPING && this.dispatchEvent(h.wakeupEvent)
    }, h.prototype.sleep = function() {
        this.sleepState = h.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this._wakeUpAfterNarrowphase = !1
    }, h.sleepyEvent = {
        type: "sleepy"
    }, h.sleepEvent = {
        type: "sleep"
    }, h.prototype.sleepTick = function(t) {
        if (this.allowSleep) {
            var e = this.sleepState,
                i = this.velocity.norm2() + this.angularVelocity.norm2(),
                n = Math.pow(this.sleepSpeedLimit, 2);
            e === h.AWAKE && i < n ? (this.sleepState = h.SLEEPY, this.timeLastSleepy = t, this.dispatchEvent(h.sleepyEvent)) : e === h.SLEEPY && i > n ? this.wakeUp() : e === h.SLEEPY && t - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(h.sleepEvent))
        }
    }, h.prototype.updateSolveMassProperties = function() {
        this.sleepState === h.SLEEPING || this.type === h.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld))
    }, h.prototype.pointToLocalFrame = function(t, e) {
        return e = e || new r, t.vsub(this.position, e), this.quaternion.conjugate().vmult(e, e), e
    }, h.prototype.vectorToLocalFrame = function(t, e) {
        return e = e || new r, this.quaternion.conjugate().vmult(t, e), e
    }, h.prototype.pointToWorldFrame = function(t, e) {
        return e = e || new r, this.quaternion.vmult(t, e), e.vadd(this.position, e), e
    }, h.prototype.vectorToWorldFrame = function(t, e) {
        return e = e || new r, this.quaternion.vmult(t, e), e
    };
    var c = new r,
        u = new a;
    h.prototype.addShape = function(t, e, i) {
        var n = new r,
            o = new a;
        return e && n.copy(e), i && o.copy(i), this.shapes.push(t), this.shapeOffsets.push(n), this.shapeOrientations.push(o), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, t.body = this, this
    }, h.prototype.updateBoundingRadius = function() {
        for (var t = this.shapes, e = this.shapeOffsets, i = t.length, n = 0, r = 0; r !== i; r++) {
            var o = t[r];
            o.updateBoundingSphereRadius();
            var a = e[r].norm(),
                s = o.boundingSphereRadius;
            a + s > n && (n = a + s)
        }
        this.boundingRadius = n
    };
    var p = new s;
    h.prototype.computeAABB = function() {
        for (var t = this.shapes, e = this.shapeOffsets, i = this.shapeOrientations, n = t.length, r = c, o = u, a = this.quaternion, s = this.aabb, l = p, h = 0; h !== n; h++) {
            var d = t[h];
            a.vmult(e[h], r), r.vadd(this.position, r), i[h].mult(a, o), d.calculateWorldAABB(r, o, l.lowerBound, l.upperBound), 0 === h ? s.copy(l) : s.extend(l)
        }
        this.aabbNeedsUpdate = !1
    };
    var d = new o,
        f = new o;
    new o, h.prototype.updateInertiaWorld = function(t) {
        var e = this.invInertia;
        if (e.x !== e.y || e.y !== e.z || t) {
            var i = d,
                n = f;
            i.setRotationFromQuaternion(this.quaternion), i.transpose(n), i.scale(e, i), i.mmult(n, this.invInertiaWorld)
        }
    }, new r;
    var m = new r;
    h.prototype.applyForce = function(t, e) {
        if (this.type === h.DYNAMIC) {
            var i = m;
            e.cross(t, i), this.force.vadd(t, this.force), this.torque.vadd(i, this.torque)
        }
    };
    var v = new r,
        g = new r;
    h.prototype.applyLocalForce = function(t, e) {
        if (this.type === h.DYNAMIC) {
            var i = v,
                n = g;
            this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, n), this.applyForce(i, n)
        }
    }, new r;
    var y = new r,
        _ = new r;
    h.prototype.applyImpulse = function(t, e) {
        if (this.type === h.DYNAMIC) {
            var i = e,
                n = y;
            n.copy(t), n.mult(this.invMass, n), this.velocity.vadd(n, this.velocity);
            var r = _;
            i.cross(t, r), this.invInertiaWorld.vmult(r, r), this.angularVelocity.vadd(r, this.angularVelocity)
        }
    };
    var x = new r,
        b = new r;
    h.prototype.applyLocalImpulse = function(t, e) {
        if (this.type === h.DYNAMIC) {
            var i = x,
                n = b;
            this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, n), this.applyImpulse(i, n)
        }
    };
    var w = new r;
    h.prototype.updateMassProperties = function() {
        var t = w;
        this.invMass = this.mass > 0 ? 1 / this.mass : 0;
        var e = this.inertia,
            i = this.fixedRotation;
        this.computeAABB(), t.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), l.calculateInertia(t, this.mass, e), this.invInertia.set(e.x > 0 && !i ? 1 / e.x : 0, e.y > 0 && !i ? 1 / e.y : 0, e.z > 0 && !i ? 1 / e.z : 0), this.updateInertiaWorld(!0)
    }, h.prototype.getVelocityAtWorldPoint = function(t, e) {
        var i = new r;
        return t.vsub(this.position, i), this.angularVelocity.cross(i, e), this.velocity.vadd(e, e), e
    }, new r, new r, new a, new a, h.prototype.integrate = function(t, e, i) {
        if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), (this.type === h.DYNAMIC || this.type === h.KINEMATIC) && this.sleepState !== h.SLEEPING) {
            var n = this.velocity,
                r = this.angularVelocity,
                o = this.position,
                a = this.force,
                s = this.torque,
                l = this.quaternion,
                c = this.invMass,
                u = this.invInertiaWorld,
                p = this.linearFactor,
                d = c * t;
            n.x += a.x * d * p.x, n.y += a.y * d * p.y, n.z += a.z * d * p.z;
            var f = u.elements,
                m = this.angularFactor,
                v = s.x * m.x,
                g = s.y * m.y,
                y = s.z * m.z;
            r.x += t * (f[0] * v + f[1] * g + f[2] * y), r.y += t * (f[3] * v + f[4] * g + f[5] * y), r.z += t * (f[6] * v + f[7] * g + f[8] * y), o.x += n.x * t, o.y += n.y * t, o.z += n.z * t, l.integrate(this.angularVelocity, t, this.angularFactor, l), e && (i ? l.normalizeFast() : l.normalize()), this.aabbNeedsUpdate = !0, this.updateInertiaWorld()
        }
    }
}, , , , , , , , function(t, e) {
    var i, n, r = t.exports = {};

    function o() {
        throw new Error("setTimeout has not been defined")
    }

    function a() {
        throw new Error("clearTimeout has not been defined")
    }

    function s(t) {
        if (i === setTimeout) return setTimeout(t, 0);
        if ((i === o || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0);
        try {
            return i(t, 0)
        } catch (e) {
            try {
                return i.call(null, t, 0)
            } catch (e) {
                return i.call(this, t, 0)
            }
        }
    }! function() {
        try {
            i = "function" == typeof setTimeout ? setTimeout : o
        } catch (t) {
            i = o
        }
        try {
            n = "function" == typeof clearTimeout ? clearTimeout : a
        } catch (t) {
            n = a
        }
    }();
    var l, h = [],
        c = !1,
        u = -1;

    function p() {
        c && l && (c = !1, l.length ? h = l.concat(h) : u = -1, h.length && d())
    }

    function d() {
        if (!c) {
            var t = s(p);
            c = !0;
            for (var e = h.length; e;) {
                for (l = h, h = []; ++u < e;) l && l[u].run();
                u = -1, e = h.length
            }
            l = null, c = !1,
                function(t) {
                    if (n === clearTimeout) return clearTimeout(t);
                    if ((n === a || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t);
                    try {
                        n(t)
                    } catch (e) {
                        try {
                            return n.call(null, t)
                        } catch (e) {
                            return n.call(this, t)
                        }
                    }
                }(t)
        }
    }

    function f(t, e) {
        this.fun = t, this.array = e
    }

    function m() {}
    r.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        h.push(new f(t, e)), 1 !== h.length || c || s(d)
    }, f.prototype.run = function() {
        this.fun.apply(null, this.array)
    }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = m, r.addListener = m, r.once = m, r.off = m, r.removeListener = m, r.removeAllListeners = m, r.emit = m, r.prependListener = m, r.prependOnceListener = m, r.listeners = function(t) {
        return []
    }, r.binding = function(t) {
        throw new Error("process.binding is not supported")
    }, r.cwd = function() {
        return "/"
    }, r.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }, r.umask = function() {
        return 0
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(222),
        r = i(1);

    function o(t, e, i, r) {
        this.id = o.id++, this.minForce = void 0 === i ? -1e6 : i, this.maxForce = void 0 === r ? 1e6 : r, this.bi = t, this.bj = e, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new n, this.jacobianElementB = new n, this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60)
    }
    o.prototype.constructor = o, o.id = 0, o.prototype.setSpookParams = function(t, e, i) {
        var n = e,
            r = t,
            o = i;
        this.a = 4 / (o * (1 + 4 * n)), this.b = 4 * n / (1 + 4 * n), this.eps = 4 / (o * o * r * (1 + 4 * n))
    }, o.prototype.computeB = function(t, e, i) {
        var n = this.computeGW();
        return -this.computeGq() * t - n * e - this.computeGiMf() * i
    }, o.prototype.computeGq = function() {
        var t = this.jacobianElementA,
            e = this.jacobianElementB,
            i = this.bi,
            n = this.bj,
            r = i.position,
            o = n.position;
        return t.spatial.dot(r) + e.spatial.dot(o)
    }, new r, o.prototype.computeGW = function() {
        var t = this.jacobianElementA,
            e = this.jacobianElementB,
            i = this.bi,
            n = this.bj,
            r = i.velocity,
            o = n.velocity,
            a = i.angularVelocity,
            s = n.angularVelocity;
        return t.multiplyVectors(r, a) + e.multiplyVectors(o, s)
    }, o.prototype.computeGWlambda = function() {
        var t = this.jacobianElementA,
            e = this.jacobianElementB,
            i = this.bi,
            n = this.bj,
            r = i.vlambda,
            o = n.vlambda,
            a = i.wlambda,
            s = n.wlambda;
        return t.multiplyVectors(r, a) + e.multiplyVectors(o, s)
    };
    var a = new r,
        s = new r,
        l = new r,
        h = new r;
    o.prototype.computeGiMf = function() {
        var t = this.jacobianElementA,
            e = this.jacobianElementB,
            i = this.bi,
            n = this.bj,
            r = i.force,
            o = i.torque,
            c = n.force,
            u = n.torque,
            p = i.invMassSolve,
            d = n.invMassSolve;
        return r.scale(p, a), c.scale(d, s), i.invInertiaWorldSolve.vmult(o, l), n.invInertiaWorldSolve.vmult(u, h), t.multiplyVectors(a, l) + e.multiplyVectors(s, h)
    };
    var c = new r;
    o.prototype.computeGiMGt = function() {
        var t = this.jacobianElementA,
            e = this.jacobianElementB,
            i = this.bi,
            n = this.bj,
            r = i.invMassSolve,
            o = n.invMassSolve,
            a = i.invInertiaWorldSolve,
            s = n.invInertiaWorldSolve,
            l = r + o;
        return a.vmult(t.rotational, c), l += c.dot(t.rotational), s.vmult(e.rotational, c), l + c.dot(e.rotational)
    };
    var u = new r;
    new r, new r, new r, new r, new r, o.prototype.addToWlambda = function(t) {
        var e = this.jacobianElementA,
            i = this.jacobianElementB,
            n = this.bi,
            r = this.bj,
            o = u;
        n.vlambda.addScaledVector(n.invMassSolve * t, e.spatial, n.vlambda), r.vlambda.addScaledVector(r.invMassSolve * t, i.spatial, r.vlambda), n.invInertiaWorldSolve.vmult(e.rotational, o), n.wlambda.addScaledVector(t, o, n.wlambda), r.invInertiaWorldSolve.vmult(i.rotational, o), r.wlambda.addScaledVector(t, o, r.wlambda)
    }, o.prototype.computeC = function() {
        return this.computeGiMGt() + this.eps
    }
}, function(t, e, i) {
    t.exports = r;
    var n = i(56);

    function r(t, e, i) {
        i = n.defaults(i, {
            collideConnected: !0,
            wakeUpBodies: !0
        }), this.equations = [], this.bodyA = t, this.bodyB = e, this.id = r.idCounter++, this.collideConnected = i.collideConnected, i.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
    }
    r.prototype.update = function() {
        throw new Error("method update() not implmemented in this Constraint subclass!")
    }, r.prototype.enable = function() {
        for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !0
    }, r.prototype.disable = function() {
        for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !1
    }, r.idCounter = 0
}, function(t, e, i) {
    var n = i(1),
        r = i(13);

    function o(t) {
        t = t || {}, this.position = new n, t.position && this.position.copy(t.position), this.quaternion = new r, t.quaternion && this.quaternion.copy(t.quaternion)
    }
    t.exports = o;
    var a = new r;
    o.pointToLocalFrame = function(t, e, i, r) {
        return r = r || new n, i.vsub(t, r), e.conjugate(a), a.vmult(r, r), r
    }, o.prototype.pointToLocal = function(t, e) {
        return o.pointToLocalFrame(this.position, this.quaternion, t, e)
    }, o.pointToWorldFrame = function(t, e, i, r) {
        return r = r || new n, e.vmult(i, r), r.vadd(t, r), r
    }, o.prototype.pointToWorld = function(t, e) {
        return o.pointToWorldFrame(this.position, this.quaternion, t, e)
    }, o.prototype.vectorToWorldFrame = function(t, e) {
        return e = e || new n, this.quaternion.vmult(t, e), e
    }, o.vectorToWorldFrame = function(t, e, i) {
        return t.vmult(e, i), i
    }, o.vectorToLocalFrame = function(t, e, i, r) {
        return r = r || new n, e.w *= -1, e.vmult(i, r), e.w *= -1, r
    }
}, function(t, e, i) {
    t.exports = a;
    var n = i(8),
        r = i(1),
        o = (i(13), i(41));

    function a(t, e, i) {
        n.call(this, {
            type: n.types.CONVEXPOLYHEDRON
        }), this.vertices = t || [], this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.faces = e || [], this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = i ? i.slice() : null, this.computeEdges(), this.updateBoundingSphereRadius()
    }
    a.prototype = new n, a.prototype.constructor = a;
    var s = new r;
    a.prototype.computeEdges = function() {
        var t = this.faces,
            e = this.vertices,
            i = (e.length, this.uniqueEdges);
        i.length = 0;
        for (var n = s, r = 0; r !== t.length; r++)
            for (var o = t[r], a = o.length, l = 0; l !== a; l++) {
                var h = (l + 1) % a;
                e[o[l]].vsub(e[o[h]], n), n.normalize();
                for (var c = !1, u = 0; u !== i.length; u++)
                    if (i[u].almostEquals(n) || i[u].almostEquals(n)) {
                        c = !0;
                        break
                    }
                c || i.push(n.clone())
            }
    }, a.prototype.computeNormals = function() {
        this.faceNormals.length = this.faces.length;
        for (var t = 0; t < this.faces.length; t++) {
            for (var e = 0; e < this.faces[t].length; e++)
                if (!this.vertices[this.faces[t][e]]) throw new Error("Vertex " + this.faces[t][e] + " not found!");
            var i = this.faceNormals[t] || new r;
            this.getFaceNormal(t, i), i.negate(i), this.faceNormals[t] = i
        }
    };
    var l = new r,
        h = new r;
    a.computeNormal = function(t, e, i, n) {
        e.vsub(t, h), i.vsub(e, l), l.cross(h, n), n.isZero() || n.normalize()
    }, a.prototype.getFaceNormal = function(t, e) {
        var i = this.faces[t],
            n = this.vertices[i[0]],
            r = this.vertices[i[1]],
            o = this.vertices[i[2]];
        return a.computeNormal(n, r, o, e)
    };
    var c = new r;
    a.prototype.clipAgainstHull = function(t, e, i, n, o, a, s, l, h) {
        for (var u = c, p = -1, d = -Number.MAX_VALUE, f = 0; f < i.faces.length; f++) {
            u.copy(i.faceNormals[f]), o.vmult(u, u);
            var m = u.dot(a);
            m > d && (d = m, p = f)
        }
        for (var v = [], g = i.faces[p], y = g.length, _ = 0; _ < y; _++) {
            var x = i.vertices[g[_]],
                b = new r;
            b.copy(x), o.vmult(b, b), n.vadd(b, b), v.push(b)
        }
        p >= 0 && this.clipFaceAgainstHull(a, t, e, v, s, l, h)
    };
    var u = new r,
        p = new r,
        d = new r,
        f = new r,
        m = new r,
        v = new r;
    a.prototype.findSeparatingAxis = function(t, e, i, n, r, o, a, s) {
        var l = u,
            h = p,
            c = d,
            g = f,
            y = m,
            _ = v,
            x = Number.MAX_VALUE;
        if (this.uniqueAxes)
            for (w = 0; w !== this.uniqueAxes.length; w++) {
                if (i.vmult(this.uniqueAxes[w], l), !1 === (M = this.testSepAxis(l, t, e, i, n, r))) return !1;
                M < x && (x = M, o.copy(l))
            } else
                for (var b = a ? a.length : this.faces.length, w = 0; w < b; w++) {
                    var T = a ? a[w] : w;
                    if (l.copy(this.faceNormals[T]), i.vmult(l, l), !1 === (M = this.testSepAxis(l, t, e, i, n, r))) return !1;
                    M < x && (x = M, o.copy(l))
                }
        if (t.uniqueAxes)
            for (w = 0; w !== t.uniqueAxes.length; w++) {
                if (r.vmult(t.uniqueAxes[w], h), !1 === (M = this.testSepAxis(h, t, e, i, n, r))) return !1;
                M < x && (x = M, o.copy(h))
            } else {
                var E = s ? s.length : t.faces.length;
                for (w = 0; w < E; w++) {
                    var M;
                    if (T = s ? s[w] : w, h.copy(t.faceNormals[T]), r.vmult(h, h), !1 === (M = this.testSepAxis(h, t, e, i, n, r))) return !1;
                    M < x && (x = M, o.copy(h))
                }
            }
        for (var S = 0; S !== this.uniqueEdges.length; S++) {
            i.vmult(this.uniqueEdges[S], g);
            for (var A = 0; A !== t.uniqueEdges.length; A++)
                if (r.vmult(t.uniqueEdges[A], y), g.cross(y, _), !_.almostZero()) {
                    _.normalize();
                    var C = this.testSepAxis(_, t, e, i, n, r);
                    if (!1 === C) return !1;
                    C < x && (x = C, o.copy(_))
                }
        }
        return n.vsub(e, c), c.dot(o) > 0 && o.negate(o), !0
    };
    var g = [],
        y = [];
    a.prototype.testSepAxis = function(t, e, i, n, r, o) {
        a.project(this, t, i, n, g), a.project(e, t, r, o, y);
        var s = g[0],
            l = g[1],
            h = y[0],
            c = y[1];
        if (s < c || h < l) return !1;
        var u = s - c,
            p = h - l;
        return u < p ? u : p
    };
    var _ = new r,
        x = new r;
    a.prototype.calculateLocalInertia = function(t, e) {
        this.computeLocalAABB(_, x);
        var i = x.x - _.x,
            n = x.y - _.y,
            r = x.z - _.z;
        e.x = 1 / 12 * t * (2 * n * 2 * n + 2 * r * 2 * r), e.y = 1 / 12 * t * (2 * i * 2 * i + 2 * r * 2 * r), e.z = 1 / 12 * t * (2 * n * 2 * n + 2 * i * 2 * i)
    }, a.prototype.getPlaneConstantOfFace = function(t) {
        var e = this.faces[t],
            i = this.faceNormals[t],
            n = this.vertices[e[0]];
        return -i.dot(n)
    };
    var b = new r,
        w = new r,
        T = new r,
        E = new r,
        M = new r,
        S = new r,
        A = new r,
        C = new r;
    a.prototype.clipFaceAgainstHull = function(t, e, i, n, r, o, a) {
        for (var s = b, l = w, h = T, c = E, u = M, p = S, d = A, f = C, m = n, v = [], g = -1, y = Number.MAX_VALUE, _ = 0; _ < this.faces.length; _++) {
            s.copy(this.faceNormals[_]), i.vmult(s, s);
            var x = s.dot(t);
            x < y && (y = x, g = _)
        }
        if (!(g < 0)) {
            var R = this.faces[g];
            R.connectedFaces = [];
            for (var P = 0; P < this.faces.length; P++)
                for (var L = 0; L < this.faces[P].length; L++) - 1 !== R.indexOf(this.faces[P][L]) && P !== g && -1 === R.connectedFaces.indexOf(P) && R.connectedFaces.push(P);
            m.length;
            for (var O = R.length, B = 0; B < O; B++) {
                var I = this.vertices[R[B]],
                    N = this.vertices[R[(B + 1) % O]];
                I.vsub(N, l), h.copy(l), i.vmult(h, h), e.vadd(h, h), c.copy(this.faceNormals[g]), i.vmult(c, c), e.vadd(c, c), h.cross(c, u), u.negate(u), p.copy(I), i.vmult(p, p), e.vadd(p, p), p.dot(u);
                var z = R.connectedFaces[B];
                d.copy(this.faceNormals[z]);
                var F = this.getPlaneConstantOfFace(z);
                f.copy(d), i.vmult(f, f);
                var D = F - f.dot(e);
                for (this.clipFaceAgainstPlane(m, v, f, D); m.length;) m.shift();
                for (; v.length;) m.push(v.shift())
            }
            for (d.copy(this.faceNormals[g]), F = this.getPlaneConstantOfFace(g), f.copy(d), i.vmult(f, f), D = F - f.dot(e), P = 0; P < m.length; P++) {
                var U = f.dot(m[P]) + D;
                if (U <= r && (console.log("clamped: depth=" + U + " to minDist=" + r), U = r), U <= o) {
                    var k = m[P];
                    if (U <= 0) {
                        var V = {
                            point: k,
                            normal: f,
                            depth: U
                        };
                        a.push(V)
                    }
                }
            }
        }
    }, a.prototype.clipFaceAgainstPlane = function(t, e, i, n) {
        var o, a, s = t.length;
        if (s < 2) return e;
        var l = t[t.length - 1],
            h = t[0];
        o = i.dot(l) + n;
        for (var c = 0; c < s; c++) {
            if (h = t[c], a = i.dot(h) + n, o < 0)
                if (a < 0)(u = new r).copy(h), e.push(u);
                else {
                    var u = new r;
                    l.lerp(h, o / (o - a), u), e.push(u)
                }
            else a < 0 && (u = new r, l.lerp(h, o / (o - a), u), e.push(u), e.push(h));
            l = h, o = a
        }
        return e
    }, a.prototype.computeWorldVertices = function(t, e) {
        for (var i = this.vertices.length; this.worldVertices.length < i;) this.worldVertices.push(new r);
        for (var n = this.vertices, o = this.worldVertices, a = 0; a !== i; a++) e.vmult(n[a], o[a]), t.vadd(o[a], o[a]);
        this.worldVerticesNeedsUpdate = !1
    }, new r, a.prototype.computeLocalAABB = function(t, e) {
        var i = this.vertices.length,
            n = this.vertices;
        t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (var r = 0; r < i; r++) {
            var o = n[r];
            o.x < t.x ? t.x = o.x : o.x > e.x && (e.x = o.x), o.y < t.y ? t.y = o.y : o.y > e.y && (e.y = o.y), o.z < t.z ? t.z = o.z : o.z > e.z && (e.z = o.z)
        }
    }, a.prototype.computeWorldFaceNormals = function(t) {
        for (var e = this.faceNormals.length; this.worldFaceNormals.length < e;) this.worldFaceNormals.push(new r);
        for (var i = this.faceNormals, n = this.worldFaceNormals, o = 0; o !== e; o++) t.vmult(i[o], n[o]);
        this.worldFaceNormalsNeedsUpdate = !1
    }, a.prototype.updateBoundingSphereRadius = function() {
        for (var t = 0, e = this.vertices, i = 0, n = e.length; i !== n; i++) {
            var r = e[i].norm2();
            r > t && (t = r)
        }
        this.boundingSphereRadius = Math.sqrt(t)
    };
    var R = new r;
    a.prototype.calculateWorldAABB = function(t, e, i, n) {
        for (var r, o, a, s, l, h, c = this.vertices.length, u = this.vertices, p = 0; p < c; p++) {
            R.copy(u[p]), e.vmult(R, R), t.vadd(R, R);
            var d = R;
            d.x < r || void 0 === r ? r = d.x : (d.x > s || void 0 === s) && (s = d.x), d.y < o || void 0 === o ? o = d.y : (d.y > l || void 0 === l) && (l = d.y), d.z < a || void 0 === a ? a = d.z : (d.z > h || void 0 === h) && (h = d.z)
        }
        i.set(r, o, a), n.set(s, l, h)
    }, a.prototype.volume = function() {
        return 4 * Math.PI * this.boundingSphereRadius / 3
    }, a.prototype.getAveragePointLocal = function(t) {
        t = t || new r;
        for (var e = this.vertices.length, i = this.vertices, n = 0; n < e; n++) t.vadd(i[n], t);
        return t.mult(1 / e, t), t
    }, a.prototype.transformAllPoints = function(t, e) {
        var i = this.vertices.length,
            n = this.vertices;
        if (e) {
            for (var r = 0; r < i; r++) {
                var o = n[r];
                e.vmult(o, o)
            }
            for (r = 0; r < this.faceNormals.length; r++) o = this.faceNormals[r], e.vmult(o, o)
        }
        if (t)
            for (r = 0; r < i; r++)(o = n[r]).vadd(t, o)
    };
    var P = new r,
        L = new r,
        O = new r;
    a.prototype.pointIsInside = function(t) {
        var e = this.vertices.length,
            i = this.vertices,
            n = this.faces,
            r = this.faceNormals,
            o = this.faces.length,
            a = P;
        this.getAveragePointLocal(a);
        for (var s = 0; s < o; s++) {
            this.faces[s].length, e = r[s];
            var l = i[n[s][0]],
                h = L;
            t.vsub(l, h);
            var c = e.dot(h),
                u = O;
            a.vsub(l, u);
            var p = e.dot(u);
            if (c < 0 && p > 0 || c > 0 && p < 0) return !1
        }
        return -1
    }, new r;
    var B = new r,
        I = new r;
    a.project = function(t, e, i, n, r) {
        var a = t.vertices.length,
            s = B,
            l = 0,
            h = 0,
            c = I,
            u = t.vertices;
        c.setZero(), o.vectorToLocalFrame(i, n, e, s), o.pointToLocalFrame(i, n, c, c);
        var p = c.dot(s);
        h = l = u[0].dot(s);
        for (var d = 1; d < a; d++) {
            var f = u[d].dot(s);
            f > l && (l = f), f < h && (h = f)
        }
        if ((h -= p) > (l -= p)) {
            var m = h;
            h = l, l = m
        }
        r[0] = l, r[1] = h
    }
}, , , , , , , , , , , , function(t, e, i) {
    var n = i(1);

    function r() {
        this.rayFromWorld = new n, this.rayToWorld = new n, this.hitNormalWorld = new n, this.hitPointWorld = new n, this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1
    }
    t.exports = r, r.prototype.reset = function() {
        this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1
    }, r.prototype.abort = function() {
        this._shouldStop = !0
    }, r.prototype.set = function(t, e, i, n, r, o, a) {
        this.rayFromWorld.copy(t), this.rayToWorld.copy(e), this.hitNormalWorld.copy(i), this.hitPointWorld.copy(n), this.shape = r, this.body = o, this.distance = a
    }
}, function(t, e) {
    function i(t) {
        var e = "";
        "string" == typeof(t = t || {}) ? (e = t, t = {}) : "object" == typeof t && (e = ""), this.name = e, this.id = i.idCounter++, this.friction = void 0 !== t.friction ? t.friction : -1, this.restitution = void 0 !== t.restitution ? t.restitution : -1
    }
    t.exports = i, i.idCounter = 0
}, function(t, e) {
    function i() {}
    t.exports = i, i.defaults = function(t, e) {
        for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
        return t
    }
}, , , , , , , , , , , , , , function(t, e, i) {
    t.exports = o;
    var n = i(1),
        r = (i(25), i(39));

    function o(t, e, i) {
        var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
        r.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.maxAngle = Math.PI / 2
    }
    o.prototype = new r, o.prototype.constructor = o;
    var a = new n,
        s = new n;
    o.prototype.computeB = function(t) {
        var e = this.a,
            i = this.b,
            n = this.axisA,
            r = this.axisB,
            o = a,
            l = s,
            h = this.jacobianElementA,
            c = this.jacobianElementB;
        return n.cross(r, o), r.cross(n, l), h.rotational.copy(l), c.rotational.copy(o), -(Math.cos(this.maxAngle) - n.dot(r)) * e - this.computeGW() * i - t * this.computeGiMf()
    }
}, function(t, e, i) {
    t.exports = a;
    var n = i(40),
        r = i(24),
        o = i(1);

    function a(t, e, i, a, s) {
        n.call(this, t, i), s = void 0 !== s ? s : 1e6, this.pivotA = e ? e.clone() : new o, this.pivotB = a ? a.clone() : new o;
        var l = this.equationX = new r(t, i),
            h = this.equationY = new r(t, i),
            c = this.equationZ = new r(t, i);
        this.equations.push(l, h, c), l.minForce = h.minForce = c.minForce = -s, l.maxForce = h.maxForce = c.maxForce = s, l.ni.set(1, 0, 0), h.ni.set(0, 1, 0), c.ni.set(0, 0, 1)
    }
    a.prototype = new n, a.prototype.update = function() {
        var t = this.bodyA,
            e = this.bodyB,
            i = this.equationX,
            n = this.equationY,
            r = this.equationZ;
        t.quaternion.vmult(this.pivotA, i.ri), e.quaternion.vmult(this.pivotB, i.rj), n.ri.copy(i.ri), n.rj.copy(i.rj), r.ri.copy(i.ri), r.rj.copy(i.rj)
    }
}, function(t, e) {
    function i() {
        this.equations = []
    }
    t.exports = i, i.prototype.solve = function(t, e) {
        return 0
    }, i.prototype.addEquation = function(t) {
        t.enabled && this.equations.push(t)
    }, i.prototype.removeEquation = function(t) {
        var e = this.equations,
            i = e.indexOf(t); - 1 !== i && e.splice(i, 1)
    }, i.prototype.removeAllEquations = function() {
        this.equations.length = 0
    }
}, function(t, e, i) {
    t.exports = h;
    var n = i(1),
        r = i(13),
        o = i(41),
        a = (i(42), i(75), i(54)),
        s = i(8),
        l = i(26);

    function h(t, e) {
        this.from = t ? t.clone() : new n, this.to = e ? e.clone() : new n, this._direction = new n, this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = h.ANY, this.result = new a, this.hasHit = !1, this.callback = function(t) {}
    }
    h.prototype.constructor = h, h.CLOSEST = 1, h.ANY = 2, h.ALL = 4;
    var c = new l,
        u = [];
    h.prototype.intersectWorld = function(t, e) {
        return this.mode = e.mode || h.ANY, this.result = e.result || new a, this.skipBackfaces = !!e.skipBackfaces, this.collisionFilterMask = void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1, this.collisionFilterGroup = void 0 !== e.collisionFilterGroup ? e.collisionFilterGroup : -1, e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || function() {}, this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(c), u.length = 0, t.broadphase.aabbQuery(t, c, u), this.intersectBodies(u), this.hasHit
    };
    var p = new n,
        d = new n;

    function f(t, e, i, n) {
        n.vsub(e, F), i.vsub(e, p), t.vsub(e, d);
        var r, o, a = F.dot(F),
            s = F.dot(p),
            l = F.dot(d),
            h = p.dot(p),
            c = p.dot(d);
        return (r = h * l - s * c) >= 0 && (o = a * c - s * l) >= 0 && r + o < a * h - s * s
    }
    h.pointInTriangle = f;
    var m = new n,
        v = new r;
    h.prototype.intersectBody = function(t, e) {
        e && (this.result = e, this._updateDirection());
        var i = this.checkCollisionResponse;
        if ((!i || t.collisionResponse) && 0 != (this.collisionFilterGroup & t.collisionFilterMask) && 0 != (t.collisionFilterGroup & this.collisionFilterMask))
            for (var n = m, r = v, o = 0, a = t.shapes.length; o < a; o++) {
                var s = t.shapes[o];
                if ((!i || s.collisionResponse) && (t.quaternion.mult(t.shapeOrientations[o], r), t.quaternion.vmult(t.shapeOffsets[o], n), n.vadd(t.position, n), this.intersectShape(s, r, n, t), this.result._shouldStop)) break
            }
    }, h.prototype.intersectBodies = function(t, e) {
        e && (this.result = e, this._updateDirection());
        for (var i = 0, n = t.length; !this.result._shouldStop && i < n; i++) this.intersectBody(t[i])
    }, h.prototype._updateDirection = function() {
        this.to.vsub(this.from, this._direction), this._direction.normalize()
    }, h.prototype.intersectShape = function(t, e, i, n) {
        if (!(function(t, e, i) {
                i.vsub(t, F);
                var n = F.dot(e);
                return e.mult(n, D), D.vadd(t, D), i.distanceTo(D)
            }(this.from, this._direction, i) > t.boundingSphereRadius)) {
            var r = this[t.type];
            r && r.call(this, t, e, i, n, t)
        }
    }, new n, new n;
    var g = new n,
        y = new n,
        _ = new n,
        x = new n;
    new n, new a, h.prototype.intersectBox = function(t, e, i, n, r) {
        return this.intersectConvex(t.convexPolyhedronRepresentation, e, i, n, r)
    }, h.prototype[s.types.BOX] = h.prototype.intersectBox, h.prototype.intersectPlane = function(t, e, i, r, o) {
        var a = this.from,
            s = this.to,
            l = this._direction,
            h = new n(0, 0, 1);
        e.vmult(h, h);
        var c = new n;
        a.vsub(i, c);
        var u = c.dot(h);
        if (s.vsub(i, c), !(u * c.dot(h) > 0 || a.distanceTo(s) < u)) {
            var p = h.dot(l);
            if (!(Math.abs(p) < this.precision)) {
                var d = new n,
                    f = new n,
                    m = new n;
                a.vsub(i, d);
                var v = -h.dot(d) / p;
                l.scale(v, f), a.vadd(f, m), this.reportIntersection(h, m, o, r, -1)
            }
        }
    }, h.prototype[s.types.PLANE] = h.prototype.intersectPlane, h.prototype.getAABB = function(t) {
        var e = this.to,
            i = this.from;
        t.lowerBound.x = Math.min(e.x, i.x), t.lowerBound.y = Math.min(e.y, i.y), t.lowerBound.z = Math.min(e.z, i.z), t.upperBound.x = Math.max(e.x, i.x), t.upperBound.y = Math.max(e.y, i.y), t.upperBound.z = Math.max(e.z, i.z)
    };
    var b = {
            faceList: [0]
        },
        w = new n,
        T = new h,
        E = [];
    h.prototype.intersectHeightfield = function(t, e, i, n, r) {
        t.data, t.elementSize;
        var a = T;
        a.from.copy(this.from), a.to.copy(this.to), o.pointToLocalFrame(i, e, a.from, a.from), o.pointToLocalFrame(i, e, a.to, a.to), a._updateDirection();
        var s, h, c, u, p = E;
        s = h = 0, c = u = t.data.length - 1;
        var d = new l;
        a.getAABB(d), t.getIndexOfPosition(d.lowerBound.x, d.lowerBound.y, p, !0), s = Math.max(s, p[0]), h = Math.max(h, p[1]), t.getIndexOfPosition(d.upperBound.x, d.upperBound.y, p, !0), c = Math.min(c, p[0] + 1), u = Math.min(u, p[1] + 1);
        for (var f = s; f < c; f++)
            for (var m = h; m < u; m++) {
                if (this.result._shouldStop) return;
                if (t.getAabbAtIndex(f, m, d), d.overlapsRay(a)) {
                    if (t.getConvexTrianglePillar(f, m, !1), o.pointToWorldFrame(i, e, t.pillarOffset, w), this.intersectConvex(t.pillarConvex, e, w, n, r, b), this.result._shouldStop) return;
                    t.getConvexTrianglePillar(f, m, !0), o.pointToWorldFrame(i, e, t.pillarOffset, w), this.intersectConvex(t.pillarConvex, e, w, n, r, b)
                }
            }
    }, h.prototype[s.types.HEIGHTFIELD] = h.prototype.intersectHeightfield;
    var M = new n,
        S = new n;
    h.prototype.intersectSphere = function(t, e, i, n, r) {
        var o = this.from,
            a = this.to,
            s = t.radius,
            l = Math.pow(a.x - o.x, 2) + Math.pow(a.y - o.y, 2) + Math.pow(a.z - o.z, 2),
            h = 2 * ((a.x - o.x) * (o.x - i.x) + (a.y - o.y) * (o.y - i.y) + (a.z - o.z) * (o.z - i.z)),
            c = Math.pow(o.x - i.x, 2) + Math.pow(o.y - i.y, 2) + Math.pow(o.z - i.z, 2) - Math.pow(s, 2),
            u = Math.pow(h, 2) - 4 * l * c,
            p = M,
            d = S;
        if (!(u < 0))
            if (0 === u) o.lerp(a, u, p), p.vsub(i, d), d.normalize(), this.reportIntersection(d, p, r, n, -1);
            else {
                var f = (-h - Math.sqrt(u)) / (2 * l),
                    m = (-h + Math.sqrt(u)) / (2 * l);
                if (f >= 0 && f <= 1 && (o.lerp(a, f, p), p.vsub(i, d), d.normalize(), this.reportIntersection(d, p, r, n, -1)), this.result._shouldStop) return;
                m >= 0 && m <= 1 && (o.lerp(a, m, p), p.vsub(i, d), d.normalize(), this.reportIntersection(d, p, r, n, -1))
            }
    }, h.prototype[s.types.SPHERE] = h.prototype.intersectSphere;
    var A = new n,
        C = (new n, new n, new n);
    h.prototype.intersectConvex = function(t, e, i, n, r, o) {
        for (var a = A, s = C, l = o && o.faceList || null, h = t.faces, c = t.vertices, u = t.faceNormals, p = this._direction, d = this.from, m = this.to, v = d.distanceTo(m), b = l ? l.length : h.length, w = this.result, T = 0; !w._shouldStop && T < b; T++) {
            var E = l ? l[T] : T,
                M = h[E],
                S = u[E],
                R = e,
                P = i;
            s.copy(c[M[0]]), R.vmult(s, s), s.vadd(P, s), s.vsub(d, s), R.vmult(S, a);
            var L = p.dot(a);
            if (!(Math.abs(L) < this.precision)) {
                var O = a.dot(s) / L;
                if (!(O < 0)) {
                    p.mult(O, g), g.vadd(d, g), y.copy(c[M[0]]), R.vmult(y, y), P.vadd(y, y);
                    for (var B = 1; !w._shouldStop && B < M.length - 1; B++) {
                        _.copy(c[M[B]]), x.copy(c[M[B + 1]]), R.vmult(_, _), R.vmult(x, x), P.vadd(_, _), P.vadd(x, x);
                        var I = g.distanceTo(d);
                        !f(g, y, _, x) && !f(g, _, y, x) || I > v || this.reportIntersection(a, g, r, n, E)
                    }
                }
            }
        }
    }, h.prototype[s.types.CONVEXPOLYHEDRON] = h.prototype.intersectConvex;
    var R = new n,
        P = new n,
        L = new n,
        O = new n,
        B = new n,
        I = new n,
        N = (new l, []),
        z = new o;
    h.prototype.intersectTrimesh = function(t, e, i, n, r, a) {
        var s = R,
            l = N,
            h = z,
            c = C,
            u = P,
            p = L,
            d = O,
            m = I,
            v = B,
            b = (a && a.faceList, t.indices),
            w = (t.vertices, t.faceNormals, this.from),
            T = this.to,
            E = this._direction;
        h.position.copy(i), h.quaternion.copy(e), o.vectorToLocalFrame(i, e, E, u), o.pointToLocalFrame(i, e, w, p), o.pointToLocalFrame(i, e, T, d), d.x *= t.scale.x, d.y *= t.scale.y, d.z *= t.scale.z, p.x *= t.scale.x, p.y *= t.scale.y, p.z *= t.scale.z, d.vsub(p, u), u.normalize();
        var M = p.distanceSquared(d);
        t.tree.rayQuery(this, h, l);
        for (var S = 0, A = l.length; !this.result._shouldStop && S !== A; S++) {
            var F = l[S];
            t.getNormal(F, s), t.getVertex(b[3 * F], y), y.vsub(p, c);
            var D = u.dot(s),
                U = s.dot(c) / D;
            if (!(U < 0)) {
                u.scale(U, g), g.vadd(p, g), t.getVertex(b[3 * F + 1], _), t.getVertex(b[3 * F + 2], x);
                var k = g.distanceSquared(p);
                !f(g, _, y, x) && !f(g, y, _, x) || k > M || (o.vectorToWorldFrame(e, s, v), o.pointToWorldFrame(i, e, g, m), this.reportIntersection(v, m, r, n, F))
            }
        }
        l.length = 0
    }, h.prototype[s.types.TRIMESH] = h.prototype.intersectTrimesh, h.prototype.reportIntersection = function(t, e, i, n, r) {
        var o = this.from,
            a = this.to,
            s = o.distanceTo(e),
            l = this.result;
        if (!(this.skipBackfaces && t.dot(this._direction) > 0)) switch (l.hitFaceIndex = void 0 !== r ? r : -1, this.mode) {
            case h.ALL:
                this.hasHit = !0, l.set(o, a, t, e, i, n, s), l.hasHit = !0, this.callback(l);
                break;
            case h.CLOSEST:
                (s < l.distance || !l.hasHit) && (this.hasHit = !0, l.hasHit = !0, l.set(o, a, t, e, i, n, s));
                break;
            case h.ANY:
                this.hasHit = !0, l.hasHit = !0, l.set(o, a, t, e, i, n, s), l._shouldStop = !0
        }
    };
    var F = new n,
        D = new n
}, function(t, e, i) {
    var n = i(30),
        r = i(1),
        o = i(13);

    function a() {
        this.world = null, this.useBoundingBoxes = !1, this.dirty = !0
    }
    i(8), i(133), t.exports = a, a.prototype.collisionPairs = function(t, e, i) {
        throw new Error("collisionPairs not implemented for this BroadPhase class!")
    };
    var s = n.STATIC | n.KINEMATIC;
    a.prototype.needBroadphaseCollision = function(t, e) {
        return 0 != (t.collisionFilterGroup & e.collisionFilterMask) && 0 != (e.collisionFilterGroup & t.collisionFilterMask) && (0 == (t.type & s) && t.sleepState !== n.SLEEPING || 0 == (e.type & s) && e.sleepState !== n.SLEEPING)
    }, a.prototype.intersectionTest = function(t, e, i, n) {
        this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t, e, i, n) : this.doBoundingSphereBroadphase(t, e, i, n)
    };
    var l = new r;
    new r, new o, new r, a.prototype.doBoundingSphereBroadphase = function(t, e, i, n) {
        var r = l;
        e.position.vsub(t.position, r);
        var o = Math.pow(t.boundingRadius + e.boundingRadius, 2);
        r.norm2() < o && (i.push(t), n.push(e))
    }, a.prototype.doBoundingBoxBroadphase = function(t, e, i, n) {
        t.aabbNeedsUpdate && t.computeAABB(), e.aabbNeedsUpdate && e.computeAABB(), t.aabb.overlaps(e.aabb) && (i.push(t), n.push(e))
    };
    var h = {
            keys: []
        },
        c = [],
        u = [];
    a.prototype.makePairsUnique = function(t, e) {
        for (var i = h, n = c, r = u, o = t.length, a = 0; a !== o; a++) n[a] = t[a], r[a] = e[a];
        for (t.length = 0, e.length = 0, a = 0; a !== o; a++) {
            var s = n[a].id,
                l = r[a].id;
            i[p = s < l ? s + "," + l : l + "," + s] = a, i.keys.push(p)
        }
        for (a = 0; a !== i.keys.length; a++) {
            var p, d = i[p = i.keys.pop()];
            t.push(n[d]), e.push(r[d]), delete i[p]
        }
    }, a.prototype.setWorld = function(t) {};
    var p = new r;
    a.boundingSphereCheck = function(t, e) {
        var i = p;
        return t.position.vsub(e.position, i), Math.pow(t.shape.boundingSphereRadius + e.shape.boundingSphereRadius, 2) > i.norm2()
    }, a.prototype.aabbQuery = function(t, e, i) {
        return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), []
    }
}, function(t, e, i) {
    t.exports = a;
    var n = i(8),
        r = i(1),
        o = i(42);

    function a(t) {
        n.call(this, {
            type: n.types.BOX
        }), this.halfExtents = t, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius()
    }
    a.prototype = new n, a.prototype.constructor = a, a.prototype.updateConvexPolyhedronRepresentation = function() {
        var t = this.halfExtents.x,
            e = this.halfExtents.y,
            i = this.halfExtents.z,
            n = r,
            a = [new n(-t, -e, -i), new n(t, -e, -i), new n(t, e, -i), new n(-t, e, -i), new n(-t, -e, i), new n(t, -e, i), new n(t, e, i), new n(-t, e, i)],
            s = (new n(0, 0, 1), new n(0, 1, 0), new n(1, 0, 0), new o(a, [
                [3, 2, 1, 0],
                [4, 5, 6, 7],
                [5, 4, 0, 1],
                [2, 3, 7, 6],
                [0, 4, 7, 3],
                [1, 2, 6, 5]
            ]));
        this.convexPolyhedronRepresentation = s, s.material = this.material
    }, a.prototype.calculateLocalInertia = function(t, e) {
        return e = e || new r, a.calculateInertia(this.halfExtents, t, e), e
    }, a.calculateInertia = function(t, e, i) {
        var n = t;
        i.x = 1 / 12 * e * (2 * n.y * 2 * n.y + 2 * n.z * 2 * n.z), i.y = 1 / 12 * e * (2 * n.x * 2 * n.x + 2 * n.z * 2 * n.z), i.z = 1 / 12 * e * (2 * n.y * 2 * n.y + 2 * n.x * 2 * n.x)
    }, a.prototype.getSideNormals = function(t, e) {
        var i = t,
            n = this.halfExtents;
        if (i[0].set(n.x, 0, 0), i[1].set(0, n.y, 0), i[2].set(0, 0, n.z), i[3].set(-n.x, 0, 0), i[4].set(0, -n.y, 0), i[5].set(0, 0, -n.z), void 0 !== e)
            for (var r = 0; r !== i.length; r++) e.vmult(i[r], i[r]);
        return i
    }, a.prototype.volume = function() {
        return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z
    }, a.prototype.updateBoundingSphereRadius = function() {
        this.boundingSphereRadius = this.halfExtents.norm()
    };
    var s = new r;
    new r, a.prototype.forEachWorldCorner = function(t, e, i) {
        for (var n = this.halfExtents, r = [
                [n.x, n.y, n.z],
                [-n.x, n.y, n.z],
                [-n.x, -n.y, n.z],
                [-n.x, -n.y, -n.z],
                [n.x, -n.y, -n.z],
                [n.x, n.y, -n.z],
                [-n.x, n.y, -n.z],
                [n.x, -n.y, n.z]
            ], o = 0; o < r.length; o++) s.set(r[o][0], r[o][1], r[o][2]), e.vmult(s, s), t.vadd(s, s), i(s.x, s.y, s.z)
    };
    var l = [new r, new r, new r, new r, new r, new r, new r, new r];
    a.prototype.calculateWorldAABB = function(t, e, i, n) {
        var r = this.halfExtents;
        l[0].set(r.x, r.y, r.z), l[1].set(-r.x, r.y, r.z), l[2].set(-r.x, -r.y, r.z), l[3].set(-r.x, -r.y, -r.z), l[4].set(r.x, -r.y, -r.z), l[5].set(r.x, r.y, -r.z), l[6].set(-r.x, r.y, -r.z), l[7].set(r.x, -r.y, r.z);
        var o = l[0];
        e.vmult(o, o), t.vadd(o, o), n.copy(o), i.copy(o);
        for (var a = 1; a < 8; a++) {
            o = l[a], e.vmult(o, o), t.vadd(o, o);
            var s = o.x,
                h = o.y,
                c = o.z;
            s > n.x && (n.x = s), h > n.y && (n.y = h), c > n.z && (n.z = c), s < i.x && (i.x = s), h < i.y && (i.y = h), c < i.z && (i.z = c)
        }
    }
}, , , , , , , , , , , , , function(t, e, i) {
    t.exports = o;
    var n = i(1),
        r = (i(25), i(39));

    function o(t, e, i) {
        i = void 0 !== i ? i : 1e6, r.call(this, t, e, -i, i), this.axisA = new n, this.axisB = new n, this.targetVelocity = 0
    }
    o.prototype = new r, o.prototype.constructor = o, o.prototype.computeB = function(t) {
        this.a;
        var e = this.b,
            i = (this.bi, this.bj, this.axisA),
            n = this.axisB,
            r = this.jacobianElementA,
            o = this.jacobianElementB;
        return r.rotational.copy(i), n.negate(o.rotational), -(this.computeGW() - this.targetVelocity) * e - t * this.computeGiMf()
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(39),
        r = i(1);

    function o(t, e, i) {
        n.call(this, t, e, -i, i), this.ri = new r, this.rj = new r, this.t = new r
    }
    i(25), o.prototype = new n, o.prototype.constructor = o;
    var a = new r,
        s = new r;
    o.prototype.computeB = function(t) {
        this.a;
        var e = this.b,
            i = (this.bi, this.bj, this.ri),
            n = this.rj,
            r = a,
            o = s,
            l = this.t;
        i.cross(l, r), n.cross(l, o);
        var h = this.jacobianElementA,
            c = this.jacobianElementB;
        return l.negate(h.spatial), r.negate(h.rotational), c.spatial.copy(l), c.rotational.copy(o), -this.computeGW() * e - t * this.computeGiMf()
    }
}, function(t, e) {
    var i = function() {};
    t.exports = i, i.prototype = {
        constructor: i,
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            return void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e), this
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        },
        hasAnyEventListener: function(t) {
            return void 0 !== this._listeners && void 0 !== this._listeners[t]
        },
        removeEventListener: function(t, e) {
            if (void 0 === this._listeners) return this;
            var i = this._listeners;
            if (void 0 === i[t]) return this;
            var n = i[t].indexOf(e);
            return -1 !== n && i[t].splice(n, 1), this
        },
        dispatchEvent: function(t) {
            if (void 0 === this._listeners) return this;
            var e = this._listeners[t.type];
            if (void 0 !== e) {
                t.target = this;
                for (var i = 0, n = e.length; i < n; i++) e[i].call(this, t)
            }
            return this
        }
    }
}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    t.exports = o;
    var n = i(8),
        r = i(1);

    function o(t) {
        if (n.call(this, {
                type: n.types.SPHERE
            }), this.radius = void 0 !== t ? t : 1, this.radius < 0) throw new Error("The sphere radius cannot be negative.");
        this.updateBoundingSphereRadius()
    }
    o.prototype = new n, o.prototype.constructor = o, o.prototype.calculateLocalInertia = function(t, e) {
        e = e || new r;
        var i = 2 * t * this.radius * this.radius / 5;
        return e.x = i, e.y = i, e.z = i, e
    }, o.prototype.volume = function() {
        return 4 * Math.PI * this.radius / 3
    }, o.prototype.updateBoundingSphereRadius = function() {
        this.boundingSphereRadius = this.radius
    }, o.prototype.calculateWorldAABB = function(t, e, i, n) {
        for (var r = this.radius, o = ["x", "y", "z"], a = 0; a < o.length; a++) {
            var s = o[a];
            i[s] = t[s] - r, n[s] = t[s] + r
        }
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(8),
        r = i(1);

    function o() {
        n.call(this, {
            type: n.types.PARTICLE
        })
    }
    o.prototype = new n, o.prototype.constructor = o, o.prototype.calculateLocalInertia = function(t, e) {
        return (e = e || new r).set(0, 0, 0), e
    }, o.prototype.volume = function() {
        return 0
    }, o.prototype.updateBoundingSphereRadius = function() {
        this.boundingSphereRadius = 0
    }, o.prototype.calculateWorldAABB = function(t, e, i, n) {
        i.copy(t), n.copy(t)
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(74),
        r = i(26);

    function o() {
        n.apply(this)
    }
    o.prototype = new n, o.prototype.constructor = o, o.prototype.collisionPairs = function(t, e, i) {
        var n, r, o, a, s = t.bodies,
            l = s.length;
        for (n = 0; n !== l; n++)
            for (r = 0; r !== n; r++) o = s[n], a = s[r], this.needBroadphaseCollision(o, a) && this.intersectionTest(o, a, e, i)
    }, new r, o.prototype.aabbQuery = function(t, e, i) {
        i = i || [];
        for (var n = 0; n < t.bodies.length; n++) {
            var r = t.bodies[n];
            r.aabbNeedsUpdate && r.computeAABB(), r.aabb.overlaps(e) && i.push(r)
        }
        return i
    }
}, function(t, e, i) {
    t.exports = s, i(40);
    var n = i(71),
        r = i(70),
        o = i(88),
        a = (i(24), i(1));

    function s(t, e, i) {
        var s = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6,
            l = i.pivotA ? i.pivotA.clone() : new a,
            h = i.pivotB ? i.pivotB.clone() : new a;
        n.call(this, t, l, e, h, s), (this.axisA = i.axisA ? i.axisA.clone() : new a(1, 0, 0)).normalize(), (this.axisB = i.axisB ? i.axisB.clone() : new a(1, 0, 0)).normalize();
        var c = this.rotationalEquation1 = new r(t, e, i),
            u = this.rotationalEquation2 = new r(t, e, i),
            p = this.motorEquation = new o(t, e, s);
        p.enabled = !1, this.equations.push(c, u, p)
    }
    s.prototype = new n, s.constructor = s, s.prototype.enableMotor = function() {
        this.motorEquation.enabled = !0
    }, s.prototype.disableMotor = function() {
        this.motorEquation.enabled = !1
    }, s.prototype.setMotorSpeed = function(t) {
        this.motorEquation.targetVelocity = t
    }, s.prototype.setMotorMaxForce = function(t) {
        this.motorEquation.maxForce = t, this.motorEquation.minForce = -t
    };
    var l = new a,
        h = new a;
    s.prototype.update = function() {
        var t = this.bodyA,
            e = this.bodyB,
            i = this.motorEquation,
            r = this.rotationalEquation1,
            o = this.rotationalEquation2,
            a = l,
            s = h,
            c = this.axisA,
            u = this.axisB;
        n.prototype.update.call(this), t.quaternion.vmult(c, a), e.quaternion.vmult(u, s), a.tangents(r.axisA, o.axisA), r.axisB.copy(s), o.axisB.copy(s), this.motorEquation.enabled && (t.quaternion.vmult(this.axisA, i.axisA), e.quaternion.vmult(this.axisB, i.axisB))
    }
}, function(t, e, i) {
    t.exports = r, i(1), i(13);
    var n = i(72);

    function r() {
        n.call(this), this.iterations = 10, this.tolerance = 1e-7
    }
    r.prototype = new n;
    var o = [],
        a = [],
        s = [];
    r.prototype.solve = function(t, e) {
        var i, n, r, l, h, c = 0,
            u = this.iterations,
            p = this.tolerance * this.tolerance,
            d = this.equations,
            f = d.length,
            m = e.bodies,
            v = m.length,
            g = t;
        if (0 !== f)
            for (var y = 0; y !== v; y++) m[y].updateSolveMassProperties();
        var _ = a,
            x = s,
            b = o;
        for (_.length = f, x.length = f, b.length = f, y = 0; y !== f; y++) {
            var w = d[y];
            b[y] = 0, x[y] = w.computeB(g), _[y] = 1 / w.computeC()
        }
        if (0 !== f) {
            for (y = 0; y !== v; y++) {
                var T = (S = m[y]).vlambda,
                    E = S.wlambda;
                T.set(0, 0, 0), E.set(0, 0, 0)
            }
            for (c = 0; c !== u; c++) {
                l = 0;
                for (var M = 0; M !== f; M++) w = d[M], i = x[M], n = _[M], (h = b[M]) + (r = n * (i - w.computeGWlambda() - w.eps * h)) < w.minForce ? r = w.minForce - h : h + r > w.maxForce && (r = w.maxForce - h), b[M] += r, l += r > 0 ? r : -r, w.addToWlambda(r);
                if (l * l < p) break
            }
            for (y = 0; y !== v; y++) {
                var S, A = (S = m[y]).velocity,
                    C = S.angularVelocity;
                S.vlambda.vmul(S.linearFactor, S.vlambda), A.vadd(S.vlambda, A), S.wlambda.vmul(S.angularFactor, S.wlambda), C.vadd(S.wlambda, C)
            }
            for (var R = d.length, P = 1 / g; R--;) d[R].multiplier = b[R] * P
        }
        return c
    }
}, function(t, e, i) {
    var n = i(56);

    function r(t, e, i) {
        i = n.defaults(i, {
            friction: .3,
            restitution: .3,
            contactEquationStiffness: 1e7,
            contactEquationRelaxation: 3,
            frictionEquationStiffness: 1e7,
            frictionEquationRelaxation: 3
        }), this.id = r.idCounter++, this.materials = [t, e], this.friction = i.friction, this.restitution = i.restitution, this.contactEquationStiffness = i.contactEquationStiffness, this.contactEquationRelaxation = i.contactEquationRelaxation, this.frictionEquationStiffness = i.frictionEquationStiffness, this.frictionEquationRelaxation = i.frictionEquationRelaxation
    }
    t.exports = r, r.idCounter = 0
}, function(t, e) {
    function i() {
        this.objects = [], this.type = Object
    }
    t.exports = i, i.prototype.release = function() {
        for (var t = arguments.length, e = 0; e !== t; e++) this.objects.push(arguments[e]);
        return this
    }, i.prototype.get = function() {
        return 0 === this.objects.length ? this.constructObject() : this.objects.pop()
    }, i.prototype.constructObject = function() {
        throw new Error("constructObject() not implemented in this Pool subclass yet!")
    }, i.prototype.resize = function(t) {
        for (var e = this.objects; e.length > t;) e.pop();
        for (; e.length < t;) e.push(this.constructObject());
        return this
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(1),
        r = i(130);

    function o() {
        r.call(this), this.type = n
    }
    o.prototype = new r, o.prototype.constructObject = function() {
        return new n
    }
}, function(t, e, i) {
    t.exports = p;
    var n = i(26),
        r = i(8),
        o = i(73),
        a = i(1),
        s = i(41),
        l = (i(42), i(13)),
        h = (i(72), i(131)),
        c = i(24),
        u = i(89);

    function p(t) {
        this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new h, this.world = t, this.currentContactMaterial = null, this.enableFrictionReduction = !1
    }
    p.prototype.createContactEquation = function(t, e, i, n, r, o) {
        var a;
        this.contactPointPool.length ? ((a = this.contactPointPool.pop()).bi = t, a.bj = e) : a = new c(t, e), a.enabled = t.collisionResponse && e.collisionResponse && i.collisionResponse && n.collisionResponse;
        var s = this.currentContactMaterial;
        a.restitution = s.restitution, a.setSpookParams(s.contactEquationStiffness, s.contactEquationRelaxation, this.world.dt);
        var l = i.material || t.material,
            h = n.material || e.material;
        return l && h && l.restitution >= 0 && h.restitution >= 0 && (a.restitution = l.restitution * h.restitution), a.si = r || i, a.sj = o || n, a
    }, p.prototype.createFrictionEquationsFromContact = function(t, e) {
        var i = t.bi,
            n = t.bj,
            r = t.si,
            o = t.sj,
            a = this.world,
            s = this.currentContactMaterial,
            l = s.friction,
            h = r.material || i.material,
            c = o.material || n.material;
        if (h && c && h.friction >= 0 && c.friction >= 0 && (l = h.friction * c.friction), l > 0) {
            var p = l * a.gravity.length(),
                d = i.invMass + n.invMass;
            d > 0 && (d = 1 / d);
            var f = this.frictionEquationPool,
                m = f.length ? f.pop() : new u(i, n, p * d),
                v = f.length ? f.pop() : new u(i, n, p * d);
            return m.bi = v.bi = i, m.bj = v.bj = n, m.minForce = v.minForce = -p * d, m.maxForce = v.maxForce = p * d, m.ri.copy(t.ri), m.rj.copy(t.rj), v.ri.copy(t.ri), v.rj.copy(t.rj), t.ni.tangents(m.t, v.t), m.setSpookParams(s.frictionEquationStiffness, s.frictionEquationRelaxation, a.dt), v.setSpookParams(s.frictionEquationStiffness, s.frictionEquationRelaxation, a.dt), m.enabled = v.enabled = t.enabled, e.push(m, v), !0
        }
        return !1
    };
    var d = new a,
        f = new a,
        m = new a;
    p.prototype.createFrictionFromAverage = function(t) {
        var e = this.result[this.result.length - 1];
        if (this.createFrictionEquationsFromContact(e, this.frictionResult) && 1 !== t) {
            var i = this.frictionResult[this.frictionResult.length - 2],
                n = this.frictionResult[this.frictionResult.length - 1];
            d.setZero(), f.setZero(), m.setZero();
            for (var r = e.bi, o = (e.bj, 0); o !== t; o++)(e = this.result[this.result.length - 1 - o]).bodyA !== r ? (d.vadd(e.ni, d), f.vadd(e.ri, f), m.vadd(e.rj, m)) : (d.vsub(e.ni, d), f.vadd(e.rj, f), m.vadd(e.ri, m));
            var a = 1 / t;
            f.scale(a, i.ri), m.scale(a, i.rj), n.ri.copy(i.ri), n.rj.copy(i.rj), d.normalize(), d.tangents(i.t, n.t)
        }
    };
    var v = new a,
        g = new a,
        y = new l,
        _ = new l;
    p.prototype.getContacts = function(t, e, i, n, r, o, a) {
        this.contactPointPool = r, this.frictionEquationPool = a, this.result = n, this.frictionResult = o;
        for (var s = y, l = _, h = v, c = g, u = 0, p = t.length; u !== p; u++) {
            var d = t[u],
                f = e[u],
                m = null;
            d.material && f.material && (m = i.getContactMaterial(d.material, f.material) || null);
            for (var x = 0; x < d.shapes.length; x++) {
                d.quaternion.mult(d.shapeOrientations[x], s), d.quaternion.vmult(d.shapeOffsets[x], h), h.vadd(d.position, h);
                for (var b = d.shapes[x], w = 0; w < f.shapes.length; w++) {
                    f.quaternion.mult(f.shapeOrientations[w], l), f.quaternion.vmult(f.shapeOffsets[w], c), c.vadd(f.position, c);
                    var T = f.shapes[w];
                    if (b.collisionFilterMask & T.collisionFilterGroup && T.collisionFilterMask & b.collisionFilterGroup && !(h.distanceTo(c) > b.boundingSphereRadius + T.boundingSphereRadius)) {
                        var E = null;
                        b.material && T.material && (E = i.getContactMaterial(b.material, T.material) || null), this.currentContactMaterial = E || m || i.defaultContactMaterial;
                        var M = this[b.type | T.type];
                        M && (b.type < T.type ? M.call(this, b, T, h, c, s, l, d, f, b, T) : M.call(this, T, b, c, h, l, s, f, d, b, T))
                    }
                }
            }
        }
    }, p.prototype[r.types.BOX | r.types.BOX] = p.prototype.boxBox = function(t, e, i, n, r, o, a, s) {
        t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.material = e.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexConvex(t.convexPolyhedronRepresentation, e.convexPolyhedronRepresentation, i, n, r, o, a, s, t, e)
    }, p.prototype[r.types.BOX | r.types.CONVEXPOLYHEDRON] = p.prototype.boxConvex = function(t, e, i, n, r, o, a, s) {
        t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexConvex(t.convexPolyhedronRepresentation, e, i, n, r, o, a, s, t, e)
    }, p.prototype[r.types.BOX | r.types.PARTICLE] = p.prototype.boxParticle = function(t, e, i, n, r, o, a, s) {
        t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexParticle(t.convexPolyhedronRepresentation, e, i, n, r, o, a, s, t, e)
    }, p.prototype[r.types.SPHERE] = p.prototype.sphereSphere = function(t, e, i, n, r, o, a, s, l, h) {
        var c = this.createContactEquation(a, s, t, e, l, h);
        n.vsub(i, c.ni), c.ni.normalize(), c.ri.copy(c.ni), c.rj.copy(c.ni), c.ri.mult(t.radius, c.ri), c.rj.mult(-e.radius, c.rj), c.ri.vadd(i, c.ri), c.ri.vsub(a.position, c.ri), c.rj.vadd(n, c.rj), c.rj.vsub(s.position, c.rj), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult)
    };
    var x = new a,
        b = new a,
        w = new a;
    p.prototype[r.types.PLANE | r.types.TRIMESH] = p.prototype.planeTrimesh = function(t, e, i, n, r, o, l, h, c, u) {
        var p = new a,
            d = x;
        d.set(0, 0, 1), r.vmult(d, d);
        for (var f = 0; f < e.vertices.length / 3; f++) {
            e.getVertex(f, p);
            var m = new a;
            m.copy(p), s.pointToWorldFrame(n, o, m, p);
            var v = b;
            if (p.vsub(i, v), d.dot(v) <= 0) {
                var g = this.createContactEquation(l, h, t, e, c, u);
                g.ni.copy(d);
                var y = w;
                d.scale(v.dot(d), y), p.vsub(y, y), g.ri.copy(y), g.ri.vsub(l.position, g.ri), g.rj.copy(p), g.rj.vsub(h.position, g.rj), this.result.push(g), this.createFrictionEquationsFromContact(g, this.frictionResult)
            }
        }
    };
    var T = new a,
        E = new a,
        M = (new a, new a),
        S = new a,
        A = new a,
        C = new a,
        R = new a,
        P = new a,
        L = new a,
        O = new a,
        B = new a,
        I = new a,
        N = new a,
        z = new n,
        F = [];
    p.prototype[r.types.SPHERE | r.types.TRIMESH] = p.prototype.sphereTrimesh = function(t, e, i, n, r, a, l, h, c, u) {
        var p = A,
            d = C,
            f = R,
            m = P,
            v = L,
            g = O,
            y = z,
            _ = S,
            x = E,
            b = F;
        s.pointToLocalFrame(n, a, i, v);
        var w = t.radius;
        y.lowerBound.set(v.x - w, v.y - w, v.z - w), y.upperBound.set(v.x + w, v.y + w, v.z + w), e.getTrianglesInAABB(y, b);
        for (var D = M, U = t.radius * t.radius, k = 0; k < b.length; k++)
            for (var V = 0; V < 3; V++) e.getVertex(e.indices[3 * b[k] + V], D), D.vsub(v, x), x.norm2() <= U && (_.copy(D), s.pointToWorldFrame(n, a, _, D), D.vsub(i, x), (j = this.createContactEquation(l, h, t, e, c, u)).ni.copy(x), j.ni.normalize(), j.ri.copy(j.ni), j.ri.scale(t.radius, j.ri), j.ri.vadd(i, j.ri), j.ri.vsub(l.position, j.ri), j.rj.copy(D), j.rj.vsub(h.position, j.rj), this.result.push(j), this.createFrictionEquationsFromContact(j, this.frictionResult));
        for (k = 0; k < b.length; k++)
            for (V = 0; V < 3; V++) {
                e.getVertex(e.indices[3 * b[k] + V], p), e.getVertex(e.indices[3 * b[k] + (V + 1) % 3], d), d.vsub(p, f), v.vsub(d, g);
                var H = g.dot(f);
                v.vsub(p, g);
                var G = g.dot(f);
                if (G > 0 && H < 0 && (v.vsub(p, g), m.copy(f), m.normalize(), G = g.dot(m), m.scale(G, g), g.vadd(p, g), (J = g.distanceTo(v)) < t.radius)) {
                    var j = this.createContactEquation(l, h, t, e, c, u);
                    g.vsub(v, j.ni), j.ni.normalize(), j.ni.scale(t.radius, j.ri), s.pointToWorldFrame(n, a, g, g), g.vsub(h.position, j.rj), s.vectorToWorldFrame(a, j.ni, j.ni), s.vectorToWorldFrame(a, j.ri, j.ri), this.result.push(j), this.createFrictionEquationsFromContact(j, this.frictionResult)
                }
            }
        for (var W = B, q = I, X = N, Y = T, Z = (k = 0, b.length); k !== Z; k++) {
            e.getTriangleVertices(b[k], W, q, X), e.getNormal(b[k], Y), v.vsub(W, g);
            var J = g.dot(Y);
            Y.scale(J, g), v.vsub(g, g), J = g.distanceTo(v), o.pointInTriangle(g, W, q, X) && J < t.radius && (j = this.createContactEquation(l, h, t, e, c, u), g.vsub(v, j.ni), j.ni.normalize(), j.ni.scale(t.radius, j.ri), s.pointToWorldFrame(n, a, g, g), g.vsub(h.position, j.rj), s.vectorToWorldFrame(a, j.ni, j.ni), s.vectorToWorldFrame(a, j.ri, j.ri), this.result.push(j), this.createFrictionEquationsFromContact(j, this.frictionResult))
        }
        b.length = 0
    };
    var D = new a,
        U = new a;
    p.prototype[r.types.SPHERE | r.types.PLANE] = p.prototype.spherePlane = function(t, e, i, n, r, o, a, s, l, h) {
        var c = this.createContactEquation(a, s, t, e, l, h);
        if (c.ni.set(0, 0, 1), o.vmult(c.ni, c.ni), c.ni.negate(c.ni), c.ni.normalize(), c.ni.mult(t.radius, c.ri), i.vsub(n, D), c.ni.mult(c.ni.dot(D), U), D.vsub(U, c.rj), -D.dot(c.ni) <= t.radius) {
            var u = c.ri,
                p = c.rj;
            u.vadd(i, u), u.vsub(a.position, u), p.vadd(n, p), p.vsub(s.position, p), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult)
        }
    };
    var k = new a,
        V = new a,
        H = new a;

    function G(t, e, i) {
        for (var n = null, r = t.length, o = 0; o !== r; o++) {
            var a = t[o],
                s = k;
            t[(o + 1) % r].vsub(a, s);
            var l = V;
            s.cross(e, l);
            var h = H;
            i.vsub(a, h);
            var c = l.dot(h);
            if (!(null === n || c > 0 && !0 === n || c <= 0 && !1 === n)) return !1;
            null === n && (n = c > 0)
        }
        return !0
    }
    var j = new a,
        W = new a,
        q = new a,
        X = new a,
        Y = [new a, new a, new a, new a, new a, new a],
        Z = new a,
        J = new a,
        K = new a,
        Q = new a;
    p.prototype[r.types.SPHERE | r.types.BOX] = p.prototype.sphereBox = function(t, e, i, n, r, o, a, s, l, h) {
        var c = this.v3pool,
            u = Y;
        i.vsub(n, j), e.getSideNormals(u, o);
        for (var p = t.radius, d = !1, f = J, m = K, v = Q, g = null, y = 0, _ = 0, x = 0, b = null, w = 0, T = u.length; w !== T && !1 === d; w++) {
            var E = W;
            E.copy(u[w]);
            var M = E.norm();
            E.normalize();
            var S = j.dot(E);
            if (S < M + p && S > 0) {
                var A = q,
                    C = X;
                A.copy(u[(w + 1) % 3]), C.copy(u[(w + 2) % 3]);
                var R = A.norm(),
                    P = C.norm();
                A.normalize(), C.normalize();
                var L = j.dot(A),
                    O = j.dot(C);
                if (L < R && L > -R && O < P && O > -P) {
                    var B = Math.abs(S - M - p);
                    (null === b || B < b) && (b = B, _ = L, x = O, g = M, f.copy(E), m.copy(A), v.copy(C), y++)
                }
            }
        }
        if (y) {
            d = !0;
            var I = this.createContactEquation(a, s, t, e, l, h);
            f.mult(-p, I.ri), I.ni.copy(f), I.ni.negate(I.ni), f.mult(g, f), m.mult(_, m), f.vadd(m, f), v.mult(x, v), f.vadd(v, I.rj), I.ri.vadd(i, I.ri), I.ri.vsub(a.position, I.ri), I.rj.vadd(n, I.rj), I.rj.vsub(s.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult)
        }
        for (var N = c.get(), z = Z, F = 0; 2 !== F && !d; F++)
            for (var D = 0; 2 !== D && !d; D++)
                for (var U = 0; 2 !== U && !d; U++) N.set(0, 0, 0), F ? N.vadd(u[0], N) : N.vsub(u[0], N), D ? N.vadd(u[1], N) : N.vsub(u[1], N), U ? N.vadd(u[2], N) : N.vsub(u[2], N), n.vadd(N, z), z.vsub(i, z), z.norm2() < p * p && (d = !0, (I = this.createContactEquation(a, s, t, e, l, h)).ri.copy(z), I.ri.normalize(), I.ni.copy(I.ri), I.ri.mult(p, I.ri), I.rj.copy(N), I.ri.vadd(i, I.ri), I.ri.vsub(a.position, I.ri), I.rj.vadd(n, I.rj), I.rj.vsub(s.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult));
        c.release(N), N = null;
        var k = c.get(),
            V = c.get(),
            H = (I = c.get(), c.get()),
            G = (B = c.get(), u.length);
        for (F = 0; F !== G && !d; F++)
            for (D = 0; D !== G && !d; D++)
                if (F % 3 != D % 3) {
                    u[D].cross(u[F], k), k.normalize(), u[F].vadd(u[D], V), I.copy(i), I.vsub(V, I), I.vsub(n, I);
                    var $ = I.dot(k);
                    for (k.mult($, H), U = 0; U === F % 3 || U === D % 3;) U++;
                    B.copy(i), B.vsub(H, B), B.vsub(V, B), B.vsub(n, B);
                    var tt = Math.abs($),
                        et = B.norm();
                    if (tt < u[U].norm() && et < p) {
                        d = !0;
                        var it = this.createContactEquation(a, s, t, e, l, h);
                        V.vadd(H, it.rj), it.rj.copy(it.rj), B.negate(it.ni), it.ni.normalize(), it.ri.copy(it.rj), it.ri.vadd(n, it.ri), it.ri.vsub(i, it.ri), it.ri.normalize(), it.ri.mult(p, it.ri), it.ri.vadd(i, it.ri), it.ri.vsub(a.position, it.ri), it.rj.vadd(n, it.rj), it.rj.vsub(s.position, it.rj), this.result.push(it), this.createFrictionEquationsFromContact(it, this.frictionResult)
                    }
                }
        c.release(k, V, I, H, B)
    };
    var $ = new a,
        tt = new a,
        et = new a,
        it = new a,
        nt = new a,
        rt = new a,
        ot = new a,
        at = new a,
        st = new a,
        lt = new a;
    p.prototype[r.types.SPHERE | r.types.CONVEXPOLYHEDRON] = p.prototype.sphereConvex = function(t, e, i, n, r, o, a, s, l, h) {
        var c = this.v3pool;
        i.vsub(n, $);
        for (var u = e.faceNormals, p = e.faces, d = e.vertices, f = t.radius, m = 0; m !== d.length; m++) {
            var v = d[m],
                g = nt;
            o.vmult(v, g), n.vadd(g, g);
            var y = it;
            if (g.vsub(i, y), y.norm2() < f * f) return _ = !0, (B = this.createContactEquation(a, s, t, e, l, h)).ri.copy(y), B.ri.normalize(), B.ni.copy(B.ri), B.ri.mult(f, B.ri), g.vsub(n, B.rj), B.ri.vadd(i, B.ri), B.ri.vsub(a.position, B.ri), B.rj.vadd(n, B.rj), B.rj.vsub(s.position, B.rj), this.result.push(B), void this.createFrictionEquationsFromContact(B, this.frictionResult)
        }
        for (var _ = !1, x = (m = 0, p.length); m !== x && !1 === _; m++) {
            var b = u[m],
                w = p[m],
                T = rt;
            o.vmult(b, T);
            var E = ot;
            o.vmult(d[w[0]], E), E.vadd(n, E);
            var M = at;
            T.mult(-f, M), i.vadd(M, M);
            var S = st;
            M.vsub(E, S);
            var A = S.dot(T),
                C = lt;
            if (i.vsub(E, C), A < 0 && C.dot(T) > 0) {
                for (var R = [], P = 0, L = w.length; P !== L; P++) {
                    var O = c.get();
                    o.vmult(d[w[P]], O), n.vadd(O, O), R.push(O)
                }
                if (G(R, T, i)) {
                    _ = !0;
                    var B = this.createContactEquation(a, s, t, e, l, h);
                    T.mult(-f, B.ri), T.negate(B.ni);
                    var I = c.get();
                    T.mult(-A, I);
                    var N = c.get();
                    T.mult(-f, N), i.vsub(n, B.rj), B.rj.vadd(N, B.rj), B.rj.vadd(I, B.rj), B.rj.vadd(n, B.rj), B.rj.vsub(s.position, B.rj), B.ri.vadd(i, B.ri), B.ri.vsub(a.position, B.ri), c.release(I), c.release(N), this.result.push(B), this.createFrictionEquationsFromContact(B, this.frictionResult), P = 0;
                    for (var z = R.length; P !== z; P++) c.release(R[P]);
                    return
                }
                for (P = 0; P !== w.length; P++) {
                    var F = c.get(),
                        D = c.get();
                    o.vmult(d[w[(P + 1) % w.length]], F), o.vmult(d[w[(P + 2) % w.length]], D), n.vadd(F, F), n.vadd(D, D);
                    var U = tt;
                    D.vsub(F, U);
                    var k = et;
                    U.unit(k);
                    var V = c.get(),
                        H = c.get();
                    i.vsub(F, H);
                    var j = H.dot(k);
                    k.mult(j, V), V.vadd(F, V);
                    var W = c.get();
                    if (V.vsub(i, W), j > 0 && j * j < U.norm2() && W.norm2() < f * f) {
                        for (B = this.createContactEquation(a, s, t, e, l, h), V.vsub(n, B.rj), V.vsub(i, B.ni), B.ni.normalize(), B.ni.mult(f, B.ri), B.rj.vadd(n, B.rj), B.rj.vsub(s.position, B.rj), B.ri.vadd(i, B.ri), B.ri.vsub(a.position, B.ri), this.result.push(B), this.createFrictionEquationsFromContact(B, this.frictionResult), P = 0, z = R.length; P !== z; P++) c.release(R[P]);
                        return c.release(F), c.release(D), c.release(V), c.release(W), void c.release(H)
                    }
                    c.release(F), c.release(D), c.release(V), c.release(W), c.release(H)
                }
                for (P = 0, z = R.length; P !== z; P++) c.release(R[P])
            }
        }
    }, new a, new a, p.prototype[r.types.PLANE | r.types.BOX] = p.prototype.planeBox = function(t, e, i, n, r, o, a, s) {
        e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, e.convexPolyhedronRepresentation.id = e.id, this.planeConvex(t, e.convexPolyhedronRepresentation, i, n, r, o, a, s, t, e)
    };
    var ht = new a,
        ct = new a,
        ut = new a,
        pt = new a;
    p.prototype[r.types.PLANE | r.types.CONVEXPOLYHEDRON] = p.prototype.planeConvex = function(t, e, i, n, r, o, a, s, l, h) {
        var c = ht,
            u = ct;
        u.set(0, 0, 1), r.vmult(u, u);
        for (var p = 0, d = ut, f = 0; f !== e.vertices.length; f++)
            if (c.copy(e.vertices[f]), o.vmult(c, c), n.vadd(c, c), c.vsub(i, d), u.dot(d) <= 0) {
                var m = this.createContactEquation(a, s, t, e, l, h),
                    v = pt;
                u.mult(u.dot(d), v), c.vsub(v, v), v.vsub(i, m.ri), m.ni.copy(u), c.vsub(n, m.rj), m.ri.vadd(i, m.ri), m.ri.vsub(a.position, m.ri), m.rj.vadd(n, m.rj), m.rj.vsub(s.position, m.rj), this.result.push(m), p++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(m, this.frictionResult)
            }
        this.enableFrictionReduction && p && this.createFrictionFromAverage(p)
    };
    var dt = new a,
        ft = new a;
    p.prototype[r.types.CONVEXPOLYHEDRON] = p.prototype.convexConvex = function(t, e, i, n, r, o, a, s, l, h, c, u) {
        var p = dt;
        if (!(i.distanceTo(n) > t.boundingSphereRadius + e.boundingSphereRadius) && t.findSeparatingAxis(e, i, r, n, o, p, c, u)) {
            var d = [],
                f = ft;
            t.clipAgainstHull(i, r, e, n, o, p, -100, 100, d);
            for (var m = 0, v = 0; v !== d.length; v++) {
                var g = this.createContactEquation(a, s, t, e, l, h),
                    y = g.ri,
                    _ = g.rj;
                p.negate(g.ni), d[v].normal.negate(f), f.mult(d[v].depth, f), d[v].point.vadd(f, y), _.copy(d[v].point), y.vsub(i, y), _.vsub(n, _), y.vadd(i, y), y.vsub(a.position, y), _.vadd(n, _), _.vsub(s.position, _), this.result.push(g), m++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(g, this.frictionResult)
            }
            this.enableFrictionReduction && m && this.createFrictionFromAverage(m)
        }
    };
    var mt = new a,
        vt = new a,
        gt = new a;
    p.prototype[r.types.PLANE | r.types.PARTICLE] = p.prototype.planeParticle = function(t, e, i, n, r, o, a, s, l, h) {
        var c = mt;
        c.set(0, 0, 1), a.quaternion.vmult(c, c);
        var u = vt;
        if (n.vsub(a.position, u), c.dot(u) <= 0) {
            var p = this.createContactEquation(s, a, e, t, l, h);
            p.ni.copy(c), p.ni.negate(p.ni), p.ri.set(0, 0, 0);
            var d = gt;
            c.mult(c.dot(n), d), n.vsub(d, d), p.rj.copy(d), this.result.push(p), this.createFrictionEquationsFromContact(p, this.frictionResult)
        }
    };
    var yt = new a;
    p.prototype[r.types.PARTICLE | r.types.SPHERE] = p.prototype.sphereParticle = function(t, e, i, n, r, o, a, s, l, h) {
        var c = yt;
        if (c.set(0, 0, 1), n.vsub(i, c), c.norm2() <= t.radius * t.radius) {
            var u = this.createContactEquation(s, a, e, t, l, h);
            c.normalize(), u.rj.copy(c), u.rj.mult(t.radius, u.rj), u.ni.copy(c), u.ni.negate(u.ni), u.ri.set(0, 0, 0), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult)
        }
    };
    var _t = new l,
        xt = new a,
        bt = (new a, new a),
        wt = new a,
        Tt = new a;
    p.prototype[r.types.PARTICLE | r.types.CONVEXPOLYHEDRON] = p.prototype.convexParticle = function(t, e, i, n, r, o, a, s, l, h) {
        var c = -1,
            u = bt,
            p = Tt,
            d = null,
            f = xt;
        if (f.copy(n), f.vsub(i, f), r.conjugate(_t), _t.vmult(f, f), t.pointIsInside(f)) {
            t.worldVerticesNeedsUpdate && t.computeWorldVertices(i, r), t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(r);
            for (var m = 0, v = t.faces.length; m !== v; m++) {
                var g = [t.worldVertices[t.faces[m][0]]],
                    y = t.worldFaceNormals[m];
                n.vsub(g[0], wt);
                var _ = -y.dot(wt);
                (null === d || Math.abs(_) < Math.abs(d)) && (d = _, c = m, u.copy(y))
            }
            if (-1 !== c) {
                var x = this.createContactEquation(s, a, e, t, l, h);
                u.mult(d, p), p.vadd(n, p), p.vsub(i, p), x.rj.copy(p), u.negate(x.ni), x.ri.set(0, 0, 0);
                var b = x.ri,
                    w = x.rj;
                b.vadd(n, b), b.vsub(s.position, b), w.vadd(i, w), w.vsub(a.position, w), this.result.push(x), this.createFrictionEquationsFromContact(x, this.frictionResult)
            } else console.warn("Point found inside convex, but did not find penetrating face!")
        }
    }, p.prototype[r.types.BOX | r.types.HEIGHTFIELD] = p.prototype.boxHeightfield = function(t, e, i, n, r, o, a, s) {
        t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexHeightfield(t.convexPolyhedronRepresentation, e, i, n, r, o, a, s, t, e)
    };
    var Et = new a,
        Mt = new a,
        St = [0];
    p.prototype[r.types.CONVEXPOLYHEDRON | r.types.HEIGHTFIELD] = p.prototype.convexHeightfield = function(t, e, i, n, r, o, a, l) {
        var h = e.data,
            c = e.elementSize,
            u = t.boundingSphereRadius,
            p = Mt,
            d = St,
            f = Et;
        s.pointToLocalFrame(n, o, i, f);
        var m = Math.floor((f.x - u) / c) - 1,
            v = Math.ceil((f.x + u) / c) + 1,
            g = Math.floor((f.y - u) / c) - 1,
            y = Math.ceil((f.y + u) / c) + 1;
        if (!(v < 0 || y < 0 || m > h.length || g > h[0].length)) {
            m < 0 && (m = 0), v < 0 && (v = 0), g < 0 && (g = 0), y < 0 && (y = 0), m >= h.length && (m = h.length - 1), v >= h.length && (v = h.length - 1), y >= h[0].length && (y = h[0].length - 1), g >= h[0].length && (g = h[0].length - 1);
            var _ = [];
            e.getRectMinMax(m, g, v, y, _);
            var x = _[0],
                b = _[1];
            if (!(f.z - u > b || f.z + u < x))
                for (var w = m; w < v; w++)
                    for (var T = g; T < y; T++) e.getConvexTrianglePillar(w, T, !1), s.pointToWorldFrame(n, o, e.pillarOffset, p), i.distanceTo(p) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && this.convexConvex(t, e.pillarConvex, i, p, r, o, a, l, null, null, d, null), e.getConvexTrianglePillar(w, T, !0), s.pointToWorldFrame(n, o, e.pillarOffset, p), i.distanceTo(p) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && this.convexConvex(t, e.pillarConvex, i, p, r, o, a, l, null, null, d, null)
        }
    };
    var At = new a,
        Ct = new a;
    p.prototype[r.types.SPHERE | r.types.HEIGHTFIELD] = p.prototype.sphereHeightfield = function(t, e, i, n, r, o, a, l) {
        var h = e.data,
            c = t.radius,
            u = e.elementSize,
            p = Ct,
            d = At;
        s.pointToLocalFrame(n, o, i, d);
        var f = Math.floor((d.x - c) / u) - 1,
            m = Math.ceil((d.x + c) / u) + 1,
            v = Math.floor((d.y - c) / u) - 1,
            g = Math.ceil((d.y + c) / u) + 1;
        if (!(m < 0 || g < 0 || f > h.length || g > h[0].length)) {
            f < 0 && (f = 0), m < 0 && (m = 0), v < 0 && (v = 0), g < 0 && (g = 0), f >= h.length && (f = h.length - 1), m >= h.length && (m = h.length - 1), g >= h[0].length && (g = h[0].length - 1), v >= h[0].length && (v = h[0].length - 1);
            var y = [];
            e.getRectMinMax(f, v, m, g, y);
            var _ = y[0],
                x = y[1];
            if (!(d.z - c > x || d.z + c < _))
                for (var b = this.result, w = f; w < m; w++)
                    for (var T = v; T < g; T++) {
                        var E = b.length;
                        if (e.getConvexTrianglePillar(w, T, !1), s.pointToWorldFrame(n, o, e.pillarOffset, p), i.distanceTo(p) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && this.sphereConvex(t, e.pillarConvex, i, p, r, o, a, l), e.getConvexTrianglePillar(w, T, !0), s.pointToWorldFrame(n, o, e.pillarOffset, p), i.distanceTo(p) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && this.sphereConvex(t, e.pillarConvex, i, p, r, o, a, l), b.length - E > 2) return
                    }
        }
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(8),
        r = i(1);

    function o() {
        n.call(this, {
            type: n.types.PLANE
        }), this.worldNormal = new r, this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE
    }
    o.prototype = new n, o.prototype.constructor = o, o.prototype.computeWorldNormal = function(t) {
        var e = this.worldNormal;
        e.set(0, 0, 1), t.vmult(e, e), this.worldNormalNeedsUpdate = !1
    }, o.prototype.calculateLocalInertia = function(t, e) {
        return e || new r
    }, o.prototype.volume = function() {
        return Number.MAX_VALUE
    };
    var a = new r;
    o.prototype.calculateWorldAABB = function(t, e, i, n) {
        a.set(0, 0, 1), e.vmult(a, a);
        var r = Number.MAX_VALUE;
        i.set(-r, -r, -r), n.set(r, r, r), 1 === a.x && (n.x = t.x), 1 === a.y && (n.y = t.y), 1 === a.z && (n.z = t.z), -1 === a.x && (i.x = t.x), -1 === a.y && (i.y = t.y), -1 === a.z && (i.z = t.z)
    }, o.prototype.updateBoundingSphereRadius = function() {
        this.boundingSphereRadius = Number.MAX_VALUE
    }
}, function(t, e) {
    function i() {
        this.matrix = []
    }
    t.exports = i, i.prototype.get = function(t, e) {
        if (t = t.index, (e = e.index) > t) {
            var i = e;
            e = t, t = i
        }
        return this.matrix[(t * (t + 1) >> 1) + e - 1]
    }, i.prototype.set = function(t, e, i) {
        if (t = t.index, (e = e.index) > t) {
            var n = e;
            e = t, t = n
        }
        this.matrix[(t * (t + 1) >> 1) + e - 1] = i ? 1 : 0
    }, i.prototype.reset = function() {
        for (var t = 0, e = this.matrix.length; t !== e; t++) this.matrix[t] = 0
    }, i.prototype.setNumObjects = function(t) {
        this.matrix.length = t * (t - 1) >> 1
    }
}, function(t, e, i) {
    "use strict";

    function n() {}
    i.r(e), i.d(e, "WebGLRenderTargetCube", function() {
        return ai
    }), i.d(e, "WebGLRenderTarget", function() {
        return oi
    }), i.d(e, "WebGLRenderer", function() {
        return Br
    }), i.d(e, "ShaderLib", function() {
        return _i
    }), i.d(e, "UniformsLib", function() {
        return yi
    }), i.d(e, "UniformsUtils", function() {
        return fi
    }), i.d(e, "ShaderChunk", function() {
        return di
    }), i.d(e, "FogExp2", function() {
        return Ir
    }), i.d(e, "Fog", function() {
        return Nr
    }), i.d(e, "Scene", function() {
        return zr
    }), i.d(e, "Sprite", function() {
        return Dr
    }), i.d(e, "LOD", function() {
        return Ur
    }), i.d(e, "SkinnedMesh", function() {
        return Hr
    }), i.d(e, "Skeleton", function() {
        return kr
    }), i.d(e, "Bone", function() {
        return Vr
    }), i.d(e, "Mesh", function() {
        return fn
    }), i.d(e, "LineSegments", function() {
        return Wr
    }), i.d(e, "LineLoop", function() {
        return qr
    }), i.d(e, "Line", function() {
        return jr
    }), i.d(e, "Points", function() {
        return Yr
    }), i.d(e, "Group", function() {
        return Zr
    }), i.d(e, "VideoTexture", function() {
        return Jr
    }), i.d(e, "DataTexture", function() {
        return si
    }), i.d(e, "CompressedTexture", function() {
        return Kr
    }), i.d(e, "CubeTexture", function() {
        return vn
    }), i.d(e, "CanvasTexture", function() {
        return Ar
    }), i.d(e, "DepthTexture", function() {
        return Qr
    }), i.d(e, "TextureParams", function() {
        return $r
    }), i.d(e, "Texture", function() {
        return ni
    }), i.d(e, "CompressedTextureLoader", function() {
        return Sa
    }), i.d(e, "DataTextureLoader", function() {
        return Aa
    }), i.d(e, "CubeTextureLoader", function() {
        return Ra
    }), i.d(e, "TextureLoader", function() {
        return Pa
    }), i.d(e, "ObjectLoader", function() {
        return Is
    }), i.d(e, "MaterialLoader", function() {
        return Es
    }), i.d(e, "BufferGeometryLoader", function() {
        return Ms
    }), i.d(e, "DefaultLoadingManager", function() {
        return Ta
    }), i.d(e, "LoadingManager", function() {
        return wa
    }), i.d(e, "JSONLoader", function() {
        return Bs
    }), i.d(e, "ImageLoader", function() {
        return Ca
    }), i.d(e, "ImageBitmapLoader", function() {
        return Us
    }), i.d(e, "FontLoader", function() {
        return Gs
    }), i.d(e, "FileLoader", function() {
        return Ma
    }), i.d(e, "Loader", function() {
        return Ls
    }), i.d(e, "LoaderUtils", function() {
        return Os
    }), i.d(e, "Cache", function() {
        return ba
    }), i.d(e, "AudioLoader", function() {
        return fl
    }), i.d(e, "SpotLightShadow", function() {
        return ns
    }), i.d(e, "SpotLight", function() {
        return rs
    }), i.d(e, "PointLight", function() {
        return os
    }), i.d(e, "RectAreaLight", function() {
        return hs
    }), i.d(e, "HemisphereLight", function() {
        return es
    }), i.d(e, "DirectionalLightShadow", function() {
        return as
    }), i.d(e, "DirectionalLight", function() {
        return ss
    }), i.d(e, "AmbientLight", function() {
        return ls
    }), i.d(e, "LightShadow", function() {
        return is
    }), i.d(e, "Light", function() {
        return ts
    }), i.d(e, "StereoCamera", function() {
        return ml
    }), i.d(e, "PerspectiveCamera", function() {
        return Pr
    }), i.d(e, "OrthographicCamera", function() {
        return Ri
    }), i.d(e, "CubeCamera", function() {
        return vl
    }), i.d(e, "ArrayCamera", function() {
        return Lr
    }), i.d(e, "Camera", function() {
        return Ci
    }), i.d(e, "AudioListener", function() {
        return gl
    }), i.d(e, "PositionalAudio", function() {
        return _l
    }), i.d(e, "AudioContext", function() {
        return dl
    }), i.d(e, "AudioAnalyser", function() {
        return xl
    }), i.d(e, "Audio", function() {
        return yl
    }), i.d(e, "VectorKeyframeTrack", function() {
        return ws
    }), i.d(e, "StringKeyframeTrack", function() {
        return cs
    }), i.d(e, "QuaternionKeyframeTrack", function() {
        return fs
    }), i.d(e, "NumberKeyframeTrack", function() {
        return vs
    }), i.d(e, "ColorKeyframeTrack", function() {
        return ms
    }), i.d(e, "BooleanKeyframeTrack", function() {
        return us
    }), i.d(e, "PropertyMixer", function() {
        return bl
    }), i.d(e, "PropertyBinding", function() {
        return Tl
    }), i.d(e, "KeyframeTrack", function() {
        return bs
    }), i.d(e, "AnimationUtils", function() {
        return xs
    }), i.d(e, "AnimationObjectGroup", function() {
        return El
    }), i.d(e, "AnimationMixer", function() {
        return Sl
    }), i.d(e, "AnimationClip", function() {
        return Ts
    }), i.d(e, "Uniform", function() {
        return Al
    }), i.d(e, "InstancedBufferGeometry", function() {
        return Cl
    }), i.d(e, "BufferGeometry", function() {
        return Yi
    }), i.d(e, "Geometry", function() {
        return Ii
    }), i.d(e, "InterleavedBufferAttribute", function() {
        return Rl
    }), i.d(e, "InstancedInterleavedBuffer", function() {
        return Ll
    }), i.d(e, "InterleavedBuffer", function() {
        return Pl
    }), i.d(e, "InstancedBufferAttribute", function() {
        return Ol
    }), i.d(e, "Face3", function() {
        return Pi
    }), i.d(e, "Object3D", function() {
        return Ai
    }), i.d(e, "Raycaster", function() {
        return Bl
    }), i.d(e, "Layers", function() {
        return bi
    }), i.d(e, "EventDispatcher", function() {
        return n
    }), i.d(e, "Clock", function() {
        return zl
    }), i.d(e, "QuaternionLinearInterpolant", function() {
        return ds
    }), i.d(e, "LinearInterpolant", function() {
        return ys
    }), i.d(e, "DiscreteInterpolant", function() {
        return _s
    }), i.d(e, "CubicInterpolant", function() {
        return gs
    }), i.d(e, "Interpolant", function() {
        return ps
    }), i.d(e, "Triangle", function() {
        return dn
    }), i.d(e, "Math", function() {
        return je
    }), i.d(e, "Spherical", function() {
        return Fl
    }), i.d(e, "Cylindrical", function() {
        return Dl
    }), i.d(e, "Plane", function() {
        return ci
    }), i.d(e, "Frustum", function() {
        return ui
    }), i.d(e, "Sphere", function() {
        return hi
    }), i.d(e, "Ray", function() {
        return un
    }), i.d(e, "Matrix4", function() {
        return qe
    }), i.d(e, "Matrix3", function() {
        return Ze
    }), i.d(e, "Box3", function() {
        return li
    }), i.d(e, "Box2", function() {
        return Ul
    }), i.d(e, "Line3", function() {
        return pn
    }), i.d(e, "Euler", function() {
        return xi
    }), i.d(e, "Vector4", function() {
        return ri
    }), i.d(e, "Vector3", function() {
        return Ye
    }), i.d(e, "Vector2", function() {
        return We
    }), i.d(e, "Quaternion", function() {
        return Xe
    }), i.d(e, "Color", function() {
        return vi
    }), i.d(e, "ImmediateRenderObject", function() {
        return kl
    }), i.d(e, "VertexNormalsHelper", function() {
        return Vl
    }), i.d(e, "SpotLightHelper", function() {
        return Hl
    }), i.d(e, "SkeletonHelper", function() {
        return Gl
    }), i.d(e, "PointLightHelper", function() {
        return jl
    }), i.d(e, "RectAreaLightHelper", function() {
        return Wl
    }), i.d(e, "HemisphereLightHelper", function() {
        return ql
    }), i.d(e, "GridHelper", function() {
        return Xl
    }), i.d(e, "PolarGridHelper", function() {
        return Yl
    }), i.d(e, "FaceNormalsHelper", function() {
        return Zl
    }), i.d(e, "DirectionalLightHelper", function() {
        return Jl
    }), i.d(e, "CameraHelper", function() {
        return Kl
    }), i.d(e, "BoxHelper", function() {
        return Ql
    }), i.d(e, "Box3Helper", function() {
        return $l
    }), i.d(e, "PlaneHelper", function() {
        return th
    }), i.d(e, "ArrowHelper", function() {
        return eh
    }), i.d(e, "AxesHelper", function() {
        return ih
    }), i.d(e, "Shape", function() {
        return $a
    }), i.d(e, "Path", function() {
        return Qa
    }), i.d(e, "ShapePath", function() {
        return ks
    }), i.d(e, "Font", function() {
        return Vs
    }), i.d(e, "CurvePath", function() {
        return Ka
    }), i.d(e, "Curve", function() {
        return La
    }), i.d(e, "ShapeUtils", function() {
        return Vo
    }), i.d(e, "WebGLUtils", function() {
        return Rr
    }), i.d(e, "WireframeGeometry", function() {
        return to
    }), i.d(e, "ParametricGeometry", function() {
        return eo
    }), i.d(e, "ParametricBufferGeometry", function() {
        return io
    }), i.d(e, "TetrahedronGeometry", function() {
        return oo
    }), i.d(e, "TetrahedronBufferGeometry", function() {
        return ao
    }), i.d(e, "OctahedronGeometry", function() {
        return so
    }), i.d(e, "OctahedronBufferGeometry", function() {
        return lo
    }), i.d(e, "IcosahedronGeometry", function() {
        return ho
    }), i.d(e, "IcosahedronBufferGeometry", function() {
        return co
    }), i.d(e, "DodecahedronGeometry", function() {
        return uo
    }), i.d(e, "DodecahedronBufferGeometry", function() {
        return po
    }), i.d(e, "PolyhedronGeometry", function() {
        return no
    }), i.d(e, "PolyhedronBufferGeometry", function() {
        return ro
    }), i.d(e, "TubeGeometry", function() {
        return fo
    }), i.d(e, "TubeBufferGeometry", function() {
        return mo
    }), i.d(e, "TorusKnotGeometry", function() {
        return vo
    }), i.d(e, "TorusKnotBufferGeometry", function() {
        return go
    }), i.d(e, "TorusGeometry", function() {
        return yo
    }), i.d(e, "TorusBufferGeometry", function() {
        return _o
    }), i.d(e, "TextGeometry", function() {
        return qo
    }), i.d(e, "TextBufferGeometry", function() {
        return Xo
    }), i.d(e, "SphereGeometry", function() {
        return Yo
    }), i.d(e, "SphereBufferGeometry", function() {
        return Zo
    }), i.d(e, "RingGeometry", function() {
        return Jo
    }), i.d(e, "RingBufferGeometry", function() {
        return Ko
    }), i.d(e, "PlaneGeometry", function() {
        return Ki
    }), i.d(e, "PlaneBufferGeometry", function() {
        return Qi
    }), i.d(e, "LatheGeometry", function() {
        return Qo
    }), i.d(e, "LatheBufferGeometry", function() {
        return $o
    }), i.d(e, "ShapeGeometry", function() {
        return ta
    }), i.d(e, "ShapeBufferGeometry", function() {
        return ea
    }), i.d(e, "ExtrudeGeometry", function() {
        return jo
    }), i.d(e, "ExtrudeBufferGeometry", function() {
        return Wo
    }), i.d(e, "EdgesGeometry", function() {
        return na
    }), i.d(e, "ConeGeometry", function() {
        return aa
    }), i.d(e, "ConeBufferGeometry", function() {
        return sa
    }), i.d(e, "CylinderGeometry", function() {
        return ra
    }), i.d(e, "CylinderBufferGeometry", function() {
        return oa
    }), i.d(e, "CircleGeometry", function() {
        return la
    }), i.d(e, "CircleBufferGeometry", function() {
        return ha
    }), i.d(e, "BoxGeometry", function() {
        return Zi
    }), i.d(e, "BoxBufferGeometry", function() {
        return Ji
    }), i.d(e, "ShadowMaterial", function() {
        return ua
    }), i.d(e, "SpriteMaterial", function() {
        return Fr
    }), i.d(e, "RawShaderMaterial", function() {
        return pa
    }), i.d(e, "ShaderMaterial", function() {
        return cn
    }), i.d(e, "PointsMaterial", function() {
        return Xr
    }), i.d(e, "MeshPhysicalMaterial", function() {
        return fa
    }), i.d(e, "MeshStandardMaterial", function() {
        return da
    }), i.d(e, "MeshPhongMaterial", function() {
        return ma
    }), i.d(e, "MeshToonMaterial", function() {
        return va
    }), i.d(e, "MeshNormalMaterial", function() {
        return ga
    }), i.d(e, "MeshLambertMaterial", function() {
        return ya
    }), i.d(e, "MeshDepthMaterial", function() {
        return Er
    }), i.d(e, "MeshDistanceMaterial", function() {
        return Mr
    }), i.d(e, "MeshBasicMaterial", function() {
        return hn
    }), i.d(e, "LineDashedMaterial", function() {
        return _a
    }), i.d(e, "LineBasicMaterial", function() {
        return Gr
    }), i.d(e, "Material", function() {
        return ln
    }), i.d(e, "Float64BufferAttribute", function() {
        return ji
    }), i.d(e, "Float32BufferAttribute", function() {
        return Gi
    }), i.d(e, "Uint32BufferAttribute", function() {
        return Hi
    }), i.d(e, "Int32BufferAttribute", function() {
        return Vi
    }), i.d(e, "Uint16BufferAttribute", function() {
        return ki
    }), i.d(e, "Int16BufferAttribute", function() {
        return Ui
    }), i.d(e, "Uint8ClampedBufferAttribute", function() {
        return Di
    }), i.d(e, "Uint8BufferAttribute", function() {
        return Fi
    }), i.d(e, "Int8BufferAttribute", function() {
        return zi
    }), i.d(e, "BufferAttribute", function() {
        return Ni
    }), i.d(e, "ArcCurve", function() {
        return Ba
    }), i.d(e, "CatmullRomCurve3", function() {
        return Ua
    }), i.d(e, "CubicBezierCurve", function() {
        return Ga
    }), i.d(e, "CubicBezierCurve3", function() {
        return ja
    }), i.d(e, "EllipseCurve", function() {
        return Oa
    }), i.d(e, "LineCurve", function() {
        return Wa
    }), i.d(e, "LineCurve3", function() {
        return qa
    }), i.d(e, "QuadraticBezierCurve", function() {
        return Xa
    }), i.d(e, "QuadraticBezierCurve3", function() {
        return Ya
    }), i.d(e, "SplineCurve", function() {
        return Za
    }), i.d(e, "REVISION", function() {
        return d
    }), i.d(e, "MOUSE", function() {
        return f
    }), i.d(e, "CullFaceNone", function() {
        return m
    }), i.d(e, "CullFaceBack", function() {
        return v
    }), i.d(e, "CullFaceFront", function() {
        return g
    }), i.d(e, "CullFaceFrontBack", function() {
        return y
    }), i.d(e, "FrontFaceDirectionCW", function() {
        return _
    }), i.d(e, "FrontFaceDirectionCCW", function() {
        return x
    }), i.d(e, "BasicShadowMap", function() {
        return b
    }), i.d(e, "PCFShadowMap", function() {
        return w
    }), i.d(e, "PCFSoftShadowMap", function() {
        return T
    }), i.d(e, "FrontSide", function() {
        return E
    }), i.d(e, "BackSide", function() {
        return M
    }), i.d(e, "DoubleSide", function() {
        return S
    }), i.d(e, "FlatShading", function() {
        return A
    }), i.d(e, "SmoothShading", function() {
        return C
    }), i.d(e, "NoColors", function() {
        return R
    }), i.d(e, "FaceColors", function() {
        return P
    }), i.d(e, "VertexColors", function() {
        return L
    }), i.d(e, "NoBlending", function() {
        return O
    }), i.d(e, "NormalBlending", function() {
        return B
    }), i.d(e, "AdditiveBlending", function() {
        return I
    }), i.d(e, "SubtractiveBlending", function() {
        return N
    }), i.d(e, "MultiplyBlending", function() {
        return z
    }), i.d(e, "CustomBlending", function() {
        return F
    }), i.d(e, "AddEquation", function() {
        return D
    }), i.d(e, "SubtractEquation", function() {
        return U
    }), i.d(e, "ReverseSubtractEquation", function() {
        return k
    }), i.d(e, "MinEquation", function() {
        return V
    }), i.d(e, "MaxEquation", function() {
        return H
    }), i.d(e, "ZeroFactor", function() {
        return G
    }), i.d(e, "OneFactor", function() {
        return j
    }), i.d(e, "SrcColorFactor", function() {
        return W
    }), i.d(e, "OneMinusSrcColorFactor", function() {
        return q
    }), i.d(e, "SrcAlphaFactor", function() {
        return X
    }), i.d(e, "OneMinusSrcAlphaFactor", function() {
        return Y
    }), i.d(e, "DstAlphaFactor", function() {
        return Z
    }), i.d(e, "OneMinusDstAlphaFactor", function() {
        return J
    }), i.d(e, "DstColorFactor", function() {
        return K
    }), i.d(e, "OneMinusDstColorFactor", function() {
        return Q
    }), i.d(e, "SrcAlphaSaturateFactor", function() {
        return $
    }), i.d(e, "NeverDepth", function() {
        return tt
    }), i.d(e, "AlwaysDepth", function() {
        return et
    }), i.d(e, "LessDepth", function() {
        return it
    }), i.d(e, "LessEqualDepth", function() {
        return nt
    }), i.d(e, "EqualDepth", function() {
        return rt
    }), i.d(e, "GreaterEqualDepth", function() {
        return ot
    }), i.d(e, "GreaterDepth", function() {
        return at
    }), i.d(e, "NotEqualDepth", function() {
        return st
    }), i.d(e, "MultiplyOperation", function() {
        return lt
    }), i.d(e, "MixOperation", function() {
        return ht
    }), i.d(e, "AddOperation", function() {
        return ct
    }), i.d(e, "NoToneMapping", function() {
        return ut
    }), i.d(e, "LinearToneMapping", function() {
        return pt
    }), i.d(e, "ReinhardToneMapping", function() {
        return dt
    }), i.d(e, "Uncharted2ToneMapping", function() {
        return ft
    }), i.d(e, "CineonToneMapping", function() {
        return mt
    }), i.d(e, "UVMapping", function() {
        return vt
    }), i.d(e, "CubeReflectionMapping", function() {
        return gt
    }), i.d(e, "CubeRefractionMapping", function() {
        return yt
    }), i.d(e, "EquirectangularReflectionMapping", function() {
        return _t
    }), i.d(e, "EquirectangularRefractionMapping", function() {
        return xt
    }), i.d(e, "SphericalReflectionMapping", function() {
        return bt
    }), i.d(e, "CubeUVReflectionMapping", function() {
        return wt
    }), i.d(e, "CubeUVRefractionMapping", function() {
        return Tt
    }), i.d(e, "RepeatWrapping", function() {
        return Et
    }), i.d(e, "ClampToEdgeWrapping", function() {
        return Mt
    }), i.d(e, "MirroredRepeatWrapping", function() {
        return St
    }), i.d(e, "NearestFilter", function() {
        return At
    }), i.d(e, "NearestMipMapNearestFilter", function() {
        return Ct
    }), i.d(e, "NearestMipMapLinearFilter", function() {
        return Rt
    }), i.d(e, "LinearFilter", function() {
        return Pt
    }), i.d(e, "LinearMipMapNearestFilter", function() {
        return Lt
    }), i.d(e, "LinearMipMapLinearFilter", function() {
        return Ot
    }), i.d(e, "UnsignedByteType", function() {
        return Bt
    }), i.d(e, "ByteType", function() {
        return It
    }), i.d(e, "ShortType", function() {
        return Nt
    }), i.d(e, "UnsignedShortType", function() {
        return zt
    }), i.d(e, "IntType", function() {
        return Ft
    }), i.d(e, "UnsignedIntType", function() {
        return Dt
    }), i.d(e, "FloatType", function() {
        return Ut
    }), i.d(e, "HalfFloatType", function() {
        return kt
    }), i.d(e, "UnsignedShort4444Type", function() {
        return Vt
    }), i.d(e, "UnsignedShort5551Type", function() {
        return Ht
    }), i.d(e, "UnsignedShort565Type", function() {
        return Gt
    }), i.d(e, "UnsignedInt248Type", function() {
        return jt
    }), i.d(e, "AlphaFormat", function() {
        return Wt
    }), i.d(e, "RGBFormat", function() {
        return qt
    }), i.d(e, "RGBAFormat", function() {
        return Xt
    }), i.d(e, "LuminanceFormat", function() {
        return Yt
    }), i.d(e, "LuminanceAlphaFormat", function() {
        return Zt
    }), i.d(e, "RGBEFormat", function() {
        return Jt
    }), i.d(e, "DepthFormat", function() {
        return Kt
    }), i.d(e, "DepthStencilFormat", function() {
        return Qt
    }), i.d(e, "RGB_S3TC_DXT1_Format", function() {
        return $t
    }), i.d(e, "RGBA_S3TC_DXT1_Format", function() {
        return te
    }), i.d(e, "RGBA_S3TC_DXT3_Format", function() {
        return ee
    }), i.d(e, "RGBA_S3TC_DXT5_Format", function() {
        return ie
    }), i.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
        return ne
    }), i.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
        return re
    }), i.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
        return oe
    }), i.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
        return ae
    }), i.d(e, "RGB_ETC1_Format", function() {
        return se
    }), i.d(e, "RGBA_ASTC_4x4_Format", function() {
        return le
    }), i.d(e, "RGBA_ASTC_5x4_Format", function() {
        return he
    }), i.d(e, "RGBA_ASTC_5x5_Format", function() {
        return ce
    }), i.d(e, "RGBA_ASTC_6x5_Format", function() {
        return ue
    }), i.d(e, "RGBA_ASTC_6x6_Format", function() {
        return pe
    }), i.d(e, "RGBA_ASTC_8x5_Format", function() {
        return de
    }), i.d(e, "RGBA_ASTC_8x6_Format", function() {
        return fe
    }), i.d(e, "RGBA_ASTC_8x8_Format", function() {
        return me
    }), i.d(e, "RGBA_ASTC_10x5_Format", function() {
        return ve
    }), i.d(e, "RGBA_ASTC_10x6_Format", function() {
        return ge
    }), i.d(e, "RGBA_ASTC_10x8_Format", function() {
        return ye
    }), i.d(e, "RGBA_ASTC_10x10_Format", function() {
        return _e
    }), i.d(e, "RGBA_ASTC_12x10_Format", function() {
        return xe
    }), i.d(e, "RGBA_ASTC_12x12_Format", function() {
        return be
    }), i.d(e, "LoopOnce", function() {
        return we
    }), i.d(e, "LoopRepeat", function() {
        return Te
    }), i.d(e, "LoopPingPong", function() {
        return Ee
    }), i.d(e, "InterpolateDiscrete", function() {
        return Me
    }), i.d(e, "InterpolateLinear", function() {
        return Se
    }), i.d(e, "InterpolateSmooth", function() {
        return Ae
    }), i.d(e, "ZeroCurvatureEnding", function() {
        return Ce
    }), i.d(e, "ZeroSlopeEnding", function() {
        return Re
    }), i.d(e, "WrapAroundEnding", function() {
        return Pe
    }), i.d(e, "TrianglesDrawMode", function() {
        return Le
    }), i.d(e, "TriangleStripDrawMode", function() {
        return Oe
    }), i.d(e, "TriangleFanDrawMode", function() {
        return Be
    }), i.d(e, "LinearEncoding", function() {
        return Ie
    }), i.d(e, "sRGBEncoding", function() {
        return Ne
    }), i.d(e, "GammaEncoding", function() {
        return ze
    }), i.d(e, "RGBEEncoding", function() {
        return Fe
    }), i.d(e, "LogLuvEncoding", function() {
        return De
    }), i.d(e, "RGBM7Encoding", function() {
        return Ue
    }), i.d(e, "RGBM16Encoding", function() {
        return ke
    }), i.d(e, "RGBDEncoding", function() {
        return Ve
    }), i.d(e, "BasicDepthPacking", function() {
        return He
    }), i.d(e, "RGBADepthPacking", function() {
        return Ge
    }), i.d(e, "CubeGeometry", function() {
        return Zi
    }), i.d(e, "Face4", function() {
        return nh
    }), i.d(e, "LineStrip", function() {
        return rh
    }), i.d(e, "LinePieces", function() {
        return oh
    }), i.d(e, "MeshFaceMaterial", function() {
        return ah
    }), i.d(e, "MultiMaterial", function() {
        return sh
    }), i.d(e, "PointCloud", function() {
        return lh
    }), i.d(e, "Particle", function() {
        return hh
    }), i.d(e, "ParticleSystem", function() {
        return ch
    }), i.d(e, "PointCloudMaterial", function() {
        return uh
    }), i.d(e, "ParticleBasicMaterial", function() {
        return ph
    }), i.d(e, "ParticleSystemMaterial", function() {
        return dh
    }), i.d(e, "Vertex", function() {
        return fh
    }), i.d(e, "DynamicBufferAttribute", function() {
        return mh
    }), i.d(e, "Int8Attribute", function() {
        return vh
    }), i.d(e, "Uint8Attribute", function() {
        return gh
    }), i.d(e, "Uint8ClampedAttribute", function() {
        return yh
    }), i.d(e, "Int16Attribute", function() {
        return _h
    }), i.d(e, "Uint16Attribute", function() {
        return xh
    }), i.d(e, "Int32Attribute", function() {
        return bh
    }), i.d(e, "Uint32Attribute", function() {
        return wh
    }), i.d(e, "Float32Attribute", function() {
        return Th
    }), i.d(e, "Float64Attribute", function() {
        return Eh
    }), i.d(e, "ClosedSplineCurve3", function() {
        return Mh
    }), i.d(e, "SplineCurve3", function() {
        return Sh
    }), i.d(e, "Spline", function() {
        return Ah
    }), i.d(e, "AxisHelper", function() {
        return Ch
    }), i.d(e, "BoundingBoxHelper", function() {
        return Rh
    }), i.d(e, "EdgesHelper", function() {
        return Ph
    }), i.d(e, "WireframeHelper", function() {
        return Lh
    }), i.d(e, "XHRLoader", function() {
        return Oh
    }), i.d(e, "BinaryTextureLoader", function() {
        return Bh
    }), i.d(e, "GeometryUtils", function() {
        return Ih
    }), i.d(e, "ImageUtils", function() {
        return Nh
    }), i.d(e, "Projector", function() {
        return zh
    }), i.d(e, "CanvasRenderer", function() {
        return Fh
    }), i.d(e, "SceneUtils", function() {
        return Dh
    }), i.d(e, "LensFlare", function() {
        return Uh
    }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }), void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }), "name" in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function(t) {
        if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (void 0 !== n && null !== n)
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
        }
        return e
    }), Object.assign(n.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var i = this._listeners[t];
                if (void 0 !== i) {
                    var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                }
            }
        }
    });
    var r, o, a, s, l, h, c, u, p, d = "92dev",
        f = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        },
        m = 0,
        v = 1,
        g = 2,
        y = 3,
        _ = 0,
        x = 1,
        b = 0,
        w = 1,
        T = 2,
        E = 0,
        M = 1,
        S = 2,
        A = 1,
        C = 2,
        R = 0,
        P = 1,
        L = 2,
        O = 0,
        B = 1,
        I = 2,
        N = 3,
        z = 4,
        F = 5,
        D = 100,
        U = 101,
        k = 102,
        V = 103,
        H = 104,
        G = 200,
        j = 201,
        W = 202,
        q = 203,
        X = 204,
        Y = 205,
        Z = 206,
        J = 207,
        K = 208,
        Q = 209,
        $ = 210,
        tt = 0,
        et = 1,
        it = 2,
        nt = 3,
        rt = 4,
        ot = 5,
        at = 6,
        st = 7,
        lt = 0,
        ht = 1,
        ct = 2,
        ut = 0,
        pt = 1,
        dt = 2,
        ft = 3,
        mt = 4,
        vt = 300,
        gt = 301,
        yt = 302,
        _t = 303,
        xt = 304,
        bt = 305,
        wt = 306,
        Tt = 307,
        Et = 1e3,
        Mt = 1001,
        St = 1002,
        At = 1003,
        Ct = 1004,
        Rt = 1005,
        Pt = 1006,
        Lt = 1007,
        Ot = 1008,
        Bt = 1009,
        It = 1010,
        Nt = 1011,
        zt = 1012,
        Ft = 1013,
        Dt = 1014,
        Ut = 1015,
        kt = 1016,
        Vt = 1017,
        Ht = 1018,
        Gt = 1019,
        jt = 1020,
        Wt = 1021,
        qt = 1022,
        Xt = 1023,
        Yt = 1024,
        Zt = 1025,
        Jt = Xt,
        Kt = 1026,
        Qt = 1027,
        $t = 33776,
        te = 33777,
        ee = 33778,
        ie = 33779,
        ne = 35840,
        re = 35841,
        oe = 35842,
        ae = 35843,
        se = 36196,
        le = 37808,
        he = 37809,
        ce = 37810,
        ue = 37811,
        pe = 37812,
        de = 37813,
        fe = 37814,
        me = 37815,
        ve = 37816,
        ge = 37817,
        ye = 37818,
        _e = 37819,
        xe = 37820,
        be = 37821,
        we = 2200,
        Te = 2201,
        Ee = 2202,
        Me = 2300,
        Se = 2301,
        Ae = 2302,
        Ce = 2400,
        Re = 2401,
        Pe = 2402,
        Le = 0,
        Oe = 1,
        Be = 2,
        Ie = 3e3,
        Ne = 3001,
        ze = 3007,
        Fe = 3002,
        De = 3003,
        Ue = 3004,
        ke = 3005,
        Ve = 3006,
        He = 3200,
        Ge = 3201,
        je = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                return function() {
                    var e = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0;
                    return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
                }
            }(),
            clamp: function(t, e, i) {
                return Math.max(e, Math.min(i, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, i, n, r) {
                return n + (t - e) * (r - n) / (i - e)
            },
            lerp: function(t, e, i) {
                return (1 - i) * t + i * e
            },
            smoothstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * je.DEG2RAD
            },
            radToDeg: function(t) {
                return t * je.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            }
        };

    function We(t, e) {
        this.x = t || 0, this.y = e || 0
    }

    function qe() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function Xe(t, e, i, n) {
        this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function Ye(t, e, i) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0
    }

    function Ze() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(We.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }), Object.assign(We.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t, this.y = e, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        },
        multiply: function(t) {
            return this.x *= t.x, this.y *= t.y, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            var e = this.x,
                i = this.y,
                n = t.elements;
            return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        },
        clampScalar: (r = new We, o = new We, function(t, e) {
            return r.set(t, t), o.set(e, e), this.clamp(r, o)
        }),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI), t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                i = this.y - t.y;
            return e * e + i * i
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        },
        fromBufferAttribute: function(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        },
        rotateAround: function(t, e) {
            var i = Math.cos(e),
                n = Math.sin(e),
                r = this.x - t.x,
                o = this.y - t.y;
            return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this
        }
    }), Object.assign(qe.prototype, {
        isMatrix4: !0,
        set: function(t, e, i, n, r, o, a, s, l, h, c, u, p, d, f, m) {
            var v = this.elements;
            return v[0] = t, v[4] = e, v[8] = i, v[12] = n, v[1] = r, v[5] = o, v[9] = a, v[13] = s, v[2] = l, v[6] = h, v[10] = c, v[14] = u, v[3] = p, v[7] = d, v[11] = f, v[15] = m, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new qe).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
                i = t.elements;
            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
        },
        copyPosition: function(t) {
            var e = this.elements,
                i = t.elements;
            return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
        },
        extractBasis: function(t, e, i) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        },
        makeBasis: function(t, e, i) {
            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
        },
        extractRotation: (u = new Ye, function(t) {
            var e = this.elements,
                i = t.elements,
                n = 1 / u.setFromMatrixColumn(t, 0).length(),
                r = 1 / u.setFromMatrixColumn(t, 1).length(),
                o = 1 / u.setFromMatrixColumn(t, 2).length();
            return e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[8] = i[8] * o, e[9] = i[9] * o, e[10] = i[10] * o, this
        }),
        makeRotationFromEuler: function(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements,
                i = t.x,
                n = t.y,
                r = t.z,
                o = Math.cos(i),
                a = Math.sin(i),
                s = Math.cos(n),
                l = Math.sin(n),
                h = Math.cos(r),
                c = Math.sin(r);
            if ("XYZ" === t.order) {
                var u = o * h,
                    p = o * c,
                    d = a * h,
                    f = a * c;
                e[0] = s * h, e[4] = -s * c, e[8] = l, e[1] = p + d * l, e[5] = u - f * l, e[9] = -a * s, e[2] = f - u * l, e[6] = d + p * l, e[10] = o * s
            } else if ("YXZ" === t.order) {
                var m = s * h,
                    v = s * c,
                    g = l * h,
                    y = l * c;
                e[0] = m + y * a, e[4] = g * a - v, e[8] = o * l, e[1] = o * c, e[5] = o * h, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = o * s
            } else if ("ZXY" === t.order) m = s * h, v = s * c, g = l * h, y = l * c, e[0] = m - y * a, e[4] = -o * c, e[8] = g + v * a, e[1] = v + g * a, e[5] = o * h, e[9] = y - m * a, e[2] = -o * l, e[6] = a, e[10] = o * s;
            else if ("ZYX" === t.order) u = o * h, p = o * c, d = a * h, f = a * c, e[0] = s * h, e[4] = d * l - p, e[8] = u * l + f, e[1] = s * c, e[5] = f * l + u, e[9] = p * l - d, e[2] = -l, e[6] = a * s, e[10] = o * s;
            else if ("YZX" === t.order) {
                var _ = o * s,
                    x = o * l,
                    b = a * s,
                    w = a * l;
                e[0] = s * h, e[4] = w - _ * c, e[8] = b * c + x, e[1] = c, e[5] = o * h, e[9] = -a * h, e[2] = -l * h, e[6] = x * c + b, e[10] = _ - w * c
            } else "XZY" === t.order && (_ = o * s, x = o * l, b = a * s, w = a * l, e[0] = s * h, e[4] = -c, e[8] = l * h, e[1] = _ * c + w, e[5] = o * h, e[9] = x * c - b, e[2] = b * c - x, e[6] = a * h, e[10] = w * c + _);
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        makeRotationFromQuaternion: function(t) {
            var e = this.elements,
                i = t._x,
                n = t._y,
                r = t._z,
                o = t._w,
                a = i + i,
                s = n + n,
                l = r + r,
                h = i * a,
                c = i * s,
                u = i * l,
                p = n * s,
                d = n * l,
                f = r * l,
                m = o * a,
                v = o * s,
                g = o * l;
            return e[0] = 1 - (p + f), e[4] = c - g, e[8] = u + v, e[1] = c + g, e[5] = 1 - (h + f), e[9] = d - m, e[2] = u - v, e[6] = d + m, e[10] = 1 - (h + p), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        },
        lookAt: (l = new Ye, h = new Ye, c = new Ye, function(t, e, i) {
            var n = this.elements;
            return c.subVectors(t, e), 0 === c.lengthSq() && (c.z = 1), c.normalize(), l.crossVectors(i, c), 0 === l.lengthSq() && (1 === Math.abs(i.z) ? c.x += 1e-4 : c.z += 1e-4, c.normalize(), l.crossVectors(i, c)), l.normalize(), h.crossVectors(c, l), n[0] = l.x, n[4] = h.x, n[8] = c.x, n[1] = l.y, n[5] = h.y, n[9] = c.y, n[2] = l.z, n[6] = h.z, n[10] = c.z, this
        }),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var i = t.elements,
                n = e.elements,
                r = this.elements,
                o = i[0],
                a = i[4],
                s = i[8],
                l = i[12],
                h = i[1],
                c = i[5],
                u = i[9],
                p = i[13],
                d = i[2],
                f = i[6],
                m = i[10],
                v = i[14],
                g = i[3],
                y = i[7],
                _ = i[11],
                x = i[15],
                b = n[0],
                w = n[4],
                T = n[8],
                E = n[12],
                M = n[1],
                S = n[5],
                A = n[9],
                C = n[13],
                R = n[2],
                P = n[6],
                L = n[10],
                O = n[14],
                B = n[3],
                I = n[7],
                N = n[11],
                z = n[15];
            return r[0] = o * b + a * M + s * R + l * B, r[4] = o * w + a * S + s * P + l * I, r[8] = o * T + a * A + s * L + l * N, r[12] = o * E + a * C + s * O + l * z, r[1] = h * b + c * M + u * R + p * B, r[5] = h * w + c * S + u * P + p * I, r[9] = h * T + c * A + u * L + p * N, r[13] = h * E + c * C + u * O + p * z, r[2] = d * b + f * M + m * R + v * B, r[6] = d * w + f * S + m * P + v * I, r[10] = d * T + f * A + m * L + v * N, r[14] = d * E + f * C + m * O + v * z, r[3] = g * b + y * M + _ * R + x * B, r[7] = g * w + y * S + _ * P + x * I, r[11] = g * T + y * A + _ * L + x * N, r[15] = g * E + y * C + _ * O + x * z, this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        },
        applyToBufferAttribute: function() {
            var t = new Ye;
            return function(e) {
                for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(),
        determinant: function() {
            var t = this.elements,
                e = t[0],
                i = t[4],
                n = t[8],
                r = t[12],
                o = t[1],
                a = t[5],
                s = t[9],
                l = t[13],
                h = t[2],
                c = t[6],
                u = t[10],
                p = t[14];
            return t[3] * (+r * s * c - n * l * c - r * a * u + i * l * u + n * a * p - i * s * p) + t[7] * (+e * s * p - e * l * u + r * o * u - n * o * p + n * l * h - r * s * h) + t[11] * (+e * l * c - e * a * p - r * o * c + i * o * p + r * a * h - i * l * h) + t[15] * (-n * a * h - e * s * c + e * a * u + n * o * c - i * o * u + i * s * h)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
        },
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
        },
        getInverse: function(t, e) {
            var i = this.elements,
                n = t.elements,
                r = n[0],
                o = n[1],
                a = n[2],
                s = n[3],
                l = n[4],
                h = n[5],
                c = n[6],
                u = n[7],
                p = n[8],
                d = n[9],
                f = n[10],
                m = n[11],
                v = n[12],
                g = n[13],
                y = n[14],
                _ = n[15],
                x = d * y * u - g * f * u + g * c * m - h * y * m - d * c * _ + h * f * _,
                b = v * f * u - p * y * u - v * c * m + l * y * m + p * c * _ - l * f * _,
                w = p * g * u - v * d * u + v * h * m - l * g * m - p * h * _ + l * d * _,
                T = v * d * c - p * g * c - v * h * f + l * g * f + p * h * y - l * d * y,
                E = r * x + o * b + a * w + s * T;
            if (0 === E) {
                var M = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e) throw new Error(M);
                return console.warn(M), this.identity()
            }
            var S = 1 / E;
            return i[0] = x * S, i[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * _ - o * f * _) * S, i[2] = (h * y * s - g * c * s + g * a * u - o * y * u - h * a * _ + o * c * _) * S, i[3] = (d * c * s - h * f * s - d * a * u + o * f * u + h * a * m - o * c * m) * S, i[4] = b * S, i[5] = (p * y * s - v * f * s + v * a * m - r * y * m - p * a * _ + r * f * _) * S, i[6] = (v * c * s - l * y * s - v * a * u + r * y * u + l * a * _ - r * c * _) * S, i[7] = (l * f * s - p * c * s + p * a * u - r * f * u - l * a * m + r * c * m) * S, i[8] = w * S, i[9] = (v * d * s - p * g * s - v * o * m + r * g * m + p * o * _ - r * d * _) * S, i[10] = (l * g * s - v * h * s + v * o * u - r * g * u - l * o * _ + r * h * _) * S, i[11] = (p * h * s - l * d * s - p * o * u + r * d * u + l * o * m - r * h * m) * S, i[12] = T * S, i[13] = (p * g * a - v * d * a + v * o * f - r * g * f - p * o * y + r * d * y) * S, i[14] = (v * h * a - l * g * a - v * o * c + r * g * c + l * o * y - r * h * y) * S, i[15] = (l * d * a - p * h * a + p * o * c - r * d * c - l * o * f + r * h * f) * S, this
        },
        scale: function(t) {
            var e = this.elements,
                i = t.x,
                n = t.y,
                r = t.z;
            return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, i, n))
        },
        makeTranslation: function(t, e, i) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t);
            return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t);
            return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        },
        makeRotationAxis: function(t, e) {
            var i = Math.cos(e),
                n = Math.sin(e),
                r = 1 - i,
                o = t.x,
                a = t.y,
                s = t.z,
                l = r * o,
                h = r * a;
            return this.set(l * o + i, l * a - n * s, l * s + n * a, 0, l * a + n * s, h * a + i, h * s - n * o, 0, l * s - n * a, h * s + n * o, r * s * s + i, 0, 0, 0, 0, 1), this
        },
        makeScale: function(t, e, i) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        },
        makeShear: function(t, e, i) {
            return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
        },
        compose: function(t, e, i) {
            return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this
        },
        decompose: (a = new Ye, s = new qe, function(t, e, i) {
            var n = this.elements,
                r = a.set(n[0], n[1], n[2]).length(),
                o = a.set(n[4], n[5], n[6]).length(),
                l = a.set(n[8], n[9], n[10]).length();
            this.determinant() < 0 && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], s.copy(this);
            var h = 1 / r,
                c = 1 / o,
                u = 1 / l;
            return s.elements[0] *= h, s.elements[1] *= h, s.elements[2] *= h, s.elements[4] *= c, s.elements[5] *= c, s.elements[6] *= c, s.elements[8] *= u, s.elements[9] *= u, s.elements[10] *= u, e.setFromRotationMatrix(s), i.x = r, i.y = o, i.z = l, this
        }),
        makePerspective: function(t, e, i, n, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements,
                s = 2 * r / (e - t),
                l = 2 * r / (i - n),
                h = (e + t) / (e - t),
                c = (i + n) / (i - n),
                u = -(o + r) / (o - r),
                p = -2 * o * r / (o - r);
            return a[0] = s, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = l, a[9] = c, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
        },
        makeOrthographic: function(t, e, i, n, r, o) {
            var a = this.elements,
                s = 1 / (e - t),
                l = 1 / (i - n),
                h = 1 / (o - r),
                c = (e + t) * s,
                u = (i + n) * l,
                p = (o + r) * h;
            return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -c, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
        },
        equals: function(t) {
            for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                if (e[n] !== i[n]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
        }
    }), Object.assign(Xe, {
        slerp: function(t, e, i, n) {
            return i.copy(t).slerp(e, n)
        },
        slerpFlat: function(t, e, i, n, r, o, a) {
            var s = i[n + 0],
                l = i[n + 1],
                h = i[n + 2],
                c = i[n + 3],
                u = r[o + 0],
                p = r[o + 1],
                d = r[o + 2],
                f = r[o + 3];
            if (c !== f || s !== u || l !== p || h !== d) {
                var m = 1 - a,
                    v = s * u + l * p + h * d + c * f,
                    g = v >= 0 ? 1 : -1,
                    y = 1 - v * v;
                if (y > Number.EPSILON) {
                    var _ = Math.sqrt(y),
                        x = Math.atan2(_, v * g);
                    m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                }
                var b = a * g;
                if (s = s * m + u * b, l = l * m + p * b, h = h * m + d * b, c = c * m + f * b, m === 1 - a) {
                    var w = 1 / Math.sqrt(s * s + l * l + h * h + c * c);
                    s *= w, l *= w, h *= w, c *= w
                }
            }
            t[e] = s, t[e + 1] = l, t[e + 2] = h, t[e + 3] = c
        }
    }), Object.defineProperties(Xe.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t, this.onChangeCallback()
            }
        }
    }), Object.assign(Xe.prototype, {
        set: function(t, e, i, n) {
            return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = t._x,
                n = t._y,
                r = t._z,
                o = t.order,
                a = Math.cos,
                s = Math.sin,
                l = a(i / 2),
                h = a(n / 2),
                c = a(r / 2),
                u = s(i / 2),
                p = s(n / 2),
                d = s(r / 2);
            return "XYZ" === o ? (this._x = u * h * c + l * p * d, this._y = l * p * c - u * h * d, this._z = l * h * d + u * p * c, this._w = l * h * c - u * p * d) : "YXZ" === o ? (this._x = u * h * c + l * p * d, this._y = l * p * c - u * h * d, this._z = l * h * d - u * p * c, this._w = l * h * c + u * p * d) : "ZXY" === o ? (this._x = u * h * c - l * p * d, this._y = l * p * c + u * h * d, this._z = l * h * d + u * p * c, this._w = l * h * c - u * p * d) : "ZYX" === o ? (this._x = u * h * c - l * p * d, this._y = l * p * c + u * h * d, this._z = l * h * d - u * p * c, this._w = l * h * c + u * p * d) : "YZX" === o ? (this._x = u * h * c + l * p * d, this._y = l * p * c + u * h * d, this._z = l * h * d - u * p * c, this._w = l * h * c - u * p * d) : "XZY" === o && (this._x = u * h * c - l * p * d, this._y = l * p * c - u * h * d, this._z = l * h * d + u * p * c, this._w = l * h * c + u * p * d), !1 !== e && this.onChangeCallback(), this
        },
        setFromAxisAngle: function(t, e) {
            var i = e / 2,
                n = Math.sin(i);
            return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t) {
            var e, i = t.elements,
                n = i[0],
                r = i[4],
                o = i[8],
                a = i[1],
                s = i[5],
                l = i[9],
                h = i[2],
                c = i[6],
                u = i[10],
                p = n + s + u;
            return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (c - l) * e, this._y = (o - h) * e, this._z = (a - r) * e) : n > s && n > u ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (c - l) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + h) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - n - u), this._w = (o - h) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (l + c) / e) : (e = 2 * Math.sqrt(1 + u - n - s), this._w = (a - r) / e, this._x = (o + h) / e, this._y = (l + c) / e, this._z = .25 * e), this.onChangeCallback(), this
        },
        setFromUnitVectors: function() {
            var t, e = new Ye;
            return function(i, n) {
                return void 0 === e && (e = new Ye), (t = i.dot(n) + 1) < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
            }
        }(),
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var i = t._x,
                n = t._y,
                r = t._z,
                o = t._w,
                a = e._x,
                s = e._y,
                l = e._z,
                h = e._w;
            return this._x = i * h + o * a + n * l - r * s, this._y = n * h + o * s + r * a - i * l, this._z = r * h + o * l + i * s - n * a, this._w = o * h - i * a - n * s - r * l, this.onChangeCallback(), this
        },
        slerp: function(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var i = this._x,
                n = this._y,
                r = this._z,
                o = this._w,
                a = o * t._w + i * t._x + n * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
            var s = Math.sqrt(1 - a * a);
            if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this;
            var l = Math.atan2(s, a),
                h = Math.sin((1 - e) * l) / s,
                c = Math.sin(e * l) / s;
            return this._w = o * h + this._w * c, this._x = i * h + this._x * c, this._y = n * h + this._y * c, this._z = r * h + this._z * c, this.onChangeCallback(), this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }), Object.assign(Ye.prototype, {
        isVector3: !0,
        set: function(t, e, i) {
            return this.x = t, this.y = e, this.z = i, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        },
        applyEuler: (p = new Xe, function(t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(p.setFromEuler(t))
        }),
        applyAxisAngle: function() {
            var t = new Xe;
            return function(e, i) {
                return this.applyQuaternion(t.setFromAxisAngle(e, i))
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.elements,
                o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
            return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o, this
        },
        applyQuaternion: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.x,
                o = t.y,
                a = t.z,
                s = t.w,
                l = s * e + o * n - a * i,
                h = s * i + a * e - r * n,
                c = s * n + r * i - o * e,
                u = -r * e - o * i - a * n;
            return this.x = l * s + u * -r + h * -a - c * -o, this.y = h * s + u * -o + c * -r - l * -a, this.z = c * s + u * -a + l * -o - h * -r, this
        },
        project: function() {
            var t = new qe;
            return function(e) {
                return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t)
            }
        }(),
        unproject: function() {
            var t = new qe;
            return function(e) {
                return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t)
            }
        }(),
        transformDirection: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        },
        clampScalar: function() {
            var t = new Ye,
                e = new Ye;
            return function(i, n) {
                return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        cross: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            var i = t.x,
                n = t.y,
                r = t.z,
                o = e.x,
                a = e.y,
                s = e.z;
            return this.x = n * s - r * a, this.y = r * o - i * s, this.z = i * a - n * o, this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function() {
            var t = new Ye;
            return function(e) {
                return t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(),
        reflect: function() {
            var t = new Ye;
            return function(e) {
                return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
            return Math.acos(je.clamp(e, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
                i = this.y - t.y,
                n = this.z - t.z;
            return e * e + i * i + n * n
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            var e = Math.sin(t.phi) * t.radius;
            return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
        },
        setFromCylindrical: function(t) {
            return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
        },
        setFromMatrixPosition: function(t) {
            var e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
                i = this.setFromMatrixColumn(t, 1).length(),
                n = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = i, this.z = n, this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        },
        fromBufferAttribute: function(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
    }), Object.assign(Ze.prototype, {
        isMatrix3: !0,
        set: function(t, e, i, n, r, o, a, s, l) {
            var h = this.elements;
            return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = s, h[6] = i, h[7] = o, h[8] = l, this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
                i = t.elements;
            return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
        },
        setFromMatrix4: function(t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        },
        applyToBufferAttribute: function() {
            var t = new Ye;
            return function(e) {
                for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var i = t.elements,
                n = e.elements,
                r = this.elements,
                o = i[0],
                a = i[3],
                s = i[6],
                l = i[1],
                h = i[4],
                c = i[7],
                u = i[2],
                p = i[5],
                d = i[8],
                f = n[0],
                m = n[3],
                v = n[6],
                g = n[1],
                y = n[4],
                _ = n[7],
                x = n[2],
                b = n[5],
                w = n[8];
            return r[0] = o * f + a * g + s * x, r[3] = o * m + a * y + s * b, r[6] = o * v + a * _ + s * w, r[1] = l * f + h * g + c * x, r[4] = l * m + h * y + c * b, r[7] = l * v + h * _ + c * w, r[2] = u * f + p * g + d * x, r[5] = u * m + p * y + d * b, r[8] = u * v + p * _ + d * w, this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        },
        determinant: function() {
            var t = this.elements,
                e = t[0],
                i = t[1],
                n = t[2],
                r = t[3],
                o = t[4],
                a = t[5],
                s = t[6],
                l = t[7],
                h = t[8];
            return e * o * h - e * a * l - i * r * h + i * a * s + n * r * l - n * o * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = t.elements,
                n = this.elements,
                r = i[0],
                o = i[1],
                a = i[2],
                s = i[3],
                l = i[4],
                h = i[5],
                c = i[6],
                u = i[7],
                p = i[8],
                d = p * l - h * u,
                f = h * c - p * s,
                m = u * s - l * c,
                v = r * d + o * f + a * m;
            if (0 === v) {
                var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e) throw new Error(g);
                return console.warn(g), this.identity()
            }
            var y = 1 / v;
            return n[0] = d * y, n[1] = (a * u - p * o) * y, n[2] = (h * o - a * l) * y, n[3] = f * y, n[4] = (p * r - a * c) * y, n[5] = (a * s - h * r) * y, n[6] = m * y, n[7] = (o * c - u * r) * y, n[8] = (l * r - o * s) * y, this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        },
        setUvTransform: function(t, e, i, n, r, o, a) {
            var s = Math.cos(r),
                l = Math.sin(r);
            this.set(i * s, i * l, -i * (s * o + l * a) + o + t, -n * l, n * s, -n * (-l * o + s * a) + a + e, 0, 0, 1)
        },
        scale: function(t, e) {
            var i = this.elements;
            return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
        },
        rotate: function(t) {
            var e = Math.cos(t),
                i = Math.sin(t),
                n = this.elements,
                r = n[0],
                o = n[3],
                a = n[6],
                s = n[1],
                l = n[4],
                h = n[7];
            return n[0] = e * r + i * s, n[3] = e * o + i * l, n[6] = e * a + i * h, n[1] = -i * r + e * s, n[4] = -i * o + e * l, n[7] = -i * a + e * h, this
        },
        translate: function(t, e) {
            var i = this.elements;
            return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
        },
        equals: function(t) {
            for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                if (e[n] !== i[n]) return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
        }
    });
    var Je, Ke, Qe, $e, ti, ei, ii = 0;

    function ni(t, e, i, n, r, o, a, s, l, h) {
        Object.defineProperty(this, "id", {
            value: ii++
        }), this.uuid = je.generateUUID(), this.name = "", this.image = void 0 !== t ? t : ni.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : ni.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : Mt, this.wrapT = void 0 !== n ? n : Mt, this.magFilter = void 0 !== r ? r : Pt, this.minFilter = void 0 !== o ? o : Ot, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== a ? a : Xt, this.type = void 0 !== s ? s : Bt, this.offset = new We(0, 0), this.repeat = new We(1, 1), this.center = new We(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ze, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : Ie, this.version = 0, this.onUpdate = null
    }

    function ri(t, e, i, n) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function oi(t, e, i) {
        if (this.width = t, this.height = e, this.scissor = new ri(0, 0, t, e), this.scissorTest = !1, this.viewport = new ri(0, 0, t, e), void 0 === (i = i || {}).minFilter && (i.minFilter = Pt), this.texture = new ni(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), void 0 === i.generateMipmaps && (i.generateMipmaps = !1), this.texture.generateMipmaps = i.generateMipmaps, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null, this.drawBuffersTextures = [], void 0 !== i.drawBuffersTextures)
            for (var n = 0; n < i.drawBuffersTextures.length; n++) this.drawBuffersTextures[n] = i.drawBuffersTextures[n].clone()
    }

    function ai(t, e, i) {
        oi.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
    }

    function si(t, e, i, n, r, o, a, s, l, h, c, u) {
        ni.call(this, null, o, a, s, l, h, n, r, c, u), this.image = {
            data: t,
            width: e,
            height: i
        }, this.magFilter = void 0 !== l ? l : At, this.minFilter = void 0 !== h ? h : At, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }

    function li(t, e) {
        this.min = void 0 !== t ? t : new Ye(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ye(-1 / 0, -1 / 0, -1 / 0)
    }

    function hi(t, e) {
        this.center = void 0 !== t ? t : new Ye, this.radius = void 0 !== e ? e : 0
    }

    function ci(t, e) {
        this.normal = void 0 !== t ? t : new Ye(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }

    function ui(t, e, i, n, r, o) {
        this.planes = [void 0 !== t ? t : new ci, void 0 !== e ? e : new ci, void 0 !== i ? i : new ci, void 0 !== n ? n : new ci, void 0 !== r ? r : new ci, void 0 !== o ? o : new ci]
    }
    ni.DEFAULT_IMAGE = void 0, ni.DEFAULT_MAPPING = vt, ni.prototype = Object.assign(Object.create(n.prototype), {
        constructor: ni,
        isTexture: !0,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var n = this.image;
                void 0 === n.uuid && (n.uuid = je.generateUUID()), e || void 0 !== t.images[n.uuid] || (t.images[n.uuid] = {
                    uuid: n.uuid,
                    url: function(t) {
                        var e;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width, e.height = t.height;
                            var i = e.getContext("2d");
                            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height)
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }(n)
                }), i.image = n.uuid
            }
            return e || (t.textures[this.uuid] = i), i
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (this.mapping === vt) {
                if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                    case Et:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Mt:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case St:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                    case Et:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Mt:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case St:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
                this.flipY && (t.y = 1 - t.y)
            }
        }
    }), Object.defineProperty(ni.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(ri.prototype, {
        isVector4: !0,
        set: function(t, e, i, n) {
            return this.x = t, this.y = e, this.z = i, this.w = n, this
        },
        setScalar: function(t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        },
        setX: function(t) {
            return this.x = t, this
        },
        setY: function(t) {
            return this.y = t, this
        },
        setZ: function(t) {
            return this.z = t, this
        },
        setW: function(t) {
            return this.w = t, this
        },
        setComponent: function(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        },
        multiplyScalar: function(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        },
        applyMatrix4: function(t) {
            var e = this.x,
                i = this.y,
                n = this.z,
                r = this.w,
                o = t.elements;
            return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r, this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, i, n, r, o = t.elements,
                a = o[0],
                s = o[4],
                l = o[8],
                h = o[1],
                c = o[5],
                u = o[9],
                p = o[2],
                d = o[6],
                f = o[10];
            if (Math.abs(s - h) < .01 && Math.abs(l - p) < .01 && Math.abs(u - d) < .01) {
                if (Math.abs(s + h) < .1 && Math.abs(l + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + c + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                var m = (a + 1) / 2,
                    v = (c + 1) / 2,
                    g = (f + 1) / 2,
                    y = (s + h) / 4,
                    _ = (l + p) / 4,
                    x = (u + d) / 4;
                return m > v && m > g ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (n = y / (i = Math.sqrt(m)), r = _ / i) : v > g ? v < .01 ? (i = .707106781, n = 0, r = .707106781) : (i = y / (n = Math.sqrt(v)), r = x / n) : g < .01 ? (i = .707106781, n = .707106781, r = 0) : (i = _ / (r = Math.sqrt(g)), n = x / r), this.set(i, n, r, e), this
            }
            var b = Math.sqrt((d - u) * (d - u) + (l - p) * (l - p) + (h - s) * (h - s));
            return Math.abs(b) < .001 && (b = 1), this.x = (d - u) / b, this.y = (l - p) / b, this.z = (h - s) / b, this.w = Math.acos((a + c + f - 1) / 2), this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        },
        clampScalar: function() {
            var t, e;
            return function(i, n) {
                return void 0 === t && (t = new ri, e = new ri), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        },
        lerpVectors: function(t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        },
        fromBufferAttribute: function(t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        }
    }), oi.prototype = Object.assign(Object.create(n.prototype), {
        constructor: oi,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), ai.prototype = Object.create(oi.prototype), ai.prototype.constructor = ai, ai.prototype.isWebGLRenderTargetCube = !0, si.prototype = Object.create(ni.prototype), si.prototype.constructor = si, si.prototype.isDataTexture = !0, Object.assign(li.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.length; s < l; s += 3) {
                var h = t[s],
                    c = t[s + 1],
                    u = t[s + 2];
                h < e && (e = h), c < i && (i = c), u < n && (n = u), h > r && (r = h), c > o && (o = c), u > a && (a = u)
            }
            return this.min.set(e, i, n), this.max.set(r, o, a), this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, l = t.count; s < l; s++) {
                var h = t.getX(s),
                    c = t.getY(s),
                    u = t.getZ(s);
                h < e && (e = h), c < i && (i = c), u < n && (n = u), h > r && (r = h), c > o && (o = c), u > a && (a = u)
            }
            return this.min.set(e, i, n), this.max.set(r, o, a), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new Ye;
            return function(e, i) {
                var n = t.copy(i).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
        }(),
        setFromObject: function(t) {
            return this.makeEmpty(), this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Ye), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Ye), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        expandByObject: function() {
            var t, e, i, n = new Ye;

            function r(r) {
                var o = r.geometry;
                if (void 0 !== o)
                    if (o.isGeometry) {
                        var a = o.vertices;
                        for (e = 0, i = a.length; e < i; e++) n.copy(a[e]), n.applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                    } else if (o.isBufferGeometry) {
                    var s = o.attributes.position;
                    if (void 0 !== s)
                        for (e = 0, i = s.count; e < i; e++) n.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                }
            }
            return function(e) {
                return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
            }
        }(),
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Ye), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: (Ke = new Ye, function(t) {
            return this.clampPoint(t.center, Ke), Ke.distanceToSquared(t.center) <= t.radius * t.radius
        }),
        intersectsPlane: function(t) {
            var e, i;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant
        },
        intersectsTriangle: function() {
            var t = new Ye,
                e = new Ye,
                i = new Ye,
                n = new Ye,
                r = new Ye,
                o = new Ye,
                a = new Ye,
                s = new Ye,
                l = new Ye,
                h = new Ye;

            function c(n) {
                var r, o;
                for (r = 0, o = n.length - 3; r <= o; r += 3) {
                    a.fromArray(n, r);
                    var s = l.x * Math.abs(a.x) + l.y * Math.abs(a.y) + l.z * Math.abs(a.z),
                        h = t.dot(a),
                        c = e.dot(a),
                        u = i.dot(a);
                    if (Math.max(-Math.max(h, c, u), Math.min(h, c, u)) > s) return !1
                }
                return !0
            }
            return function(a) {
                if (this.isEmpty()) return !1;
                this.getCenter(s), l.subVectors(this.max, s), t.subVectors(a.a, s), e.subVectors(a.b, s), i.subVectors(a.c, s), n.subVectors(e, t), r.subVectors(i, e), o.subVectors(t, i);
                var u = [0, -n.z, n.y, 0, -r.z, r.y, 0, -o.z, o.y, n.z, 0, -n.x, r.z, 0, -r.x, o.z, 0, -o.x, -n.y, n.x, 0, -r.y, r.x, 0, -o.y, o.x, 0];
                return !!c(u) && !!c(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (h.crossVectors(n, r), c(u = [h.x, h.y, h.z]))
            }
        }(),
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Ye), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new Ye;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new Ye;
            return function(e) {
                return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new hi), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        applyMatrix4: (Je = [new Ye, new Ye, new Ye, new Ye, new Ye, new Ye, new Ye, new Ye], function(t) {
            return this.isEmpty() ? this : (Je[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Je[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Je[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Je[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Je[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Je[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Je[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Je[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Je), this)
        }),
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), Object.assign(hi.prototype, {
        set: function(t, e) {
            return this.center.copy(t), this.radius = e, this
        },
        setFromPoints: (Qe = new li, function(t, e) {
            var i = this.center;
            void 0 !== e ? i.copy(e) : Qe.setFromPoints(t).getCenter(i);
            for (var n = 0, r = 0, o = t.length; r < o; r++) n = Math.max(n, i.distanceToSquared(t[r]));
            return this.radius = Math.sqrt(n), this
        }),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var i = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Ye), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        },
        getBoundingBox: function(t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new li), t.set(this.center, this.center), t.expandByScalar(this.radius), t
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        },
        translate: function(t) {
            return this.center.add(t), this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }), Object.assign(ci.prototype, {
        set: function(t, e) {
            return this.normal.copy(t), this.constant = e, this
        },
        setComponents: function(t, e, i, n) {
            return this.normal.set(t, e, i), this.constant = n, this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        },
        setFromCoplanarPoints: function() {
            var t = new Ye,
                e = new Ye;
            return function(i, n, r) {
                var o = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                return this.setFromNormalAndCoplanarPoint(o, i), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Ye), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function() {
            var t = new Ye;
            return function(e, i) {
                void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new Ye);
                var n = e.delta(t),
                    r = this.normal.dot(n);
                if (0 === r) return 0 === this.distanceToPoint(e.start) ? i.copy(e.start) : void 0;
                var o = -(e.start.dot(this.normal) + this.constant) / r;
                return o < 0 || o > 1 ? void 0 : i.copy(n).multiplyScalar(o).add(e.start)
            }
        }(),
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start),
                i = this.distanceToPoint(t.end);
            return e < 0 && i > 0 || i < 0 && e > 0
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Ye), t.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new Ye,
                e = new Ze;
            return function(i, n) {
                var r = n || e.getNormalMatrix(i),
                    o = this.coplanarPoint(t).applyMatrix4(i),
                    a = this.normal.applyMatrix3(r).normalize();
                return this.constant = -o.dot(a), this
            }
        }(),
        translate: function(t) {
            return this.constant -= t.dot(this.normal), this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }), Object.assign(ui.prototype, {
        set: function(t, e, i, n, r, o) {
            var a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes,
                i = t.elements,
                n = i[0],
                r = i[1],
                o = i[2],
                a = i[3],
                s = i[4],
                l = i[5],
                h = i[6],
                c = i[7],
                u = i[8],
                p = i[9],
                d = i[10],
                f = i[11],
                m = i[12],
                v = i[13],
                g = i[14],
                y = i[15];
            return e[0].setComponents(a - n, c - s, f - u, y - m).normalize(), e[1].setComponents(a + n, c + s, f + u, y + m).normalize(), e[2].setComponents(a + r, c + l, f + p, y + v).normalize(), e[3].setComponents(a - r, c - l, f - p, y - v).normalize(), e[4].setComponents(a - o, c - h, f - d, y - g).normalize(), e[5].setComponents(a + o, c + h, f + d, y + g).normalize(), this
        },
        intersectsObject: (ei = new hi, function(t) {
            var e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(), ei.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ei)
        }),
        intersectsSprite: function() {
            var t = new hi;
            return function(e) {
                return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++)
                if (e[r].distanceToPoint(i) < n) return !1;
            return !0
        },
        intersectsBox: ($e = new Ye, ti = new Ye, function(t) {
            for (var e = this.planes, i = 0; i < 6; i++) {
                var n = e[i];
                $e.x = n.normal.x > 0 ? t.min.x : t.max.x, ti.x = n.normal.x > 0 ? t.max.x : t.min.x, $e.y = n.normal.y > 0 ? t.min.y : t.max.y, ti.y = n.normal.y > 0 ? t.max.y : t.min.y, $e.z = n.normal.z > 0 ? t.min.z : t.max.z, ti.z = n.normal.z > 0 ? t.max.z : t.min.z;
                var r = n.distanceToPoint($e),
                    o = n.distanceToPoint(ti);
                if (r < 0 && o < 0) return !1
            }
            return !0
        }),
        containsPoint: function(t) {
            for (var e = this.planes, i = 0; i < 6; i++)
                if (e[i].distanceToPoint(t) < 0) return !1;
            return !0
        }
    });
    var pi, di = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
            fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
            gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
            lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
            lights_pars_maps: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
            normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
            normal_fragment_maps: "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
            dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
            dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
            normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
            shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
        },
        fi = {
            merge: function(t) {
                for (var e = {}, i = 0; i < t.length; i++) {
                    var n = this.clone(t[i]);
                    for (var r in n) e[r] = n[r]
                }
                return e
            },
            clone: function(t) {
                var e = {};
                for (var i in t)
                    for (var n in e[i] = {}, t[i]) {
                        var r = t[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                    }
                return e
            }
        },
        mi = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };

    function vi(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    }
    Object.assign(vi.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        },
        setScalar: function(t) {
            return this.r = t, this.g = t, this.b = t, this
        },
        setHex: function(t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        },
        setRGB: function(t, e, i) {
            return this.r = t, this.g = e, this.b = i, this
        },
        setHSL: function() {
            function t(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }
            return function(e, i, n) {
                if (e = je.euclideanModulo(e, 1), i = je.clamp(i, 0, 1), n = je.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n;
                else {
                    var r = n <= .5 ? n * (1 + i) : n + i - n * i,
                        o = 2 * n - r;
                    this.r = t(o, r, e + 1 / 3), this.g = t(o, r, e), this.b = t(o, r, e - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var n, r = i[1],
                    o = i[2];
                switch (r) {
                    case "rgb":
                    case "rgba":
                        if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                        if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                            var a = parseFloat(n[1]) / 360,
                                s = parseInt(n[2], 10) / 100,
                                l = parseInt(n[3], 10) / 100;
                            return e(n[5]), this.setHSL(a, s, l)
                        }
                }
            } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var h, c = (h = i[1]).length;
                if (3 === c) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                if (6 === c) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
            }
            return t && t.length > 0 && (void 0 !== (h = mi[t]) ? this.setHex(h) : console.warn("THREE.Color: Unknown color " + t)), this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            var i = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
        },
        convertGammaToLinear: function() {
            var t = this.r,
                e = this.g,
                i = this.b;
            return this.r = t * t, this.g = e * e, this.b = i * i, this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                h: 0,
                s: 0,
                l: 0
            });
            var e, i, n = this.r,
                r = this.g,
                o = this.b,
                a = Math.max(n, r, o),
                s = Math.min(n, r, o),
                l = (s + a) / 2;
            if (s === a) e = 0, i = 0;
            else {
                var h = a - s;
                switch (i = l <= .5 ? h / (a + s) : h / (2 - a - s), a) {
                    case n:
                        e = (r - o) / h + (r < o ? 6 : 0);
                        break;
                    case r:
                        e = (o - n) / h + 2;
                        break;
                    case o:
                        e = (n - r) / h + 4
                }
                e /= 6
            }
            return t.h = e, t.s = i, t.l = l, t
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: (pi = {}, function(t, e, i) {
            return this.getHSL(pi), pi.h += t, pi.s += e, pi.l += i, this.setHSL(pi.h, pi.s, pi.l), this
        }),
        add: function(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        },
        addScalar: function(t) {
            return this.r += t, this.g += t, this.b += t, this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        },
        multiply: function(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        },
        multiplyScalar: function(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var gi, yi = {
            common: {
                diffuse: {
                    value: new vi(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Ze
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new We(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new vi(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new vi(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Ze
                }
            }
        },
        _i = {
            basic: {
                uniforms: fi.merge([yi.common, yi.specularmap, yi.envmap, yi.aomap, yi.lightmap, yi.fog]),
                vertexShader: di.meshbasic_vert,
                fragmentShader: di.meshbasic_frag
            },
            lambert: {
                uniforms: fi.merge([yi.common, yi.specularmap, yi.envmap, yi.aomap, yi.lightmap, yi.emissivemap, yi.fog, yi.lights, {
                    emissive: {
                        value: new vi(0)
                    }
                }]),
                vertexShader: di.meshlambert_vert,
                fragmentShader: di.meshlambert_frag
            },
            phong: {
                uniforms: fi.merge([yi.common, yi.specularmap, yi.envmap, yi.aomap, yi.lightmap, yi.emissivemap, yi.bumpmap, yi.normalmap, yi.displacementmap, yi.gradientmap, yi.fog, yi.lights, {
                    emissive: {
                        value: new vi(0)
                    },
                    specular: {
                        value: new vi(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: di.meshphong_vert,
                fragmentShader: di.meshphong_frag
            },
            standard: {
                uniforms: fi.merge([yi.common, yi.envmap, yi.aomap, yi.lightmap, yi.emissivemap, yi.bumpmap, yi.normalmap, yi.displacementmap, yi.roughnessmap, yi.metalnessmap, yi.fog, yi.lights, {
                    emissive: {
                        value: new vi(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: di.meshphysical_vert,
                fragmentShader: di.meshphysical_frag
            },
            points: {
                uniforms: fi.merge([yi.points, yi.fog]),
                vertexShader: di.points_vert,
                fragmentShader: di.points_frag
            },
            dashed: {
                uniforms: fi.merge([yi.common, yi.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: di.linedashed_vert,
                fragmentShader: di.linedashed_frag
            },
            depth: {
                uniforms: fi.merge([yi.common, yi.displacementmap]),
                vertexShader: di.depth_vert,
                fragmentShader: di.depth_frag
            },
            normal: {
                uniforms: fi.merge([yi.common, yi.bumpmap, yi.normalmap, yi.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: di.normal_vert,
                fragmentShader: di.normal_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: di.cube_vert,
                fragmentShader: di.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: di.equirect_vert,
                fragmentShader: di.equirect_frag
            },
            distanceRGBA: {
                uniforms: fi.merge([yi.common, yi.displacementmap, {
                    referencePosition: {
                        value: new Ye
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: di.distanceRGBA_vert,
                fragmentShader: di.distanceRGBA_frag
            },
            shadow: {
                uniforms: fi.merge([yi.lights, yi.fog, {
                    color: {
                        value: new vi(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: di.shadow_vert,
                fragmentShader: di.shadow_frag
            }
        };

    function xi(t, e, i, n) {
        this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || xi.DefaultOrder
    }

    function bi() {
        this.mask = 1
    }
    _i.physical = {
        uniforms: fi.merge([_i.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: di.meshphysical_vert,
        fragmentShader: di.meshphysical_frag
    }, xi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], xi.DefaultOrder = "XYZ", Object.defineProperties(xi.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t, this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t, this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t, this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t, this.onChangeCallback()
            }
        }
    }), Object.assign(xi.prototype, {
        isEuler: !0,
        set: function(t, e, i, n) {
            return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        },
        copy: function(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
        },
        setFromRotationMatrix: function(t, e, i) {
            var n = je.clamp,
                r = t.elements,
                o = r[0],
                a = r[4],
                s = r[8],
                l = r[1],
                h = r[5],
                c = r[9],
                u = r[2],
                p = r[6],
                d = r[10];
            return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, h), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, h)) : (this._y = 0, this._z = Math.atan2(l, o))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-a, h))) : "YZX" === e ? (this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-c, h), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-c, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
        },
        setFromQuaternion: function() {
            var t = new qe;
            return function(e, i, n) {
                return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
            }
        }(),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: (gi = new Xe, function(t) {
            return gi.setFromEuler(this), this.setFromQuaternion(gi, t)
        }),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new Ye(this._x, this._y, this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t, this
        },
        onChangeCallback: function() {}
    }), Object.assign(bi.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var wi, Ti, Ei, Mi, Si = 0;

    function Ai() {
        Object.defineProperty(this, "id", {
            value: Si++
        }), this.uuid = je.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ai.DefaultUp.clone();
        var t = new Ye,
            e = new xi,
            i = new Xe,
            n = new Ye(1, 1, 1);
        e.onChange(function() {
            i.setFromEuler(e, !1)
        }), i.onChange(function() {
            e.setFromQuaternion(i, void 0, !1)
        }), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: t
            },
            rotation: {
                enumerable: !0,
                value: e
            },
            quaternion: {
                enumerable: !0,
                value: i
            },
            scale: {
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new qe
            },
            normalMatrix: {
                value: new Ze
            }
        }), this.matrix = new qe, this.matrixWorld = new qe, this.matrixAutoUpdate = Ai.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new bi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function Ci() {
        Ai.call(this), this.type = "Camera", this.matrixWorldInverse = new qe, this.projectionMatrix = new qe
    }

    function Ri(t, e, i, n, r, o) {
        Ci.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
    }

    function Pi(t, e, i, n, r, o) {
        this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new Ye, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new vi, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
    }
    Ai.DefaultUp = new Ye(0, 1, 0), Ai.DefaultMatrixAutoUpdate = !0, Ai.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Ai,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t), this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: (Mi = new Xe, function(t, e) {
            return Mi.setFromAxisAngle(t, e), this.quaternion.multiply(Mi), this
        }),
        rotateOnWorldAxis: function() {
            var t = new Xe;
            return function(e, i) {
                return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
            }
        }(),
        rotateX: function() {
            var t = new Ye(1, 0, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new Ye(0, 1, 0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new Ye(0, 0, 1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new Ye;
            return function(e, i) {
                return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
            }
        }(),
        translateX: function() {
            var t = new Ye(1, 0, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new Ye(0, 1, 0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new Ye(0, 0, 1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: (Ei = new qe, function(t) {
            return t.applyMatrix4(Ei.getInverse(this.matrixWorld))
        }),
        lookAt: function() {
            var t = new qe,
                e = new Ye;
            return function(i, n, r) {
                i.isVector3 ? e.copy(i) : e.set(i, n, r), this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        add: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                type: "added"
            }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            var i = this.children.indexOf(t);
            return -1 !== i && (t.parent = null, t.dispatchEvent({
                type: "removed"
            }), this.children.splice(i, 1)), this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(t, e);
                if (void 0 !== r) return r
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Ye), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: (wi = new Ye, Ti = new Ye, function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Xe), this.updateMatrixWorld(!0), this.matrixWorld.decompose(wi, t, Ti), t
        }),
        getWorldScale: function() {
            var t = new Ye,
                e = new Xe;
            return function(i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new Ye), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
            }
        }(),
        getWorldDirection: function() {
            var t = new Xe;
            return function(e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Ye), this.getWorldQuaternion(t), e.set(0, 0, 1).applyQuaternion(t)
            }
        }(),
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t,
                i = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            }, i.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var n = {};

            function r(e, i) {
                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.matrix = this.matrix.toArray(), void 0 !== this.geometry) {
                n.geometry = r(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, l = a.length; s < l; s++) {
                            var h = a[s];
                            r(t.shapes, h)
                        } else r(t.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var c = [];
                    for (s = 0, l = this.material.length; s < l; s++) c.push(r(t.materials, this.material[s]));
                    n.material = c
                } else n.material = r(t.materials, this.material);
            if (this.children.length > 0)
                for (n.children = [], s = 0; s < this.children.length; s++) n.children.push(this.children[s].toJSON(t).object);
            if (e) {
                var u = m(t.geometries),
                    p = m(t.materials),
                    d = m(t.textures),
                    f = m(t.images);
                a = m(t.shapes), u.length > 0 && (i.geometries = u), p.length > 0 && (i.materials = p), d.length > 0 && (i.textures = d), f.length > 0 && (i.images = f), a.length > 0 && (i.shapes = a)
            }
            return i.object = n, i;

            function m(t) {
                var e = [];
                for (var i in t) {
                    var n = t[i];
                    delete n.metadata, e.push(n)
                }
                return e
            }
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (var i = 0; i < t.children.length; i++) {
                    var n = t.children[i];
                    this.add(n.clone())
                }
            return this
        }
    }), Ci.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Ci,
        isCamera: !0,
        copy: function(t, e) {
            return Ai.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
        },
        getWorldDirection: function() {
            var t = new Xe;
            return function(e) {
                return void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Ye), this.getWorldQuaternion(t), e.set(0, 0, -1).applyQuaternion(t)
            }
        }(),
        updateMatrixWorld: function(t) {
            Ai.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Ri.prototype = Object.assign(Object.create(Ci.prototype), {
        constructor: Ri,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return Ci.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        },
        setViewOffset: function(t, e, i, n, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2,
                n = (this.top + this.bottom) / 2,
                r = i - t,
                o = i + t,
                a = n + e,
                s = n - e;
            if (null !== this.view && this.view.enabled) {
                var l = this.zoom / (this.view.width / this.view.fullWidth),
                    h = this.zoom / (this.view.height / this.view.fullHeight),
                    c = (this.right - this.left) / this.view.width,
                    u = (this.top - this.bottom) / this.view.height;
                o = (r += c * (this.view.offsetX / l)) + c * (this.view.width / l), s = (a -= u * (this.view.offsetY / h)) - u * (this.view.height / h)
            }
            this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far)
        },
        toJSON: function(t) {
            var e = Ai.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }), Object.assign(Pi.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var Li, Oi, Bi = 0;

    function Ii() {
        Object.defineProperty(this, "id", {
            value: Bi += 2
        }), this.uuid = je.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
            []
        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Ni(t, e, i) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function zi(t, e, i) {
        Ni.call(this, new Int8Array(t), e, i)
    }

    function Fi(t, e, i) {
        Ni.call(this, new Uint8Array(t), e, i)
    }

    function Di(t, e, i) {
        Ni.call(this, new Uint8ClampedArray(t), e, i)
    }

    function Ui(t, e, i) {
        Ni.call(this, new Int16Array(t), e, i)
    }

    function ki(t, e, i) {
        Ni.call(this, new Uint16Array(t), e, i)
    }

    function Vi(t, e, i) {
        Ni.call(this, new Int32Array(t), e, i)
    }

    function Hi(t, e, i) {
        Ni.call(this, new Uint32Array(t), e, i)
    }

    function Gi(t, e, i) {
        Ni.call(this, new Float32Array(t), e, i)
    }

    function ji(t, e, i) {
        Ni.call(this, new Float64Array(t), e, i)
    }

    function Wi() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function qi(t) {
        if (0 === t.length) return -1 / 0;
        for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
        return e
    }
    Ii.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Ii,
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new Ze).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(t);
            for (i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i];
                r.normal.applyMatrix3(e).normalize();
                for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        },
        rotateX: function() {
            var t = new qe;
            return function(e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t = new qe;
            return function(e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t = new qe;
            return function(e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t = new qe;
            return function(e, i, n) {
                return t.makeTranslation(e, i, n), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t = new qe;
            return function(e, i, n) {
                return t.makeScale(e, i, n), this.applyMatrix(t), this
            }
        }(),
        lookAt: (Oi = new Ai, function(t) {
            Oi.lookAt(t), Oi.updateMatrix(), this.applyMatrix(Oi.matrix)
        }),
        fromBufferGeometry: function(t) {
            var e = this,
                i = null !== t.index ? t.index.array : void 0,
                n = t.attributes,
                r = n.position.array,
                o = void 0 !== n.normal ? n.normal.array : void 0,
                a = void 0 !== n.color ? n.color.array : void 0,
                s = void 0 !== n.uv ? n.uv.array : void 0,
                l = void 0 !== n.uv2 ? n.uv2.array : void 0;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (var h = [], c = [], u = [], p = 0, d = 0; p < r.length; p += 3, d += 2) e.vertices.push(new Ye(r[p], r[p + 1], r[p + 2])), void 0 !== o && h.push(new Ye(o[p], o[p + 1], o[p + 2])), void 0 !== a && e.colors.push(new vi(a[p], a[p + 1], a[p + 2])), void 0 !== s && c.push(new We(s[d], s[d + 1])), void 0 !== l && u.push(new We(l[d], l[d + 1]));

            function f(t, i, n, r) {
                var p = new Pi(t, i, n, void 0 !== o ? [h[t].clone(), h[i].clone(), h[n].clone()] : [], void 0 !== a ? [e.colors[t].clone(), e.colors[i].clone(), e.colors[n].clone()] : [], r);
                e.faces.push(p), void 0 !== s && e.faceVertexUvs[0].push([c[t].clone(), c[i].clone(), c[n].clone()]), void 0 !== l && e.faceVertexUvs[1].push([u[t].clone(), u[i].clone(), u[n].clone()])
            }
            var m = t.groups;
            if (m.length > 0)
                for (p = 0; p < m.length; p++)
                    for (var v = m[p], g = v.start, y = (d = g, g + v.count); d < y; d += 3) void 0 !== i ? f(i[d], i[d + 1], i[d + 2], v.materialIndex) : f(d, d + 1, d + 2, v.materialIndex);
            else if (void 0 !== i)
                for (p = 0; p < i.length; p += 3) f(i[p], i[p + 1], i[p + 2]);
            else
                for (p = 0; p < r.length / 3; p += 3) f(p, p + 1, p + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        },
        center: (Li = new Ye, function() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Li).negate(), this.translate(Li.x, Li.y, Li.z), this
        }),
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                i = 0 === e ? 1 : 1 / e,
                n = new qe;
            return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
        },
        computeFaceNormals: function() {
            for (var t = new Ye, e = new Ye, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i],
                    o = this.vertices[r.a],
                    a = this.vertices[r.b],
                    s = this.vertices[r.c];
                t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e, i, n, r, o, a;
            for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) a[e] = new Ye;
            if (t) {
                var s, l, h, c = new Ye,
                    u = new Ye;
                for (n = 0, r = this.faces.length; n < r; n++) o = this.faces[n], s = this.vertices[o.a], l = this.vertices[o.b], h = this.vertices[o.c], c.subVectors(h, l), u.subVectors(s, l), c.cross(u), a[o.a].add(c), a[o.b].add(c), a[o.c].add(c)
            } else
                for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) a[(o = this.faces[n]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
            for (e = 0, i = this.vertices.length; e < i; e++) a[e].normalize();
            for (n = 0, r = this.faces.length; n < r; n++) {
                var p = (o = this.faces[n]).vertexNormals;
                3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var t, e, i;
            for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                var n = (i = this.faces[t]).vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t, e, i, n, r;
            for (i = 0, n = this.faces.length; i < n; i++)
                for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
            var o = new Ii;
            for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                    var a = this.morphNormals[t].faceNormals,
                        s = this.morphNormals[t].vertexNormals;
                    for (i = 0, n = this.faces.length; i < n; i++) l = new Ye, h = {
                        a: new Ye,
                        b: new Ye,
                        c: new Ye
                    }, a.push(l), s.push(h)
                }
                var l, h, c = this.morphNormals[t];
                for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], l = c.faceNormals[i], h = c.vertexNormals[i], l.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2])
            }
            for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new li), this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new hi), this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, i) {
            if (t && t.isGeometry) {
                var n, r = this.vertices.length,
                    o = this.vertices,
                    a = t.vertices,
                    s = this.faces,
                    l = t.faces,
                    h = this.faceVertexUvs[0],
                    c = t.faceVertexUvs[0],
                    u = this.colors,
                    p = t.colors;
                void 0 === i && (i = 0), void 0 !== e && (n = (new Ze).getNormalMatrix(e));
                for (var d = 0, f = a.length; d < f; d++) {
                    var m = a[d].clone();
                    void 0 !== e && m.applyMatrix4(e), o.push(m)
                }
                for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
                for (d = 0, f = l.length; d < f; d++) {
                    var v, g, y, _ = l[d],
                        x = _.vertexNormals,
                        b = _.vertexColors;
                    (v = new Pi(_.a + r, _.b + r, _.c + r)).normal.copy(_.normal), void 0 !== n && v.normal.applyMatrix3(n).normalize();
                    for (var w = 0, T = x.length; w < T; w++) g = x[w].clone(), void 0 !== n && g.applyMatrix3(n).normalize(), v.vertexNormals.push(g);
                    for (v.color.copy(_.color), w = 0, T = b.length; w < T; w++) y = b[w], v.vertexColors.push(y.clone());
                    v.materialIndex = _.materialIndex + i, s.push(v)
                }
                for (d = 0, f = c.length; d < f; d++) {
                    var E = c[d],
                        M = [];
                    if (void 0 !== E) {
                        for (w = 0, T = E.length; w < T; w++) M.push(E[w].clone());
                        h.push(M)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function(t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function() {
            var t, e, i, n, r, o, a, s, l = {},
                h = [],
                c = [],
                u = Math.pow(10, 4);
            for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], void 0 === l[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (l[e] = i, h.push(this.vertices[i]), c[i] = h.length - 1) : c[i] = c[l[e]];
            var p = [];
            for (i = 0, n = this.faces.length; i < n; i++) {
                (r = this.faces[i]).a = c[r.a], r.b = c[r.b], r.c = c[r.c], o = [r.a, r.b, r.c];
                for (var d = 0; d < 3; d++)
                    if (o[d] === o[(d + 1) % 3]) {
                        p.push(i);
                        break
                    }
            }
            for (i = p.length - 1; i >= 0; i--) {
                var f = p[i];
                for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - h.length;
            return this.vertices = h, m
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, i = t.length; e < i; e++) {
                var n = t[e];
                this.vertices.push(new Ye(n.x, n.y, n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
            t.sort(function(t, e) {
                return t.materialIndex - e.materialIndex
            });
            var n, r, o = this.faceVertexUvs[0],
                a = this.faceVertexUvs[1];
            for (o && o.length === e && (n = []), a && a.length === e && (r = []), i = 0; i < e; i++) {
                var s = t[i]._id;
                n && n.push(o[s]), r && r.push(a[s])
            }
            n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                return t
            }
            for (var n = [], r = 0; r < this.vertices.length; r++) {
                var o = this.vertices[r];
                n.push(o.x, o.y, o.z)
            }
            var a = [],
                s = [],
                l = {},
                h = [],
                c = {},
                u = [],
                p = {};
            for (r = 0; r < this.faces.length; r++) {
                var d = this.faces[r],
                    f = void 0 !== this.faceVertexUvs[0][r],
                    m = d.normal.length() > 0,
                    v = d.vertexNormals.length > 0,
                    g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                    y = d.vertexColors.length > 0,
                    _ = 0;
                if (_ = T(_ = T(_ = T(_ = T(_ = T(_ = T(_ = T(_ = T(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y), a.push(_), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) {
                    var x = this.faceVertexUvs[0][r];
                    a.push(S(x[0]), S(x[1]), S(x[2]))
                }
                if (m && a.push(E(d.normal)), v) {
                    var b = d.vertexNormals;
                    a.push(E(b[0]), E(b[1]), E(b[2]))
                }
                if (g && a.push(M(d.color)), y) {
                    var w = d.vertexColors;
                    a.push(M(w[0]), M(w[1]), M(w[2]))
                }
            }

            function T(t, e, i) {
                return i ? t | 1 << e : t & ~(1 << e)
            }

            function E(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== l[e] ? l[e] : (l[e] = s.length / 3, s.push(t.x, t.y, t.z), l[e])
            }

            function M(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== c[e] ? c[e] : (c[e] = h.length, h.push(t.getHex()), c[e])
            }

            function S(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2, u.push(t.x, t.y), p[e])
            }
            return t.data = {}, t.data.vertices = n, t.data.normals = s, h.length > 0 && (t.data.colors = h), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
        },
        clone: function() {
            return (new Ii).copy(this)
        },
        copy: function(t) {
            var e, i, n, r, o, a;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var s = t.vertices;
            for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
            var l = t.colors;
            for (e = 0, i = l.length; e < i; e++) this.colors.push(l[e].clone());
            var h = t.faces;
            for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
            for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                var c = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = c.length; n < r; n++) {
                    var u = c[n],
                        p = [];
                    for (o = 0, a = u.length; o < a; o++) {
                        var d = u[o];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[e].push(p)
                }
            }
            var f = t.morphTargets;
            for (e = 0, i = f.length; e < i; e++) {
                var m = {};
                if (m.name = f[e].name, void 0 !== f[e].vertices)
                    for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
                if (void 0 !== f[e].normals)
                    for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
                this.morphTargets.push(m)
            }
            var v = t.morphNormals;
            for (e = 0, i = v.length; e < i; e++) {
                var g = {};
                if (void 0 !== v[e].vertexNormals)
                    for (g.vertexNormals = [], n = 0, r = v[e].vertexNormals.length; n < r; n++) {
                        var y = v[e].vertexNormals[n],
                            _ = {};
                        _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), g.vertexNormals.push(_)
                    }
                if (void 0 !== v[e].faceNormals)
                    for (g.faceNormals = [], n = 0, r = v[e].faceNormals.length; n < r; n++) g.faceNormals.push(v[e].faceNormals[n].clone());
                this.morphNormals.push(g)
            }
            var x = t.skinWeights;
            for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
            var b = t.skinIndices;
            for (e = 0, i = b.length; e < i; e++) this.skinIndices.push(b[e].clone());
            var w = t.lineDistances;
            for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
            var T = t.boundingBox;
            null !== T && (this.boundingBox = T.clone());
            var E = t.boundingSphere;
            return null !== E && (this.boundingSphere = E.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Object.defineProperty(Ni.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(Ni.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
        },
        copyAt: function(t, e, i) {
            t *= this.itemSize, i *= e.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t), this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new vi), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), o = new We), e[i++] = o.x, e[i++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new Ye), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new ri), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e, this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        },
        setXY: function(t, e, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
        },
        setXYZ: function(t, e, i, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
        },
        setXYZW: function(t, e, i, n, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), zi.prototype = Object.create(Ni.prototype), zi.prototype.constructor = zi, Fi.prototype = Object.create(Ni.prototype), Fi.prototype.constructor = Fi, Di.prototype = Object.create(Ni.prototype), Di.prototype.constructor = Di, Ui.prototype = Object.create(Ni.prototype), Ui.prototype.constructor = Ui, ki.prototype = Object.create(Ni.prototype), ki.prototype.constructor = ki, Vi.prototype = Object.create(Ni.prototype), Vi.prototype.constructor = Vi, Hi.prototype = Object.create(Ni.prototype), Hi.prototype.constructor = Hi, Gi.prototype = Object.create(Ni.prototype), Gi.prototype.constructor = Gi, ji.prototype = Object.create(Ni.prototype), ji.prototype.constructor = ji, Object.assign(Wi.prototype, {
        computeGroups: function(t) {
            for (var e, i = [], n = void 0, r = t.faces, o = 0; o < r.length; o++) {
                var a = r[o];
                a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), e = {
                    start: 3 * o,
                    materialIndex: n
                })
            }
            void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), this.groups = i
        },
        fromGeometry: function(t) {
            var e, i = t.faces,
                n = t.vertices,
                r = t.faceVertexUvs,
                o = r[0] && r[0].length > 0,
                a = r[1] && r[1].length > 0,
                s = t.morphTargets,
                l = s.length;
            if (l > 0) {
                e = [];
                for (var h = 0; h < l; h++) e[h] = [];
                this.morphTargets.position = e
            }
            var c, u = t.morphNormals,
                p = u.length;
            if (p > 0) {
                for (c = [], h = 0; h < p; h++) c[h] = [];
                this.morphTargets.normal = c
            }
            var d = t.skinIndices,
                f = t.skinWeights,
                m = d.length === n.length,
                v = f.length === n.length;
            for (h = 0; h < i.length; h++) {
                var g = i[h];
                this.vertices.push(n[g.a], n[g.b], n[g.c]);
                var y = g.vertexNormals;
                if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                else {
                    var _ = g.normal;
                    this.normals.push(_, _, _)
                }
                var x, b = g.vertexColors;
                if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                else {
                    var w = g.color;
                    this.colors.push(w, w, w)
                }!0 === o && (void 0 !== (x = r[0][h]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new We, new We, new We))), !0 === a && (void 0 !== (x = r[1][h]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new We, new We, new We)));
                for (var T = 0; T < l; T++) {
                    var E = s[T].vertices;
                    e[T].push(E[g.a], E[g.b], E[g.c])
                }
                for (T = 0; T < p; T++) {
                    var M = u[T].vertexNormals[h];
                    c[T].push(M.a, M.b, M.c)
                }
                m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        }
    });
    var Xi = 1;

    function Yi() {
        Object.defineProperty(this, "id", {
            value: Xi += 2
        }), this.uuid = je.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }

    function Zi(t, e, i, n, r, o) {
        Ii.call(this), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        }, this.fromBufferGeometry(new Ji(t, e, i, n, r, o)), this.mergeVertices()
    }

    function Ji(t, e, i, n, r, o) {
        Yi.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        };
        var a = this;
        t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1;
        var s = [],
            l = [],
            h = [],
            c = [],
            u = 0,
            p = 0;

        function d(t, e, i, n, r, o, d, f, m, v, g) {
            var y, _, x = o / m,
                b = d / v,
                w = o / 2,
                T = d / 2,
                E = f / 2,
                M = m + 1,
                S = v + 1,
                A = 0,
                C = 0,
                R = new Ye;
            for (_ = 0; _ < S; _++) {
                var P = _ * b - T;
                for (y = 0; y < M; y++) {
                    var L = y * x - w;
                    R[t] = L * n, R[e] = P * r, R[i] = E, l.push(R.x, R.y, R.z), R[t] = 0, R[e] = 0, R[i] = f > 0 ? 1 : -1, h.push(R.x, R.y, R.z), c.push(y / m), c.push(1 - _ / v), A += 1
                }
            }
            for (_ = 0; _ < v; _++)
                for (y = 0; y < m; y++) {
                    var O = u + y + M * _,
                        B = u + y + M * (_ + 1),
                        I = u + (y + 1) + M * (_ + 1),
                        N = u + (y + 1) + M * _;
                    s.push(O, B, N), s.push(B, I, N), C += 6
                }
            a.addGroup(p, C, g), p += C, u += A
        }
        d("z", "y", "x", -1, -1, i, e, t, o = Math.floor(o) || 1, r, 0), d("z", "y", "x", 1, -1, i, e, -t, o, r, 1), d("x", "z", "y", 1, 1, t, i, e, n, o, 2), d("x", "z", "y", 1, -1, t, i, -e, n, o, 3), d("x", "y", "z", 1, -1, t, e, i, n, r, 4), d("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(s), this.addAttribute("position", new Gi(l, 3)), this.addAttribute("normal", new Gi(h, 3)), this.addAttribute("uv", new Gi(c, 2))
    }

    function Ki(t, e, i, n) {
        Ii.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new Qi(t, e, i, n)), this.mergeVertices()
    }

    function Qi(t, e, i, n) {
        Yi.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        };
        var r, o, a = (t = t || 1) / 2,
            s = (e = e || 1) / 2,
            l = Math.floor(i) || 1,
            h = Math.floor(n) || 1,
            c = l + 1,
            u = h + 1,
            p = t / l,
            d = e / h,
            f = [],
            m = [],
            v = [],
            g = [];
        for (o = 0; o < u; o++) {
            var y = o * d - s;
            for (r = 0; r < c; r++) {
                var _ = r * p - a;
                m.push(_, -y, 0), v.push(0, 0, 1), g.push(r / l), g.push(1 - o / h)
            }
        }
        for (o = 0; o < h; o++)
            for (r = 0; r < l; r++) {
                var x = r + c * o,
                    b = r + c * (o + 1),
                    w = r + 1 + c * (o + 1),
                    T = r + 1 + c * o;
                f.push(x, b, T), f.push(b, w, T)
            }
        this.setIndex(f), this.addAttribute("position", new Gi(m, 3)), this.addAttribute("normal", new Gi(v, 3)), this.addAttribute("uv", new Gi(g, 2))
    }
    Yi.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Yi,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new(qi(t) > 65535 ? Hi : ki)(t, 1) : this.index = t
        },
        addAttribute: function(t, e) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new Ni(arguments[1], arguments[2])))
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            return delete this.attributes[t], this
        },
        addGroup: function(t, e, i) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
            var i = this.attributes.normal;
            return void 0 !== i && ((new Ze).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        },
        rotateX: function() {
            var t = new qe;
            return function(e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(),
        rotateY: function() {
            var t = new qe;
            return function(e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(),
        rotateZ: function() {
            var t = new qe;
            return function(e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(),
        translate: function() {
            var t = new qe;
            return function(e, i, n) {
                return t.makeTranslation(e, i, n), this.applyMatrix(t), this
            }
        }(),
        scale: function() {
            var t = new qe;
            return function(e, i, n) {
                return t.makeScale(e, i, n), this.applyMatrix(t), this
            }
        }(),
        lookAt: function() {
            var t = new Ai;
            return function(e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(),
        center: function() {
            var t = new Ye;
            return function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
            }
        }(),
        setFromObject: function(t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var i = new Gi(3 * e.vertices.length, 3),
                    n = new Gi(3 * e.colors.length, 3);
                if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var r = new Gi(e.lineDistances.length, 1);
                    this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            for (var e = [], i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new Gi(e, 3)), this
        },
        updateFromObject: function(t) {
            var e, i = t.geometry;
            if (t.isMesh) {
                var n = i.__directGeometry;
                if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i);
                n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n
            }
            return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(i.colors), e.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(i.lineDistances), e.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new Wi).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.addAttribute("position", new Ni(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                var i = new Float32Array(3 * t.normals.length);
                this.addAttribute("normal", new Ni(i, 3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var n = new Float32Array(3 * t.colors.length);
                this.addAttribute("color", new Ni(n, 3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var r = new Float32Array(2 * t.uvs.length);
                this.addAttribute("uv", new Ni(r, 2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var o = new Float32Array(2 * t.uvs2.length);
                this.addAttribute("uv2", new Ni(o, 2).copyVector2sArray(t.uvs2))
            }
            for (var a in this.groups = t.groups, t.morphTargets) {
                for (var s = [], l = t.morphTargets[a], h = 0, c = l.length; h < c; h++) {
                    var u = l[h],
                        p = new Gi(3 * u.length, 3);
                    s.push(p.copyVector3sArray(u))
                }
                this.morphAttributes[a] = s
            }
            if (t.skinIndices.length > 0) {
                var d = new Gi(4 * t.skinIndices.length, 4);
                this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var f = new Gi(4 * t.skinWeights.length, 4);
                this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new li);
            var t = this.attributes.position;
            void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var t = new li,
                e = new Ye;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new hi);
                var i = this.attributes.position;
                if (i) {
                    var n = this.boundingSphere.center;
                    t.setFromBufferAttribute(i), t.getCenter(n);
                    for (var r = 0, o = 0, a = i.count; o < a; o++) e.x = i.getX(o), e.y = i.getY(o), e.z = i.getZ(o), r = Math.max(r, n.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index,
                e = this.attributes,
                i = this.groups;
            if (e.position) {
                var n = e.position.array;
                if (void 0 === e.normal) this.addAttribute("normal", new Ni(new Float32Array(n.length), 3));
                else
                    for (var r = e.normal.array, o = 0, a = r.length; o < a; o++) r[o] = 0;
                var s, l, h, c = e.normal.array,
                    u = new Ye,
                    p = new Ye,
                    d = new Ye,
                    f = new Ye,
                    m = new Ye;
                if (t) {
                    var v = t.array;
                    0 === i.length && this.addGroup(0, v.length);
                    for (var g = 0, y = i.length; g < y; ++g) {
                        var _ = i[g],
                            x = _.start;
                        for (o = x, a = x + _.count; o < a; o += 3) s = 3 * v[o + 0], l = 3 * v[o + 1], h = 3 * v[o + 2], u.fromArray(n, s), p.fromArray(n, l), d.fromArray(n, h), f.subVectors(d, p), m.subVectors(u, p), f.cross(m), c[s] += f.x, c[s + 1] += f.y, c[s + 2] += f.z, c[l] += f.x, c[l + 1] += f.y, c[l + 2] += f.z, c[h] += f.x, c[h + 1] += f.y, c[h + 2] += f.z
                    }
                } else
                    for (o = 0, a = n.length; o < a; o += 9) u.fromArray(n, o), p.fromArray(n, o + 3), d.fromArray(n, o + 6), f.subVectors(d, p), m.subVectors(u, p), f.cross(m), c[o] = f.x, c[o + 1] = f.y, c[o + 2] = f.z, c[o + 3] = f.x, c[o + 4] = f.y, c[o + 5] = f.z, c[o + 6] = f.x, c[o + 7] = f.y, c[o + 8] = f.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i = this.attributes;
                for (var n in i)
                    if (void 0 !== t.attributes[n])
                        for (var r = i[n].array, o = t.attributes[n], a = o.array, s = 0, l = o.itemSize * e; s < a.length; s++, l++) r[l] = a[s];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function() {
            var t = new Ye;
            return function() {
                for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
            }
        }(),
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var t = new Yi,
                e = this.index.array,
                i = this.attributes;
            for (var n in i) {
                for (var r = i[n], o = r.array, a = r.itemSize, s = new o.constructor(e.length * a), l = 0, h = 0, c = 0, u = e.length; c < u; c++) {
                    l = e[c] * a;
                    for (var p = 0; p < a; p++) s[h++] = o[l++]
                }
                t.addAttribute(n, new Ni(s, a))
            }
            var d = this.groups;
            for (c = 0, u = d.length; c < u; c++) {
                var f = d[c];
                t.addGroup(f.start, f.count, f.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                var e = this.parameters;
                for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var n = this.index;
            if (null !== n) {
                var r = Array.prototype.slice.call(n.array);
                t.data.index = {
                    type: n.array.constructor.name,
                    array: r
                }
            }
            var o = this.attributes;
            for (var i in o) {
                var a = o[i];
                r = Array.prototype.slice.call(a.array), t.data.attributes[i] = {
                    itemSize: a.itemSize,
                    type: a.array.constructor.name,
                    array: r,
                    normalized: a.normalized
                }
            }
            var s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            var l = this.boundingSphere;
            return null !== l && (t.data.boundingSphere = {
                center: l.center.toArray(),
                radius: l.radius
            }), t
        },
        clone: function() {
            return (new Yi).copy(this)
        },
        copy: function(t) {
            var e, i, n;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
            var r = t.index;
            null !== r && this.setIndex(r.clone());
            var o = t.attributes;
            for (e in o) {
                var a = o[e];
                this.addAttribute(e, a.clone())
            }
            var s = t.morphAttributes;
            for (e in s) {
                var l = [],
                    h = s[e];
                for (i = 0, n = h.length; i < n; i++) l.push(h[i].clone());
                this.morphAttributes[e] = l
            }
            var c = t.groups;
            for (i = 0, n = c.length; i < n; i++) {
                var u = c[i];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var p = t.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = t.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), Zi.prototype = Object.create(Ii.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(Yi.prototype), Ji.prototype.constructor = Ji, Ki.prototype = Object.create(Ii.prototype), Ki.prototype.constructor = Ki, Qi.prototype = Object.create(Yi.prototype), Qi.prototype.constructor = Qi;
    var $i, tn, en, nn, rn, on, an, sn = 0;

    function ln() {
        Object.defineProperty(this, "id", {
            value: sn++
        }), this.uuid = je.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = B, this.side = E, this.flatShading = !1, this.vertexColors = R, this.opacity = 1, this.transparent = !1, this.blendSrc = X, this.blendDst = Y, this.blendEquation = D, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = nt, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function hn(t) {
        ln.call(this), this.type = "MeshBasicMaterial", this.color = new vi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = lt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
    }

    function cn(t) {
        ln.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    function un(t, e) {
        this.origin = void 0 !== t ? t : new Ye, this.direction = void 0 !== e ? e : new Ye
    }

    function pn(t, e) {
        this.start = void 0 !== t ? t : new Ye, this.end = void 0 !== e ? e : new Ye
    }

    function dn(t, e, i) {
        this.a = void 0 !== t ? t : new Ye, this.b = void 0 !== e ? e : new Ye, this.c = void 0 !== i ? i : new Ye
    }

    function fn(t, e) {
        Ai.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Yi, this.material = void 0 !== e ? e : new hn({
            color: 16777215 * Math.random()
        }), this.drawMode = Le, this.updateMorphTargets()
    }

    function mn(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function vn(t, e, i, n, r, o, a, s, l, h) {
        t = void 0 !== t ? t : [], e = void 0 !== e ? e : gt, ni.call(this, t, e, i, n, r, o, a, s, l, h), this.flipY = !1
    }
    ln.prototype = Object.assign(Object.create(n.prototype), {
        constructor: ln,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var i = t[e];
                    if (void 0 !== i)
                        if ("shading" !== e) {
                            var n = this[e];
                            void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = "overdraw" === e ? Number(i) : i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === A;
                    else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function n(t) {
                var e = [];
                for (var i in t) {
                    var n = t[i];
                    delete n.metadata, e.push(n)
                }
                return e
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== B && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== E && (i.side = this.side), this.vertexColors !== R && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
                var r = n(t.textures),
                    o = n(t.images);
                r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o)
            }
            return i
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes,
                i = null;
            if (null !== e) {
                var n = e.length;
                i = new Array(n);
                for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
            }
            return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }), hn.prototype = Object.create(ln.prototype), hn.prototype.constructor = hn, hn.prototype.isMeshBasicMaterial = !0, hn.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }, cn.prototype = Object.create(ln.prototype), cn.prototype.constructor = cn, cn.prototype.isShaderMaterial = !0, cn.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = fi.clone(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
    }, cn.prototype.toJSON = function(t) {
        var e = ln.prototype.toJSON.call(this, t);
        return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
    }, Object.assign(un.prototype, {
        set: function(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Ye), e.copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        },
        recast: function() {
            var t = new Ye;
            return function(e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(),
        closestPointToPoint: function(t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Ye), e.subVectors(t, this.origin);
            var i = e.dot(this.direction);
            return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function() {
            var t = new Ye;
            return function(e) {
                var i = t.subVectors(e, this.origin).dot(this.direction);
                return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
            }
        }(),
        distanceSqToSegment: (tn = new Ye, en = new Ye, nn = new Ye, function(t, e, i, n) {
            tn.copy(t).add(e).multiplyScalar(.5), en.copy(e).sub(t).normalize(), nn.copy(this.origin).sub(tn);
            var r, o, a, s, l = .5 * t.distanceTo(e),
                h = -this.direction.dot(en),
                c = nn.dot(this.direction),
                u = -nn.dot(en),
                p = nn.lengthSq(),
                d = Math.abs(1 - h * h);
            if (d > 0)
                if (o = h * c - u, s = l * d, (r = h * u - c) >= 0)
                    if (o >= -s)
                        if (o <= s) {
                            var f = 1 / d;
                            a = (r *= f) * (r + h * (o *= f) + 2 * c) + o * (h * r + o + 2 * u) + p
                        } else o = l, a = -(r = Math.max(0, -(h * o + c))) * r + o * (o + 2 * u) + p;
            else o = -l, a = -(r = Math.max(0, -(h * o + c))) * r + o * (o + 2 * u) + p;
            else o <= -s ? a = -(r = Math.max(0, -(-h * l + c))) * r + (o = r > 0 ? -l : Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + p : o <= s ? (r = 0, a = (o = Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + p) : a = -(r = Math.max(0, -(h * l + c))) * r + (o = r > 0 ? l : Math.min(Math.max(-l, -u), l)) * (o + 2 * u) + p;
            else o = h > 0 ? -l : l, a = -(r = Math.max(0, -(h * o + c))) * r + o * (o + 2 * u) + p;
            return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy(en).multiplyScalar(o).add(tn), a
        }),
        intersectSphere: function() {
            var t = new Ye;
            return function(e, i) {
                t.subVectors(e.center, this.origin);
                var n = t.dot(this.direction),
                    r = t.dot(t) - n * n,
                    o = e.radius * e.radius;
                if (r > o) return null;
                var a = Math.sqrt(o - r),
                    s = n - a,
                    l = n + a;
                return s < 0 && l < 0 ? null : s < 0 ? this.at(l, i) : this.at(s, i)
            }
        }(),
        intersectsSphere: function(t) {
            return this.distanceToPoint(t.center) <= t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var i = -(this.origin.dot(t.normal) + t.constant) / e;
            return i >= 0 ? i : null
        },
        intersectPlane: function(t, e) {
            var i = this.distanceToPlane(t);
            return null === i ? null : this.at(i, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            var i, n, r, o, a, s, l = 1 / this.direction.x,
                h = 1 / this.direction.y,
                c = 1 / this.direction.z,
                u = this.origin;
            return l >= 0 ? (i = (t.min.x - u.x) * l, n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l, n = (t.min.x - u.x) * l), h >= 0 ? (r = (t.min.y - u.y) * h, o = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h, o = (t.min.y - u.y) * h), i > o || r > n ? null : ((r > i || i != i) && (i = r), (o < n || n != n) && (n = o), c >= 0 ? (a = (t.min.z - u.z) * c, s = (t.max.z - u.z) * c) : (a = (t.max.z - u.z) * c, s = (t.min.z - u.z) * c), i > s || a > n ? null : ((a > i || i != i) && (i = a), (s < n || n != n) && (n = s), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
        },
        intersectsBox: ($i = new Ye, function(t) {
            return null !== this.intersectBox(t, $i)
        }),
        intersectTriangle: function() {
            var t = new Ye,
                e = new Ye,
                i = new Ye,
                n = new Ye;
            return function(r, o, a, s, l) {
                e.subVectors(o, r), i.subVectors(a, r), n.crossVectors(e, i);
                var h, c = this.direction.dot(n);
                if (c > 0) {
                    if (s) return null;
                    h = 1
                } else {
                    if (!(c < 0)) return null;
                    h = -1, c = -c
                }
                t.subVectors(this.origin, r);
                var u = h * this.direction.dot(i.crossVectors(t, i));
                if (u < 0) return null;
                var p = h * this.direction.dot(e.cross(t));
                if (p < 0) return null;
                if (u + p > c) return null;
                var d = -h * t.dot(n);
                return d < 0 ? null : this.at(d / c, l)
            }
        }(),
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }), Object.assign(pn.prototype, {
        set: function(t, e) {
            return this.start.copy(t), this.end.copy(e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Ye), t.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Ye), t.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Ye), this.delta(e).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: (rn = new Ye, on = new Ye, function(t, e) {
            rn.subVectors(t, this.start), on.subVectors(this.end, this.start);
            var i = on.dot(on),
                n = on.dot(rn) / i;
            return e && (n = je.clamp(n, 0, 1)), n
        }),
        closestPointToPoint: function(t, e, i) {
            var n = this.closestPointToPointParameter(t, e);
            return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new Ye), this.delta(i).multiplyScalar(n).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }), Object.assign(dn, {
        getNormal: (an = new Ye, function(t, e, i, n) {
            void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new Ye), n.subVectors(i, e), an.subVectors(t, e), n.cross(an);
            var r = n.lengthSq();
            return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
        }),
        getBarycoord: function() {
            var t = new Ye,
                e = new Ye,
                i = new Ye;
            return function(n, r, o, a, s) {
                t.subVectors(a, r), e.subVectors(o, r), i.subVectors(n, r);
                var l = t.dot(t),
                    h = t.dot(e),
                    c = t.dot(i),
                    u = e.dot(e),
                    p = e.dot(i),
                    d = l * u - h * h;
                if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new Ye), 0 === d) return s.set(-2, -1, -1);
                var f = 1 / d,
                    m = (u * c - h * p) * f,
                    v = (l * p - h * c) * f;
                return s.set(1 - m - v, v, m)
            }
        }(),
        containsPoint: function() {
            var t = new Ye;
            return function(e, i, n, r) {
                return dn.getBarycoord(e, i, n, r, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
            }
        }()
    }), Object.assign(dn.prototype, {
        set: function(t, e, i) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
        },
        setFromPointsAndIndices: function(t, e, i, n) {
            return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        },
        getArea: function() {
            var t = new Ye,
                e = new Ye;
            return function() {
                return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
            }
        }(),
        getMidpoint: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Ye), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(t) {
            return dn.getNormal(this.a, this.b, this.c, t)
        },
        getPlane: function(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Ye), t.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(t, e) {
            return dn.getBarycoord(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return dn.containsPoint(t, this.a, this.b, this.c)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var t = new ci,
                e = [new pn, new pn, new pn],
                i = new Ye,
                n = new Ye;
            return function(r, o) {
                void 0 === o && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), o = new Ye);
                var a = 1 / 0;
                if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, i), !0 === this.containsPoint(i)) o.copy(i);
                else {
                    e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a);
                    for (var s = 0; s < e.length; s++) {
                        e[s].closestPointToPoint(i, !0, n);
                        var l = i.distanceToSquared(n);
                        l < a && (a = l, o.copy(n))
                    }
                }
                return o
            }
        }(),
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }), fn.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: fn,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return Ai.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
        },
        updateMorphTargets: function() {
            var t, e, i, n = this.geometry;
            if (n.isBufferGeometry) {
                var r = n.morphAttributes,
                    o = Object.keys(r);
                if (o.length > 0) {
                    var a = r[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                }
            } else {
                var s = n.morphTargets;
                if (void 0 !== s && s.length > 0)
                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) i = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
            }
        },
        raycast: function() {
            var t = new qe,
                e = new un,
                i = new hi,
                n = new Ye,
                r = new Ye,
                o = new Ye,
                a = new Ye,
                s = new Ye,
                l = new Ye,
                h = new We,
                c = new We,
                u = new We,
                p = new Ye,
                d = new Ye,
                f = new Ye;

            function m(t, e, i, n, r, o, a) {
                return dn.getBarycoord(t, e, i, n, p), r.multiplyScalar(p.x), o.multiplyScalar(p.y), a.multiplyScalar(p.z), r.add(o).add(a), r.clone()
            }

            function v(t, e, i, n, r, o, a, s) {
                if (null === (e.side === M ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, e.side !== S, s))) return null;
                f.copy(s), f.applyMatrix4(t.matrixWorld);
                var l = i.ray.origin.distanceTo(f);
                return l < i.near || l > i.far ? null : {
                    distance: l,
                    point: f.clone(),
                    object: t
                }
            }

            function g(t, e, i, a, s, l, p, f) {
                n.fromBufferAttribute(a, l), r.fromBufferAttribute(a, p), o.fromBufferAttribute(a, f);
                var g = v(t, t.material, e, i, n, r, o, d);
                if (g) {
                    s && (h.fromBufferAttribute(s, l), c.fromBufferAttribute(s, p), u.fromBufferAttribute(s, f), g.uv = m(d, n, r, o, h, c, u));
                    var y = new Pi(l, p, f);
                    dn.getNormal(n, r, o, y.normal), g.face = y, g.faceIndex = l
                }
                return g
            }
            return function(p, f) {
                var y, _ = this.geometry,
                    x = this.material,
                    b = this.matrixWorld;
                if (void 0 !== x && (null === _.boundingSphere && _.computeBoundingSphere(), i.copy(_.boundingSphere), i.applyMatrix4(b), !1 !== p.ray.intersectsSphere(i) && (t.getInverse(b), e.copy(p.ray).applyMatrix4(t), null === _.boundingBox || !1 !== e.intersectsBox(_.boundingBox))))
                    if (_.isBufferGeometry) {
                        var w, T, E, M, S, A = _.index,
                            C = _.attributes.position,
                            R = _.attributes.uv;
                        if (null !== A)
                            for (M = 0, S = A.count; M < S; M += 3) w = A.getX(M), T = A.getX(M + 1), E = A.getX(M + 2), (y = g(this, p, e, C, R, w, T, E)) && (y.faceIndex = Math.floor(M / 3), f.push(y));
                        else if (void 0 !== C)
                            for (M = 0, S = C.count; M < S; M += 3)(y = g(this, p, e, C, R, w = M, T = M + 1, E = M + 2)) && f.push(y)
                    } else if (_.isGeometry) {
                    var P, L, O, B, I = Array.isArray(x),
                        N = _.vertices,
                        z = _.faces,
                        F = _.faceVertexUvs[0];
                    F.length > 0 && (B = F);
                    for (var D = 0, U = z.length; D < U; D++) {
                        var k = z[D],
                            V = I ? x[k.materialIndex] : x;
                        if (void 0 !== V) {
                            if (P = N[k.a], L = N[k.b], O = N[k.c], !0 === V.morphTargets) {
                                var H = _.morphTargets,
                                    G = this.morphTargetInfluences;
                                n.set(0, 0, 0), r.set(0, 0, 0), o.set(0, 0, 0);
                                for (var j = 0, W = H.length; j < W; j++) {
                                    var q = G[j];
                                    if (0 !== q) {
                                        var X = H[j].vertices;
                                        n.addScaledVector(a.subVectors(X[k.a], P), q), r.addScaledVector(s.subVectors(X[k.b], L), q), o.addScaledVector(l.subVectors(X[k.c], O), q)
                                    }
                                }
                                n.add(P), r.add(L), o.add(O), P = n, L = r, O = o
                            }
                            if (y = v(this, V, p, e, P, L, O, d)) {
                                if (B && B[D]) {
                                    var Y = B[D];
                                    h.copy(Y[0]), c.copy(Y[1]), u.copy(Y[2]), y.uv = m(d, P, L, O, h, c, u)
                                }
                                y.face = k, y.faceIndex = D, f.push(y)
                            }
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), vn.prototype = Object.create(ni.prototype), vn.prototype.constructor = vn, vn.prototype.isCubeTexture = !0, Object.defineProperty(vn.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    });
    var gn = new ni,
        yn = new vn;

    function _n() {
        this.seq = [], this.map = {}
    }
    var xn = [],
        bn = [],
        wn = new Float32Array(16),
        Tn = new Float32Array(9);

    function En(t, e, i) {
        var n = t[0];
        if (n <= 0 || n > 0) return t;
        var r = e * i,
            o = xn[r];
        if (void 0 === o && (o = new Float32Array(r), xn[r] = o), 0 !== e) {
            n.toArray(o, 0);
            for (var a = 1, s = 0; a !== e; ++a) s += i, t[a].toArray(o, s)
        }
        return o
    }

    function Mn(t, e) {
        var i = bn[e];
        void 0 === i && (i = new Int32Array(e), bn[e] = i);
        for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
        return i
    }

    function Sn(t, e) {
        t.uniform1f(this.addr, e)
    }

    function An(t, e) {
        t.uniform1i(this.addr, e)
    }

    function Cn(t, e) {
        void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
    }

    function Rn(t, e) {
        void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
    }

    function Pn(t, e) {
        void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
    }

    function Ln(t, e) {
        t.uniformMatrix2fv(this.addr, !1, e.elements || e)
    }

    function On(t, e) {
        void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (Tn.set(e.elements), t.uniformMatrix3fv(this.addr, !1, Tn))
    }

    function Bn(t, e) {
        void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (wn.set(e.elements), t.uniformMatrix4fv(this.addr, !1, wn))
    }

    function In(t, e, i) {
        var n = i.allocTextureUnit();
        t.uniform1i(this.addr, n), i.setTexture2D(e || gn, n)
    }

    function Nn(t, e, i) {
        var n = i.allocTextureUnit();
        t.uniform1i(this.addr, n), i.setTextureCube(e || yn, n)
    }

    function zn(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function Fn(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function Dn(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function Un(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function kn(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function Vn(t, e) {
        t.uniform2fv(this.addr, En(e, this.size, 2))
    }

    function Hn(t, e) {
        t.uniform3fv(this.addr, En(e, this.size, 3))
    }

    function Gn(t, e) {
        t.uniform4fv(this.addr, En(e, this.size, 4))
    }

    function jn(t, e) {
        t.uniformMatrix2fv(this.addr, !1, En(e, this.size, 4))
    }

    function Wn(t, e) {
        t.uniformMatrix3fv(this.addr, !1, En(e, this.size, 9))
    }

    function qn(t, e) {
        t.uniformMatrix4fv(this.addr, !1, En(e, this.size, 16))
    }

    function Xn(t, e, i) {
        var n = e.length,
            r = Mn(i, n);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== n; ++o) i.setTexture2D(e[o] || gn, r[o])
    }

    function Yn(t, e, i) {
        var n = e.length,
            r = Mn(i, n);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== n; ++o) i.setTextureCube(e[o] || yn, r[o])
    }

    function Zn(t, e, i) {
        this.id = t, this.addr = i, this.setValue = function(t) {
            switch (e.type) {
                case 5126:
                    return Sn;
                case 35664:
                    return Cn;
                case 35665:
                    return Rn;
                case 35666:
                    return Pn;
                case 35674:
                    return Ln;
                case 35675:
                    return On;
                case 35676:
                    return Bn;
                case 35678:
                case 36198:
                    return In;
                case 35680:
                    return Nn;
                case 5124:
                case 35670:
                    return An;
                case 35667:
                case 35671:
                    return zn;
                case 35668:
                case 35672:
                    return Fn;
                case 35669:
                case 35673:
                    return Dn
            }
        }()
    }

    function Jn(t, e, i) {
        this.id = t, this.addr = i, this.size = e.size, this.setValue = function(t) {
            switch (e.type) {
                case 5126:
                    return Un;
                case 35664:
                    return Vn;
                case 35665:
                    return Hn;
                case 35666:
                    return Gn;
                case 35674:
                    return jn;
                case 35675:
                    return Wn;
                case 35676:
                    return qn;
                case 35678:
                    return Xn;
                case 35680:
                    return Yn;
                case 5124:
                case 35670:
                    return kn;
                case 35667:
                case 35671:
                    return zn;
                case 35668:
                case 35672:
                    return Fn;
                case 35669:
                case 35673:
                    return Dn
            }
        }()
    }

    function Kn(t) {
        this.id = t, _n.call(this)
    }
    Kn.prototype.setValue = function(t, e) {
        for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
            var o = i[n];
            o.setValue(t, e[o.id])
        }
    };
    var Qn = /([\w\d_]+)(\])?(\[|\.)?/g;

    function $n(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function tr(t, e, i) {
        var n = t.name,
            r = n.length;
        for (Qn.lastIndex = 0;;) {
            var o = Qn.exec(n),
                a = Qn.lastIndex,
                s = o[1],
                l = "]" === o[2],
                h = o[3];
            if (l && (s |= 0), void 0 === h || "[" === h && a + 2 === r) {
                $n(i, void 0 === h ? new Zn(s, t, e) : new Jn(s, t, e));
                break
            }
            var c = i.map[s];
            void 0 === c && $n(i, c = new Kn(s)), i = c
        }
    }

    function er(t, e, i) {
        _n.call(this), this.renderer = i;
        for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
            var o = t.getActiveUniform(e, r);
            tr(o, t.getUniformLocation(e, o.name), this)
        }
    }

    function ir(t, e, i) {
        var n = t.createShader(e);
        return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), function(t) {
            for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
            return e.join("\n")
        }(i)), n
    }
    er.prototype.setValue = function(t, e, i) {
        var n = this.map[e];
        void 0 !== n && n.setValue(t, i, this.renderer)
    }, er.prototype.setOptional = function(t, e, i) {
        var n = e[i];
        void 0 !== n && this.setValue(t, i, n)
    }, er.upload = function(t, e, i, n) {
        for (var r = 0, o = e.length; r !== o; ++r) {
            var a = e[r],
                s = i[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, n)
        }
    }, er.seqWithValue = function(t, e) {
        for (var i = [], n = 0, r = t.length; n !== r; ++n) {
            var o = t[n];
            o.id in e && i.push(o)
        }
        return i
    };
    var nr = 0;

    function rr(t) {
        switch (t) {
            case Ie:
                return ["Linear", "( value )"];
            case Ne:
                return ["sRGB", "( value )"];
            case Fe:
                return ["RGBE", "( value )"];
            case Ue:
                return ["RGBM", "( value, 7.0 )"];
            case ke:
                return ["RGBM", "( value, 16.0 )"];
            case Ve:
                return ["RGBD", "( value, 256.0 )"];
            case ze:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw new Error("unsupported encoding: " + t)
        }
    }

    function or(t, e) {
        var i = rr(e);
        return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
    }

    function ar(t) {
        return "" !== t
    }

    function sr(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }

    function lr(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }

    function hr(t) {
        return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(t, e) {
            var i = di[e];
            if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
            return hr(i)
        })
    }

    function cr(t) {
        return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, i, n) {
            for (var r = "", o = parseInt(e); o < parseInt(i); o++) r += n.replace(/\[ i \]/g, "[ " + o + " ]");
            return r
        })
    }

    function ur(t, e, i) {
        var n = [],
            r = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow"
            },
            o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

        function a(t, e) {
            var i;
            return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = Ie, i === Ie && e && (i = ze), i
        }
        this.getParameters = function(e, n, o, s, l, h, c) {
            var u = r[e.type],
                p = c.isSkinnedMesh ? function(t) {
                    var e = c.skeleton,
                        n = e.bones;
                    if (e.useTexture && i.floatVertexTextures) return 1024;
                    var r = i.maxVertexUniforms,
                        o = Math.floor((r - 20) / 4),
                        a = Math.min(o, n.length);
                    return a < n.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + n.length + " bones. This GPU supports " + a + "."), 0) : a
                }() : 0,
                d = i.precision;
            null !== e.precision && (d = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d, "instead.");
            var f = t.getRenderTarget();
            return {
                shaderID: u,
                precision: d,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: a(f ? f.texture : null, t.gammaOutput),
                map: !!e.map,
                mapEncoding: a(e.map, t.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: a(e.envMap, t.gammaInput),
                envMapCubeUV: !!e.envMap && (e.envMap.mapping === wt || e.envMap.mapping === Tt),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!s,
                useFog: e.fog,
                fogExp: s && s.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: e.skinning && p > 0,
                maxBones: p,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: n.directional.length,
                numPointLights: n.point.length,
                numSpotLights: n.spot.length,
                numRectAreaLights: n.rectArea.length,
                numHemiLights: n.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: h,
                dithering: e.dithering,
                shadowMapEnabled: t.shadowMap.enabled && c.receiveShadow && o.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: t.toneMapping,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === S,
                flipSided: e.side === M,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }, this.getProgramCode = function(e, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                for (var r in e.defines) n.push(r), n.push(e.defines[r]);
            for (var a = 0; a < o.length; a++) n.push(i[o[a]]);
            return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.join()
        }, this.acquireProgram = function(i, r, o, a) {
            for (var s, l = 0, h = n.length; l < h; l++) {
                var c = n[l];
                if (c.code === a) {
                    ++(s = c).usedTimes;
                    break
                }
            }
            return void 0 === s && (s = new function(t, e, i, n, r, o) {
                var a = t.context,
                    s = n.defines,
                    l = r.vertexShader,
                    h = r.fragmentShader,
                    c = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === w ? c = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === T && (c = "SHADOWMAP_TYPE_PCF_SOFT");
                var u = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    d = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (n.envMap.mapping) {
                        case gt:
                        case yt:
                            u = "ENVMAP_TYPE_CUBE";
                            break;
                        case wt:
                        case Tt:
                            u = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case _t:
                        case xt:
                            u = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case bt:
                            u = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (n.envMap.mapping) {
                        case yt:
                        case xt:
                            p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (n.combine) {
                        case lt:
                            d = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case ht:
                            d = "ENVMAP_BLENDING_MIX";
                            break;
                        case ct:
                            d = "ENVMAP_BLENDING_ADD"
                    }
                }
                var f, m, v, g, y, _ = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    x = function(t, e, i) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ar).join("\n")
                    }(n.extensions, o, e),
                    b = function(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            !1 !== n && e.push("#define " + i + " " + n)
                        }
                        return e.join("\n")
                    }(s),
                    E = a.createProgram();
                n.isRawShaderMaterial ? ((f = [b].filter(ar).join("\n")).length > 0 && (f += "\n"), (m = [x, b].filter(ar).join("\n")).length > 0 && (m += "\n")) : (f = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + c : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ar).join("\n"), m = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + _, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + u : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + c : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== ut ? "#define TONE_MAPPING" : "", o.toneMapping !== ut ? di.tonemapping_pars_fragment : "", o.toneMapping !== ut ? function(t, e) {
                    var i;
                    switch (e) {
                        case pt:
                            i = "Linear";
                            break;
                        case dt:
                            i = "Reinhard";
                            break;
                        case ft:
                            i = "Uncharted2";
                            break;
                        case mt:
                            i = "OptimizedCineon";
                            break;
                        default:
                            throw new Error("unsupported toneMapping: " + e)
                    }
                    return "vec3 toneMapping( vec3 color ) { return " + i + "ToneMapping( color ); }"
                }(0, o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? di.encodings_pars_fragment : "", o.mapEncoding ? or("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? or("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? or("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? (v = "linearToOutputTexel", g = o.outputEncoding, y = rr(g), "vec4 " + v + "( vec4 value ) { return LinearTo" + y[0] + y[1] + "; }") : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ar).join("\n")), l = lr(l = sr(l = hr(l), o), o), h = lr(h = sr(h = hr(h), o), o);
                var M = f + (l = cr(l)),
                    S = m + (h = cr(h)),
                    A = ir(a, a.VERTEX_SHADER, M),
                    C = ir(a, a.FRAGMENT_SHADER, S);
                a.attachShader(E, A), a.attachShader(E, C), void 0 !== n.index0AttributeName ? a.bindAttribLocation(E, 0, n.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(E, 0, "position"), a.linkProgram(E);
                var R, P, L = a.getProgramInfoLog(E).trim(),
                    O = a.getShaderInfoLog(A).trim(),
                    B = a.getShaderInfoLog(C).trim(),
                    I = !0,
                    N = !0;
                return !1 === a.getProgramParameter(E, a.LINK_STATUS) ? (I = !1, console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(E, a.VALIDATE_STATUS), "gl.getProgramInfoLog", L, O, B)) : "" !== L ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", L) : "" !== O && "" !== B || (N = !1), N && (this.diagnostics = {
                    runnable: I,
                    material: n,
                    programLog: L,
                    vertexShader: {
                        log: O,
                        prefix: f
                    },
                    fragmentShader: {
                        log: B,
                        prefix: m
                    }
                }), a.deleteShader(A), a.deleteShader(C), this.getUniforms = function() {
                    return void 0 === R && (R = new er(a, E, t)), R
                }, this.getAttributes = function() {
                    return void 0 === P && (P = function(t, e) {
                        for (var i = {}, n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0; r < n; r++) {
                            var o = t.getActiveAttrib(e, r).name;
                            i[o] = t.getAttribLocation(e, o)
                        }
                        return i
                    }(a, E)), P
                }, this.destroy = function() {
                    a.deleteProgram(E), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.id = nr++, this.code = i, this.usedTimes = 1, this.program = E, this.vertexShader = A, this.fragmentShader = C, this
            }(t, e, a, i, r, o), n.push(s)), s
        }, this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = n.indexOf(t);
                n[e] = n[n.length - 1], n.pop(), t.destroy()
            }
        }, this.programs = n
    }

    function pr(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function dr(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    var fr, mr, vr, gr, yr, _r, xr, br, wr = 0;

    function Tr() {
        var t = {};
        return {
            get: function(e, i) {
                var n = e.id + "," + i.id,
                    r = t[n];
                return void 0 === r && (r = new function() {
                    var t = new function() {
                            var t = new function() {
                                    var t = {};
                                    return {
                                        get: function(e) {
                                            if (void 0 !== t[e.id]) return t[e.id];
                                            var i;
                                            switch (e.type) {
                                                case "DirectionalLight":
                                                    i = {
                                                        direction: new Ye,
                                                        color: new vi,
                                                        shadow: !1,
                                                        shadowBias: 0,
                                                        shadowRadius: 1,
                                                        shadowMapSize: new We
                                                    };
                                                    break;
                                                case "SpotLight":
                                                    i = {
                                                        position: new Ye,
                                                        direction: new Ye,
                                                        color: new vi,
                                                        distance: 0,
                                                        coneCos: 0,
                                                        penumbraCos: 0,
                                                        decay: 0,
                                                        shadow: !1,
                                                        shadowBias: 0,
                                                        shadowRadius: 1,
                                                        shadowMapSize: new We
                                                    };
                                                    break;
                                                case "PointLight":
                                                    i = {
                                                        position: new Ye,
                                                        color: new vi,
                                                        distance: 0,
                                                        decay: 0,
                                                        shadow: !1,
                                                        shadowBias: 0,
                                                        shadowRadius: 1,
                                                        shadowMapSize: new We,
                                                        shadowCameraNear: 1,
                                                        shadowCameraFar: 1e3
                                                    };
                                                    break;
                                                case "HemisphereLight":
                                                    i = {
                                                        direction: new Ye,
                                                        skyColor: new vi,
                                                        groundColor: new vi
                                                    };
                                                    break;
                                                case "RectAreaLight":
                                                    i = {
                                                        color: new vi,
                                                        position: new Ye,
                                                        halfWidth: new Ye,
                                                        halfHeight: new Ye
                                                    }
                                            }
                                            return t[e.id] = i, i
                                        }
                                    }
                                },
                                e = {
                                    id: wr++,
                                    hash: "",
                                    ambient: [0, 0, 0],
                                    directional: [],
                                    directionalShadowMap: [],
                                    directionalShadowMatrix: [],
                                    spot: [],
                                    spotShadowMap: [],
                                    spotShadowMatrix: [],
                                    rectArea: [],
                                    point: [],
                                    pointShadowMap: [],
                                    pointShadowMatrix: [],
                                    hemi: []
                                },
                                i = new Ye,
                                n = new qe,
                                r = new qe;
                            return {
                                setup: function(o, a, s) {
                                    for (var l = 0, h = 0, c = 0, u = 0, p = 0, d = 0, f = 0, m = 0, v = s.matrixWorldInverse, g = 0, y = o.length; g < y; g++) {
                                        var _ = o[g],
                                            x = _.color,
                                            b = _.intensity,
                                            w = _.distance,
                                            T = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                                        if (_.isAmbientLight) l += x.r * b, h += x.g * b, c += x.b * b;
                                        else if (_.isDirectionalLight) {
                                            if ((M = t.get(_)).color.copy(_.color).multiplyScalar(_.intensity), M.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(v), M.shadow = _.castShadow, _.castShadow) {
                                                var E = _.shadow;
                                                M.shadowBias = E.bias, M.shadowRadius = E.radius, M.shadowMapSize = E.mapSize
                                            }
                                            e.directionalShadowMap[u] = T, e.directionalShadowMatrix[u] = _.shadow.matrix, e.directional[u] = M, u++
                                        } else if (_.isSpotLight)(M = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), M.position.applyMatrix4(v), M.color.copy(x).multiplyScalar(b), M.distance = w, M.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(v), M.coneCos = Math.cos(_.angle), M.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), M.decay = 0 === _.distance ? 0 : _.decay, M.shadow = _.castShadow, _.castShadow && (E = _.shadow, M.shadowBias = E.bias, M.shadowRadius = E.radius, M.shadowMapSize = E.mapSize), e.spotShadowMap[d] = T, e.spotShadowMatrix[d] = _.shadow.matrix, e.spot[d] = M, d++;
                                        else if (_.isRectAreaLight)(M = t.get(_)).color.copy(x).multiplyScalar(b), M.position.setFromMatrixPosition(_.matrixWorld), M.position.applyMatrix4(v), r.identity(), n.copy(_.matrixWorld), n.premultiply(v), r.extractRotation(n), M.halfWidth.set(.5 * _.width, 0, 0), M.halfHeight.set(0, .5 * _.height, 0), M.halfWidth.applyMatrix4(r), M.halfHeight.applyMatrix4(r), e.rectArea[f] = M, f++;
                                        else if (_.isPointLight)(M = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), M.position.applyMatrix4(v), M.color.copy(_.color).multiplyScalar(_.intensity), M.distance = _.distance, M.decay = 0 === _.distance ? 0 : _.decay, M.shadow = _.castShadow, _.castShadow && (E = _.shadow, M.shadowBias = E.bias, M.shadowRadius = E.radius, M.shadowMapSize = E.mapSize, M.shadowCameraNear = E.camera.near, M.shadowCameraFar = E.camera.far), e.pointShadowMap[p] = T, e.pointShadowMatrix[p] = _.shadow.matrix, e.point[p] = M, p++;
                                        else if (_.isHemisphereLight) {
                                            var M;
                                            (M = t.get(_)).direction.setFromMatrixPosition(_.matrixWorld), M.direction.transformDirection(v), M.direction.normalize(), M.skyColor.copy(_.color).multiplyScalar(b), M.groundColor.copy(_.groundColor).multiplyScalar(b), e.hemi[m] = M, m++
                                        }
                                    }
                                    e.ambient[0] = l, e.ambient[1] = h, e.ambient[2] = c, e.directional.length = u, e.spot.length = d, e.rectArea.length = f, e.point.length = p, e.hemi.length = m, e.hash = e.id + "," + u + "," + p + "," + d + "," + f + "," + m + "," + a.length
                                },
                                state: e
                            }
                        },
                        e = [],
                        i = [],
                        n = [];
                    return {
                        init: function() {
                            e.length = 0, i.length = 0, n.length = 0
                        },
                        state: {
                            lightsArray: e,
                            shadowsArray: i,
                            spritesArray: n,
                            lights: t
                        },
                        setupLights: function(n) {
                            t.setup(e, i, n)
                        },
                        pushLight: function(t) {
                            e.push(t)
                        },
                        pushShadow: function(t) {
                            i.push(t)
                        },
                        pushSprite: function(t) {
                            n.push(t)
                        }
                    }
                }, t[n] = r), r
            },
            dispose: function() {
                t = {}
            }
        }
    }

    function Er(t) {
        ln.call(this), this.type = "MeshDepthMaterial", this.depthPacking = He, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function Mr(t) {
        ln.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Ye, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function Sr(t, e, i) {
        for (var n = new ui, r = new qe, o = new We, a = new We(i, i), s = new Ye, l = new Ye, h = 1, c = 2, u = 1 + (h | c), p = new Array(u), d = new Array(u), f = {}, m = {
                0: M,
                1: E,
                2: S
            }, v = [new Ye(1, 0, 0), new Ye(-1, 0, 0), new Ye(0, 0, 1), new Ye(0, 0, -1), new Ye(0, 1, 0), new Ye(0, -1, 0)], g = [new Ye(0, 1, 0), new Ye(0, 1, 0), new Ye(0, 1, 0), new Ye(0, 1, 0), new Ye(0, 0, 1), new Ye(0, 0, -1)], y = [new ri, new ri, new ri, new ri, new ri, new ri], _ = 0; _ !== u; ++_) {
            var x = 0 != (_ & h),
                b = 0 != (_ & c),
                T = new Er({
                    depthPacking: Ge,
                    morphTargets: x,
                    skinning: b
                });
            p[_] = T;
            var A = new Mr({
                morphTargets: x,
                skinning: b
            });
            d[_] = A
        }
        var C = this;

        function R(e, i, n, r, o, a) {
            var s = e.geometry,
                l = null,
                u = p,
                v = e.customDepthMaterial;
            if (n && (u = d, v = e.customDistanceMaterial), v) l = v;
            else {
                var g = !1;
                i.morphTargets && (s && s.isBufferGeometry ? g = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (g = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                var y = e.isSkinnedMesh && i.skinning,
                    _ = 0;
                g && (_ |= h), y && (_ |= c), l = u[_]
            }
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                var x = l.uuid,
                    b = i.uuid,
                    w = f[x];
                void 0 === w && (w = {}, f[x] = w);
                var T = w[b];
                void 0 === T && (T = l.clone(), w[b] = T), l = T
            }
            return l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : m[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = o, l.farDistance = a), l
        }

        function P(i, r, o, a, s) {
            if (!1 !== i.visible) {
                var h = i.layers.test(r.layers),
                    c = a.whitelist,
                    u = c && -1 !== c.indexOf(i.name),
                    p = a.blacklist,
                    d = p && -1 !== p.indexOf(i.name);
                if (h && (u || !c) && (!d || !p) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
                    var f = e.update(i),
                        m = i.material;
                    if (Array.isArray(m))
                        for (var v = f.groups, g = 0, y = v.length; g < y; g++) {
                            var _ = v[g],
                                x = m[_.materialIndex];
                            if (x && x.visible) {
                                var b = R(i, x, s, l, o.near, o.far);
                                t.renderBufferDirect(o, null, f, b, i, _)
                            }
                        } else m.visible && (b = R(i, m, s, l, o.near, o.far), t.renderBufferDirect(o, null, f, b, i, null))
                }
                for (var w = i.children, T = 0, E = w.length; T < E; T++) P(w[T], r, o, a, s)
            }
        }
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = w, this.render = function(e, i, h) {
            if (!1 !== C.enabled && (!1 !== C.autoUpdate || !1 !== C.needsUpdate) && 0 !== e.length) {
                var c, u = t.context,
                    p = t.state;
                p.disable(u.BLEND), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
                for (var d = 0, f = e.length; d < f; d++) {
                    var m = e[d],
                        _ = m.shadow,
                        x = m && m.isPointLight;
                    if (void 0 !== _) {
                        if (_.needsUpdate) {
                            var b = _.camera;
                            if (o.copy(_.mapSize), o.min(a), x) {
                                var w = o.x,
                                    T = o.y;
                                y[0].set(2 * w, T, w, T), y[1].set(0, T, w, T), y[2].set(3 * w, T, w, T), y[3].set(w, T, w, T), y[4].set(3 * w, 0, w, T), y[5].set(w, 0, w, T), o.x *= 4, o.y *= 2
                            }
                            if (null === _.map) {
                                var E = {
                                    minFilter: At,
                                    magFilter: At,
                                    format: Xt
                                };
                                _.map = new oi(o.x, o.y, E), _.map.texture.name = m.name + ".shadowMap", b.updateProjectionMatrix()
                            }
                            _.isSpotLightShadow && _.update(m);
                            var M = _.map,
                                S = _.matrix;
                            l.setFromMatrixPosition(m.matrixWorld), b.position.copy(l), x ? (c = 6, S.makeTranslation(-l.x, -l.y, -l.z)) : (c = 1, s.setFromMatrixPosition(m.target.matrixWorld), b.lookAt(s), b.updateMatrixWorld(), S.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), S.multiply(b.projectionMatrix), S.multiply(b.matrixWorldInverse)), t.setRenderTarget(M), t.clear();
                            for (var A = 0; A < c; A++) {
                                if (x) {
                                    s.copy(b.position), s.add(v[A]), b.up.copy(g[A]), b.lookAt(s), b.updateMatrixWorld();
                                    var R = y[A];
                                    p.viewport(R)
                                }
                                r.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), n.setFromMatrix(r), P(i, h, b, _, x)
                            }
                        }
                    } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
                }
                C.needsUpdate = !1
            }
        }
    }

    function Ar(t, e, i, n, r, o, a, s, l) {
        ni.call(this, t, e, i, n, r, o, a, s, l), this.needsUpdate = !0
    }

    function Cr(t, e, i, n, r, o, a) {
        var s, l = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
            h = {};

        function c(t, e) {
            if (t.width > e || t.height > e) {
                if ("data" in t) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t.height + ").");
                var i = e / Math.max(t.width, t.height),
                    n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t), n
            }
            return t
        }

        function u(t) {
            return je.isPowerOfTwo(t.width) && je.isPowerOfTwo(t.height)
        }

        function p(t, e) {
            return t.generateMipmaps && e && t.minFilter !== At && t.minFilter !== Pt
        }

        function d(e, i, r, o) {
            t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log2(Math.max(r, o))
        }

        function f(e) {
            return e === At || e === Ct || e === Rt ? t.NEAREST : t.LINEAR
        }

        function m(e) {
            var i = e.target;
            i.removeEventListener("dispose", m),
                function(e) {
                    var i = n.get(e);
                    if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                    else {
                        if (void 0 === i.__webglInit) return;
                        t.deleteTexture(i.__webglTexture)
                    }
                    n.remove(e)
                }(i), i.isVideoTexture && delete h[i.id], a.memory.textures--
        }

        function v(e) {
            var i = e.target;
            i.removeEventListener("dispose", v),
                function(e) {
                    var i = n.get(e),
                        r = n.get(e.texture);
                    if (e) {
                        if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.drawBuffersTextures)
                            for (var o = 0; o < e.drawBuffersTextures.length; o++) {
                                var a = e.drawBuffersTextures[o];
                                r = n.get(a);
                                t.deleteTexture(r.__webglTexture)
                            }
                        if (e.isWebGLRenderTargetCube)
                            for (o = 0; o < 6; o++) t.deleteFramebuffer(i.__webglFramebuffer[o]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[o]);
                        else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                        n.remove(e.texture), n.remove(e)
                    }
                }(i), a.memory.textures--
        }

        function g(e, f) {
            var v = n.get(e);
            if (e.isVideoTexture && function(t) {
                    var e = t.id,
                        i = a.render.frame;
                    h[e] !== i && (h[e] = i, t.update())
                }(e), e.version > 0 && v.__version !== e.version) {
                var g = e.image;
                if (void 0 === g) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                else {
                    if (!1 !== g.complete) return void
                    function(e, n, h) {
                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), a.memory.textures++), i.activeTexture(t.TEXTURE0 + h), i.bindTexture(t.TEXTURE_2D, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, n.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, n.unpackAlignment);
                        var f = c(n.image, r.maxTextureSize);
                        (function(t) {
                            return t.wrapS !== Mt || t.wrapT !== Mt || t.minFilter !== At && t.minFilter !== Pt
                        })(n) && !1 === u(f) && (f = function(t) {
                            return t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap ? (void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = je.floorPowerOfTwo(t.width), s.height = je.floorPowerOfTwo(t.height), s.getContext("2d").drawImage(t, 0, 0, s.width, s.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + s.width + "x" + s.height, t), s) : t
                        }(f));
                        var v = u(f),
                            g = o.convert(n.format),
                            _ = o.convert(n.type);
                        y(t.TEXTURE_2D, n, v);
                        var x, b = n.mipmaps;
                        if (n.isDepthTexture) {
                            var w = t.DEPTH_COMPONENT;
                            if (n.type === Ut) {
                                if (!l) throw new Error("Float Depth Texture only supported in WebGL2.0");
                                w = t.DEPTH_COMPONENT32F
                            } else l && (w = t.DEPTH_COMPONENT16);
                            n.format === Kt && w === t.DEPTH_COMPONENT && n.type !== zt && n.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = zt, _ = o.convert(n.type)), n.format === Qt && (w = t.DEPTH_STENCIL, n.type !== jt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = jt, _ = o.convert(n.type))), i.texImage2D(t.TEXTURE_2D, 0, w, f.width, f.height, 0, g, _, null)
                        } else if (n.isDataTexture)
                            if (b.length > 0 && v) {
                                for (var T = 0, E = b.length; T < E; T++) x = b[T], i.texImage2D(t.TEXTURE_2D, T, g, x.width, x.height, 0, g, _, x.data);
                                n.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                            } else i.texImage2D(t.TEXTURE_2D, 0, g, f.width, f.height, 0, g, _, f.data), e.__maxMipLevel = 0;
                        else if (n.isCompressedTexture) {
                            for (T = 0, E = b.length; T < E; T++) x = b[T], n.format !== Xt && n.format !== qt ? i.getCompressedTextureFormats().indexOf(g) > -1 ? i.compressedTexImage2D(t.TEXTURE_2D, T, g, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(t.TEXTURE_2D, T, g, x.width, x.height, 0, g, _, x.data);
                            e.__maxMipLevel = b.length - 1
                        } else if (b.length > 0 && v) {
                            for (T = 0, E = b.length; T < E; T++) x = b[T], i.texImage2D(t.TEXTURE_2D, T, g, g, _, x);
                            n.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                        } else i.texImage2D(t.TEXTURE_2D, 0, g, g, _, f), e.__maxMipLevel = 0;
                        p(n, v) && d(t.TEXTURE_2D, n, f.width, f.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
                    }(v, e, f);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                }
            }
            i.activeTexture(t.TEXTURE0 + f), i.bindTexture(t.TEXTURE_2D, v.__webglTexture)
        }

        function y(i, a, s) {
            var l;
            if (s ? (t.texParameteri(i, t.TEXTURE_WRAP_S, o.convert(a.wrapS)), t.texParameteri(i, t.TEXTURE_WRAP_T, o.convert(a.wrapT)), t.texParameteri(i, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS === Mt && a.wrapT === Mt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), t.texParameteri(i, t.TEXTURE_MAG_FILTER, f(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, f(a.minFilter)), a.minFilter !== At && a.minFilter !== Pt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), l = e.get("EXT_texture_filter_anisotropic")) {
                if (a.type === Ut && null === e.get("OES_texture_float_linear")) return;
                if (a.type === kt && null === e.get("OES_texture_half_float_linear")) return;
                (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (t.texParameterf(i, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
            }
        }

        function _(e, r, a, s, l) {
            l = void 0 !== l ? l : n.get(r.texture).__webglTexture;
            var h = o.convert(l.format || r.texture.format),
                c = o.convert(l.type || r.texture.type);
            i.texImage2D(s, 0, h, r.width, r.height, 0, h, c, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, s, l.__webglTexture || l, 0)
        }

        function x(e, i) {
            t.bindRenderbuffer(t.RENDERBUFFER, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height)
        }

        function b(e) {
            var i = n.get(e),
                r = !0 === e.isWebGLRenderTargetCube;
            if (e.depthTexture) {
                if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function(e, i) {
                    if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(t.FRAMEBUFFER, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), g(i.depthTexture, 0);
                    var r = n.get(i.depthTexture).__webglTexture;
                    if (i.depthTexture.format === Kt) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                    else {
                        if (i.depthTexture.format !== Qt) throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                    }
                }(i.__webglFramebuffer, e)
            } else if (r) {
                i.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++) t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = t.createRenderbuffer(), x(i.__webglDepthbuffer[o], e)
            } else t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), x(i.__webglDepthbuffer, e);
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }
        this.setTexture2D = g, this.setTextureCube = function(e, s) {
            var l = n.get(e);
            if (6 === e.image.length)
                if (e.version > 0 && l.__version !== e.version) {
                    l.__image__webglTextureCube || (e.addEventListener("dispose", m), l.__image__webglTextureCube = t.createTexture(), a.memory.textures++), i.activeTexture(t.TEXTURE0 + s), i.bindTexture(t.TEXTURE_CUBE_MAP, l.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (var h = e && e.isCompressedTexture, f = e.image[0] && e.image[0].isDataTexture, v = [], g = 0; g < 6; g++) v[g] = h || f ? f ? e.image[g].image : e.image[g] : c(e.image[g], r.maxCubemapSize);
                    var _ = v[0],
                        x = u(_),
                        b = o.convert(e.format),
                        w = o.convert(e.type);
                    for (y(t.TEXTURE_CUBE_MAP, e, x), g = 0; g < 6; g++)
                        if (h)
                            for (var T, E = v[g].mipmaps, M = 0, S = E.length; M < S; M++) T = E[M], e.format !== Xt && e.format !== qt ? i.getCompressedTextureFormats().indexOf(b) > -1 ? i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, M, b, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, M, b, T.width, T.height, 0, b, w, T.data);
                        else f ? i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, b, v[g].width, v[g].height, 0, b, w, v[g].data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, b, b, w, v[g]);
                    l.__maxMipLevel = h ? E.length - 1 : 0, p(e, x) && d(t.TEXTURE_CUBE_MAP, e, _.width, _.height), l.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else i.activeTexture(t.TEXTURE0 + s), i.bindTexture(t.TEXTURE_CUBE_MAP, l.__image__webglTextureCube)
        }, this.setTextureCubeDynamic = function(e, r) {
            i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_CUBE_MAP, n.get(e).__webglTexture)
        }, this.setupRenderTarget = function(o) {
            var s = n.get(o),
                l = n.get(o.texture);
            o.addEventListener("dispose", v), l.__webglTexture = t.createTexture(), a.memory.textures++;
            var h = !0 === o.isWebGLRenderTargetCube,
                c = u(o),
                f = e.get("WEBGL_draw_buffers"),
                m = f ? f.COLOR_ATTACHMENT0_WEBGL : t.COLOR_ATTACHMENT0;
            if (h) {
                s.__webglFramebuffer = [];
                for (var x = 0; x < 6; x++) s.__webglFramebuffer[x] = t.createFramebuffer()
            } else s.__webglFramebuffer = t.createFramebuffer();
            if (h) {
                for (i.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture), y(t.TEXTURE_CUBE_MAP, o.texture, c), x = 0; x < 6; x++) _(s.__webglFramebuffer[x], o, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + x);
                p(o.texture, c) && d(t.TEXTURE_CUBE_MAP, o.texture, o.width, o.height), i.bindTexture(t.TEXTURE_CUBE_MAP, null)
            } else {
                i.bindTexture(t.TEXTURE_2D, l.__webglTexture), y(t.TEXTURE_2D, o.texture, c), _(s.__webglFramebuffer, o, m, t.TEXTURE_2D), p(o.texture, c) && d(t.TEXTURE_2D, o.texture, o.width, o.height);
                var w = 1;
                for (x = 0; x < o.drawBuffersTextures.length; x++) {
                    if (w >= r.maxDrawBuffers) {
                        console.warn("WebGLRenderer: rendertarget has too many color textures - this GPU supports " + r.maxDrawBuffers);
                        break
                    }
                    var T = o.drawBuffersTextures[x];
                    (l = n.get(T)).__webglTexture = t.createTexture(), l.format = T.format, l.type = T.type, g(T, 0), y(t.TEXTURE_2D, T, c), _(s.__webglFramebuffer, o, m + w, t.TEXTURE_2D, l), w++
                }
                if (f) {
                    var E = [];
                    for (x = 0; x < w; x++) E[x] = f.COLOR_ATTACHMENT0_WEBGL + x;
                    f.drawBuffersWEBGL(E)
                }
                i.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            o.depthBuffer && b(o)
        }, this.updateRenderTargetMipmap = function(e) {
            for (var r = e.texture, o = u(e), a = 0; a < e.drawBuffersTextures.length; a++) p(r = e.drawBuffersTextures[a], o) && (i.bindTexture(s, r), d(s, r, e.width, e.height), i.bindTexture(s, null));
            if (p(r, o)) {
                var s = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                    l = n.get(r).__webglTexture;
                i.bindTexture(s, l), d(s, r, e.width, e.height), i.bindTexture(s, null)
            }
        }
    }

    function Rr(t, e) {
        return {
            convert: function(i) {
                var n;
                if (i === Et) return t.REPEAT;
                if (i === Mt) return t.CLAMP_TO_EDGE;
                if (i === St) return t.MIRRORED_REPEAT;
                if (i === At) return t.NEAREST;
                if (i === Ct) return t.NEAREST_MIPMAP_NEAREST;
                if (i === Rt) return t.NEAREST_MIPMAP_LINEAR;
                if (i === Pt) return t.LINEAR;
                if (i === Lt) return t.LINEAR_MIPMAP_NEAREST;
                if (i === Ot) return t.LINEAR_MIPMAP_LINEAR;
                if (i === Bt) return t.UNSIGNED_BYTE;
                if (i === Vt) return t.UNSIGNED_SHORT_4_4_4_4;
                if (i === Ht) return t.UNSIGNED_SHORT_5_5_5_1;
                if (i === Gt) return t.UNSIGNED_SHORT_5_6_5;
                if (i === It) return t.BYTE;
                if (i === Nt) return t.SHORT;
                if (i === zt) return t.UNSIGNED_SHORT;
                if (i === Ft) return t.INT;
                if (i === Dt) return t.UNSIGNED_INT;
                if (i === Ut) return t.FLOAT;
                if (i === kt && null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES;
                if (i === Wt) return t.ALPHA;
                if (i === qt) return t.RGB;
                if (i === Xt) return t.RGBA;
                if (i === Yt) return t.LUMINANCE;
                if (i === Zt) return t.LUMINANCE_ALPHA;
                if (i === Kt) return t.DEPTH_COMPONENT;
                if (i === Qt) return t.DEPTH_STENCIL;
                if (i === D) return t.FUNC_ADD;
                if (i === U) return t.FUNC_SUBTRACT;
                if (i === k) return t.FUNC_REVERSE_SUBTRACT;
                if (i === G) return t.ZERO;
                if (i === j) return t.ONE;
                if (i === W) return t.SRC_COLOR;
                if (i === q) return t.ONE_MINUS_SRC_COLOR;
                if (i === X) return t.SRC_ALPHA;
                if (i === Y) return t.ONE_MINUS_SRC_ALPHA;
                if (i === Z) return t.DST_ALPHA;
                if (i === J) return t.ONE_MINUS_DST_ALPHA;
                if (i === K) return t.DST_COLOR;
                if (i === Q) return t.ONE_MINUS_DST_COLOR;
                if (i === $) return t.SRC_ALPHA_SATURATE;
                if ((i === $t || i === te || i === ee || i === ie) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                    if (i === $t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (i === te) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (i === ee) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (i === ie) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((i === ne || i === re || i === oe || i === ae) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (i === ne) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (i === re) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (i === oe) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (i === ae) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (i === se && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((i === le || i === he || i === ce || i === ue || i === pe || i === de || i === fe || i === me || i === ve || i === ge || i === ye || i === _e || i === xe || i === be) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return i;
                if ((i === V || i === H) && null !== (n = e.get("EXT_blend_minmax"))) {
                    if (i === V) return n.MIN_EXT;
                    if (i === H) return n.MAX_EXT
                }
                return i === jt && null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : 0
            }
        }
    }

    function Pr(t, e, i, n) {
        Ci.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function Lr(t) {
        Pr.call(this), this.cameras = t || []
    }

    function Or(t) {
        var e = this,
            i = null,
            n = null,
            r = null,
            o = new qe,
            a = new qe;
        "undefined" != typeof window && "VRFrameData" in window && (n = new window.VRFrameData);
        var s = new qe,
            l = new Xe,
            h = new Ye,
            c = new Pr;
        c.bounds = new ri(0, 0, .5, 1), c.layers.enable(1);
        var u = new Pr;
        u.bounds = new ri(.5, 0, .5, 1), u.layers.enable(2);
        var p, d, f = new Lr([c, u]);

        function m() {
            if (null !== i && i.isPresenting) {
                var n = i.getEyeParameters("left"),
                    r = n.renderWidth,
                    o = n.renderHeight;
                d = t.getPixelRatio(), p = t.getSize(), t.setDrawingBufferSize(2 * r, o, 1)
            } else e.enabled && t.setDrawingBufferSize(p.width, p.height, d)
        }
        f.layers.enable(1), f.layers.enable(2), "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", m, !1), this.enabled = !1, this.userHeight = 1.6, this.getDevice = function() {
            return i
        }, this.setDevice = function(t) {
            void 0 !== t && (i = t)
        }, this.setPoseTarget = function(t) {
            void 0 !== t && (r = t)
        }, this.getCamera = function(t) {
            if (null === i) return t;
            i.depthNear = t.near, i.depthFar = t.far, i.getFrameData(n);
            var p = i.stageParameters;
            p ? o.fromArray(p.sittingToStandingTransform) : o.makeTranslation(0, e.userHeight, 0);
            var d = n.pose,
                m = null !== r ? r : t;
            if (m.matrix.copy(o), m.matrix.decompose(m.position, m.quaternion, m.scale), null !== d.orientation && (l.fromArray(d.orientation), m.quaternion.multiply(l)), null !== d.position && (l.setFromRotationMatrix(o), h.fromArray(d.position), h.applyQuaternion(l), m.position.add(h)), m.updateMatrixWorld(), !1 === i.isPresenting) return t;
            c.near = t.near, u.near = t.near, c.far = t.far, u.far = t.far, f.matrixWorld.copy(t.matrixWorld), f.matrixWorldInverse.copy(t.matrixWorldInverse), c.matrixWorldInverse.fromArray(n.leftViewMatrix), u.matrixWorldInverse.fromArray(n.rightViewMatrix), a.getInverse(o), c.matrixWorldInverse.multiply(a), u.matrixWorldInverse.multiply(a);
            var v = m.parent;
            null !== v && (s.getInverse(v.matrixWorld), c.matrixWorldInverse.multiply(s), u.matrixWorldInverse.multiply(s)), c.matrixWorld.getInverse(c.matrixWorldInverse), u.matrixWorld.getInverse(u.matrixWorldInverse), c.projectionMatrix.fromArray(n.leftProjectionMatrix), u.projectionMatrix.fromArray(n.rightProjectionMatrix), f.projectionMatrix.copy(c.projectionMatrix);
            var g = i.getLayers();
            if (g.length) {
                var y = g[0];
                null !== y.leftBounds && 4 === y.leftBounds.length && c.bounds.fromArray(y.leftBounds), null !== y.rightBounds && 4 === y.rightBounds.length && u.bounds.fromArray(y.rightBounds)
            }
            return f
        }, this.getStandingMatrix = function() {
            return o
        }, this.submitFrame = function() {
            i && i.isPresenting && i.submitFrame()
        }, this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", m)
        }
    }

    function Br(t) {
        var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            i = void 0 !== t.context ? t.context : null,
            n = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            o = void 0 === t.stencil || t.stencil,
            a = void 0 !== t.antialias && t.antialias,
            s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            h = void 0 !== t.powerPreference ? t.powerPreference : "default",
            c = null,
            u = null;
        this.domElement = e, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = pt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var p, d, f, y, _, x, b, w, T, E, A, C, P, L, D, U, k, V, H, G = this,
            j = !1,
            W = null,
            q = null,
            X = -1,
            Y = "",
            Z = null,
            J = null,
            K = new ri,
            Q = new ri,
            $ = null,
            lt = 0,
            ht = e.width,
            ct = e.height,
            ut = 1,
            dt = new ri(0, 0, ht, ct),
            ft = new ri(0, 0, ht, ct),
            mt = !1,
            vt = new ui,
            gt = new function() {
                var t = this,
                    e = null,
                    i = 0,
                    n = !1,
                    r = !1,
                    o = new ci,
                    a = new Ze,
                    s = {
                        value: null,
                        needsUpdate: !1
                    };

                function l() {
                    s.value !== e && (s.value = e, s.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
                }

                function h(e, i, n, r) {
                    var l = null !== e ? e.length : 0,
                        h = null;
                    if (0 !== l) {
                        if (h = s.value, !0 !== r || null === h) {
                            var c = n + 4 * l,
                                u = i.matrixWorldInverse;
                            a.getNormalMatrix(u), (null === h || h.length < c) && (h = new Float32Array(c));
                            for (var p = 0, d = n; p !== l; ++p, d += 4) o.copy(e[p]).applyMatrix4(u, a), o.normal.toArray(h, d), h[d + 3] = o.constant
                        }
                        s.value = h, s.needsUpdate = !0
                    }
                    return t.numPlanes = l, h
                }
                this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, o) {
                    var a = 0 !== t.length || r || 0 !== i || n;
                    return n = r, e = h(t, o, 0), i = t.length, a
                }, this.beginShadows = function() {
                    r = !0, h(null)
                }, this.endShadows = function() {
                    r = !1, l()
                }, this.setState = function(t, o, a, c, u, p) {
                    if (!n || null === t || 0 === t.length || r && !a) r ? h(null) : l();
                    else {
                        var d = r ? 0 : i,
                            f = 4 * d,
                            m = u.clippingState || null;
                        s.value = m, m = h(t, c, f, p);
                        for (var v = 0; v !== f; ++v) m[v] = e[v];
                        u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d
                    }
                }
            },
            yt = !1,
            _t = !1,
            xt = new qe,
            bt = new Ye;

        function wt() {
            return null === W ? ut : 1
        }
        try {
            var Tt = {
                alpha: n,
                depth: r,
                stencil: o,
                antialias: a,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: h
            };
            if (e.addEventListener("webglcontextlost", At, !1), e.addEventListener("webglcontextrestored", Ct, !1), null === (p = i || e.getContext("webgl", Tt) || e.getContext("experimental-webgl", Tt))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === p.getShaderPrecisionFormat && (p.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            })
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t.message)
        }

        function Et() {
            (d = new function(t) {
                var e = {};
                return {
                    get: function(i) {
                        if (void 0 !== e[i]) return e[i];
                        var n;
                        switch (i) {
                            case "WEBGL_depth_texture":
                                n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            case "WEBGL_compressed_texture_etc1":
                                n = t.getExtension("WEBGL_compressed_texture_etc1");
                                break;
                            default:
                                n = t.getExtension(i)
                        }
                        return e[i] = n, n
                    }
                }
            }(p)).get("WEBGL_depth_texture"), d.get("WEBGL_draw_buffers"), d.get("OES_texture_float"), d.get("OES_texture_float_linear"), d.get("OES_texture_half_float"), d.get("OES_texture_half_float_linear"), d.get("OES_standard_derivatives"), d.get("OES_element_index_uint"), d.get("ANGLE_instanced_arrays"), H = new Rr(p, d), f = new function(t, e, i) {
                var n;

                function r(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                var o = void 0 !== i.precision ? i.precision : "highp",
                    a = r(o);
                a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                var s = !0 === i.logarithmicDepthBuffer,
                    l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                    h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    c = t.getParameter(t.MAX_TEXTURE_SIZE),
                    u = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                    p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                    d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                    f = t.getParameter(t.MAX_VARYING_VECTORS),
                    m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                    v = h > 0,
                    g = !!e.get("OES_texture_float"),
                    y = v && g,
                    _ = e.get("WEBGL_draw_buffers");
                return {
                    getMaxAnisotropy: function() {
                        if (void 0 !== n) return n;
                        var i = e.get("EXT_texture_filter_anisotropic");
                        return n = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: r,
                    precision: o,
                    logarithmicDepthBuffer: s,
                    maxTextures: l,
                    maxVertexTextures: h,
                    maxTextureSize: c,
                    maxCubemapSize: u,
                    maxAttributes: p,
                    maxVertexUniforms: d,
                    maxVaryings: f,
                    maxFragmentUniforms: m,
                    vertexTextures: v,
                    floatFragmentTextures: g,
                    floatVertexTextures: y,
                    maxDrawBuffers: _ ? t.getParameter(_.MAX_DRAW_BUFFERS_WEBGL) : 1
                }
            }(p, d, t), (y = new function(t, e, i) {
                var n = new function() {
                        var e = !1,
                            i = new ri,
                            n = null,
                            r = new ri(0, 0, 0, 0);
                        return {
                            setMask: function(i) {
                                n === i || e || (t.colorMask(i, i, i, i), n = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, n, o, a, s) {
                                !0 === s && (e *= a, n *= a, o *= a), i.set(e, n, o, a), !1 === r.equals(i) && (t.clearColor(e, n, o, a), r.copy(i))
                            },
                            reset: function() {
                                e = !1, n = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    r = new function() {
                        var e = !1,
                            i = null,
                            n = null,
                            r = null;
                        return {
                            setTest: function(e) {
                                e ? X(t.DEPTH_TEST) : Y(t.DEPTH_TEST)
                            },
                            setMask: function(n) {
                                i === n || e || (t.depthMask(n), i = n)
                            },
                            setFunc: function(e) {
                                if (n !== e) {
                                    if (e) switch (e) {
                                        case tt:
                                            t.depthFunc(t.NEVER);
                                            break;
                                        case et:
                                            t.depthFunc(t.ALWAYS);
                                            break;
                                        case it:
                                            t.depthFunc(t.LESS);
                                            break;
                                        case nt:
                                            t.depthFunc(t.LEQUAL);
                                            break;
                                        case rt:
                                            t.depthFunc(t.EQUAL);
                                            break;
                                        case ot:
                                            t.depthFunc(t.GEQUAL);
                                            break;
                                        case at:
                                            t.depthFunc(t.GREATER);
                                            break;
                                        case st:
                                            t.depthFunc(t.NOTEQUAL);
                                            break;
                                        default:
                                            t.depthFunc(t.LEQUAL)
                                    } else t.depthFunc(t.LEQUAL);
                                    n = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                r !== e && (t.clearDepth(e), r = e)
                            },
                            reset: function() {
                                e = !1, i = null, n = null, r = null
                            }
                        }
                    },
                    o = new function() {
                        var e = !1,
                            i = null,
                            n = null,
                            r = null,
                            o = null,
                            a = null,
                            s = null,
                            l = null,
                            h = null;
                        return {
                            setTest: function(e) {
                                e ? X(t.STENCIL_TEST) : Y(t.STENCIL_TEST)
                            },
                            setMask: function(n) {
                                i === n || e || (t.stencilMask(n), i = n)
                            },
                            setFunc: function(e, i, a) {
                                n === e && r === i && o === a || (t.stencilFunc(e, i, a), n = e, r = i, o = a)
                            },
                            setOp: function(e, i, n) {
                                a === e && s === i && l === n || (t.stencilOp(e, i, n), a = e, s = i, l = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                h !== e && (t.clearStencil(e), h = e)
                            },
                            reset: function() {
                                e = !1, i = null, n = null, r = null, o = null, a = null, s = null, l = null, h = null
                            }
                        }
                    },
                    a = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                    s = new Uint8Array(a),
                    l = new Uint8Array(a),
                    h = new Uint8Array(a),
                    c = {},
                    u = null,
                    p = null,
                    d = null,
                    f = null,
                    y = null,
                    _ = null,
                    x = null,
                    b = null,
                    w = null,
                    T = !1,
                    E = null,
                    A = null,
                    C = null,
                    R = null,
                    P = null,
                    L = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    D = !1,
                    U = 0,
                    k = t.getParameter(t.VERSION); - 1 !== k.indexOf("WebGL") ? (U = parseFloat(/^WebGL\ ([0-9])/.exec(k)[1]), D = U >= 1) : -1 !== k.indexOf("OpenGL ES") && (U = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(k)[1]), D = U >= 2);
                var V = null,
                    H = {},
                    G = new ri,
                    j = new ri;

                function W(e, i, n) {
                    var r = new Uint8Array(4),
                        o = t.createTexture();
                    t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                    for (var a = 0; a < n; a++) t.texImage2D(i + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                    return o
                }
                var q = {};

                function X(e) {
                    !0 !== c[e] && (t.enable(e), c[e] = !0)
                }

                function Y(e) {
                    !1 !== c[e] && (t.disable(e), c[e] = !1)
                }

                function Z(e, n, r, o, a, s, l, h) {
                    if (e !== O ? X(t.BLEND) : Y(t.BLEND), e !== F) {
                        if (e !== d || h !== T) switch (e) {
                            case I:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE));
                                break;
                            case N:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                                break;
                            case z:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR));
                                break;
                            default:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                        }
                        f = null, y = null, _ = null, x = null, b = null, w = null
                    } else a = a || n, s = s || r, l = l || o, n === f && a === x || (t.blendEquationSeparate(i.convert(n), i.convert(a)), f = n, x = a), r === y && o === _ && s === b && l === w || (t.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(s), i.convert(l)), y = r, _ = o, b = s, w = l);
                    d = e, T = h
                }

                function J(e) {
                    E !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), E = e)
                }

                function K(e) {
                    e !== m ? (X(t.CULL_FACE), e !== A && (e === v ? t.cullFace(t.BACK) : e === g ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Y(t.CULL_FACE), A = e
                }

                function Q(e, i, n) {
                    e ? (X(t.POLYGON_OFFSET_FILL), R === i && P === n || (t.polygonOffset(i, n), R = i, P = n)) : Y(t.POLYGON_OFFSET_FILL)
                }

                function $(e) {
                    void 0 === e && (e = t.TEXTURE0 + L - 1), V !== e && (t.activeTexture(e), V = e)
                }
                return q[t.TEXTURE_2D] = W(t.TEXTURE_2D, t.TEXTURE_2D, 1), q[t.TEXTURE_CUBE_MAP] = W(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), X(t.DEPTH_TEST), r.setFunc(nt), J(!1), K(v), X(t.CULL_FACE), X(t.BLEND), Z(B), {
                    buffers: {
                        color: n,
                        depth: r,
                        stencil: o
                    },
                    initAttributes: function() {
                        for (var t = 0, e = s.length; t < e; t++) s[t] = 0
                    },
                    enableAttribute: function(i) {
                        s[i] = 1, 0 === l[i] && (t.enableVertexAttribArray(i), l[i] = 1), 0 !== h[i] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), h[i] = 0)
                    },
                    enableAttributeAndDivisor: function(i, n) {
                        s[i] = 1, 0 === l[i] && (t.enableVertexAttribArray(i), l[i] = 1), h[i] !== n && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, n), h[i] = n)
                    },
                    disableUnusedAttributes: function() {
                        for (var e = 0, i = l.length; e !== i; ++e) l[e] !== s[e] && (t.disableVertexAttribArray(e), l[e] = 0)
                    },
                    enable: X,
                    disable: Y,
                    getCompressedTextureFormats: function() {
                        if (null === u && (u = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                            for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++) u.push(i[n]);
                        return u
                    },
                    useProgram: function(e) {
                        return p !== e && (t.useProgram(e), p = e, !0)
                    },
                    setBlending: Z,
                    setMaterial: function(e, i) {
                        e.side === S ? Y(t.CULL_FACE) : X(t.CULL_FACE);
                        var o = e.side === M;
                        i && (o = !o), J(o), !0 === e.transparent ? Z(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : Z(O), r.setFunc(e.depthFunc), r.setTest(e.depthTest), r.setMask(e.depthWrite), n.setMask(e.colorWrite), Q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided: J,
                    setCullFace: K,
                    setLineWidth: function(e) {
                        e !== C && (D && t.lineWidth(e), C = e)
                    },
                    setPolygonOffset: Q,
                    setScissorTest: function(e) {
                        e ? X(t.SCISSOR_TEST) : Y(t.SCISSOR_TEST)
                    },
                    activeTexture: $,
                    bindTexture: function(e, i) {
                        null === V && $();
                        var n = H[V];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        }, H[V] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || q[e]), n.type = e, n.texture = i)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(e) {
                        !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e))
                    },
                    viewport: function(e) {
                        !1 === j.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), j.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < l.length; e++) 1 === l[e] && (t.disableVertexAttribArray(e), l[e] = 0);
                        c = {}, u = null, V = null, H = {}, p = null, d = null, E = null, A = null, n.reset(), r.reset(), o.reset()
                    }
                }
            }(p, d, H)).scissor(Q.copy(ft).multiplyScalar(ut)), y.viewport(K.copy(dt).multiplyScalar(ut)), _ = new function(t) {
                var e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(i, n, r) {
                        switch (r = r || 1, e.calls++, n) {
                            case t.TRIANGLES:
                                e.triangles += r * (i / 3);
                                break;
                            case t.TRIANGLE_STRIP:
                            case t.TRIANGLE_FAN:
                                e.triangles += r * (i - 2);
                                break;
                            case t.LINES:
                                e.lines += r * (i / 2);
                                break;
                            case t.LINE_STRIP:
                                e.lines += r * (i - 1);
                                break;
                            case t.LINE_LOOP:
                                e.lines += r * i;
                                break;
                            case t.POINTS:
                                e.points += r * i;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }(p), x = new function() {
                var t = new WeakMap;
                return {
                    get: function(e) {
                        var i = t.get(e);
                        return void 0 === i && (i = {}, t.set(e, i)), i
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, i, n) {
                        t.get(e)[i] = n
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }, b = new Cr(p, d, y, x, f, H, _), w = new function(t) {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(i) {
                        i.isInterleavedBufferAttribute && (i = i.data);
                        var n = e.get(i);
                        n && (t.deleteBuffer(n.buffer), e.delete(i))
                    },
                    update: function(i, n) {
                        i.isInterleavedBufferAttribute && (i = i.data);
                        var r = e.get(i);
                        void 0 === r ? e.set(i, function(e, i) {
                            var n = e.array,
                                r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                                o = t.createBuffer();
                            t.bindBuffer(i, o), t.bufferData(i, n, r), e.onUploadCallback();
                            var a = t.FLOAT;
                            return n instanceof Float32Array ? a = t.FLOAT : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = t.UNSIGNED_SHORT : n instanceof Int16Array ? a = t.SHORT : n instanceof Uint32Array ? a = t.UNSIGNED_INT : n instanceof Int32Array ? a = t.INT : n instanceof Int8Array ? a = t.BYTE : n instanceof Uint8Array && (a = t.UNSIGNED_BYTE), {
                                buffer: o,
                                type: a,
                                bytesPerElement: n.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(i, n)) : r.version < i.version && (function(e, i, n) {
                            var r = i.array,
                                o = i.updateRange;
                            t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, t.STATIC_DRAW) : -1 === o.count ? t.bufferSubData(n, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(r.buffer, i, n), r.version = i.version)
                    }
                }
            }(p), T = new function(t, e, i) {
                var n = {},
                    r = {};

                function o(t) {
                    var a = t.target,
                        s = n[a.id];
                    for (var l in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[l]);
                    a.removeEventListener("dispose", o), delete n[a.id];
                    var h = r[a.id];
                    h && (e.remove(h), delete r[a.id]), (h = r[s.id]) && (e.remove(h), delete r[s.id]), i.memory.geometries--
                }
                return {
                    get: function(t, e) {
                        var r = n[e.id];
                        return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Yi).setFromObject(t)), r = e._bufferGeometry), n[e.id] = r, i.memory.geometries++, r)
                    },
                    update: function(i) {
                        var n = i.index,
                            r = i.attributes;
                        for (var o in null !== n && e.update(n, t.ELEMENT_ARRAY_BUFFER), r) e.update(r[o], t.ARRAY_BUFFER);
                        var a = i.morphAttributes;
                        for (var o in a)
                            for (var s = a[o], l = 0, h = s.length; l < h; l++) e.update(s[l], t.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function(i) {
                        var n = r[i.id];
                        if (n) return n;
                        var o, a = [],
                            s = i.index,
                            l = i.attributes;
                        if (null !== s)
                            for (var h = 0, c = (o = s.array).length; h < c; h += 3) {
                                var u = o[h + 0],
                                    p = o[h + 1],
                                    d = o[h + 2];
                                a.push(u, p, p, d, d, u)
                            } else
                                for (h = 0, c = (o = l.position.array).length / 3 - 1; h < c; h += 3) u = h + 0, p = h + 1, d = h + 2, a.push(u, p, p, d, d, u);
                        return n = new(qi(a) > 65535 ? Hi : ki)(a, 1), e.update(n, t.ELEMENT_ARRAY_BUFFER), r[i.id] = n, n
                    }
                }
            }(p, w, _), E = new function(t, e) {
                var i = {};
                return {
                    update: function(n) {
                        var r = e.render.frame,
                            o = n.geometry,
                            a = t.get(n, o);
                        return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), t.update(a), i[a.id] = r), a
                    },
                    dispose: function() {
                        i = {}
                    }
                }
            }(T, _), D = new function(t) {
                var e = {},
                    i = new Float32Array(8);
                return {
                    update: function(n, r, o, a) {
                        var s = n.morphTargetInfluences,
                            l = s.length,
                            h = e[r.id];
                        if (void 0 === h) {
                            h = [];
                            for (var c = 0; c < l; c++) h[c] = [c, 0];
                            e[r.id] = h
                        }
                        var u = o.morphTargets && r.morphAttributes.position,
                            p = o.morphNormals && r.morphAttributes.normal;
                        for (c = 0; c < l; c++) 0 !== (d = h[c])[1] && (u && r.removeAttribute("morphTarget" + c), p && r.removeAttribute("morphNormal" + c));
                        for (c = 0; c < l; c++)(d = h[c])[0] = c, d[1] = s[c];
                        for (h.sort(mn), c = 0; c < 8; c++) {
                            var d;
                            if (d = h[c]) {
                                var f = d[0],
                                    m = d[1];
                                if (m) {
                                    u && r.addAttribute("morphTarget" + c, u[f]), p && r.addAttribute("morphNormal" + c, p[f]), i[c] = m;
                                    continue
                                }
                            }
                            i[c] = 0
                        }
                        a.getUniforms().setValue(t, "morphTargetInfluences", i)
                    }
                }
            }(p), A = new ur(G, d, f), C = new function() {
                var t = {};
                return {
                    get: function(e, i) {
                        var n = e.id + "," + i.id,
                            r = t[n];
                        return void 0 === r && (r = new function() {
                            var t = [],
                                e = 0,
                                i = [],
                                n = [];
                            return {
                                opaque: i,
                                transparent: n,
                                init: function() {
                                    e = 0, i.length = 0, n.length = 0
                                },
                                push: function(r, o, a, s, l) {
                                    var h = t[e];
                                    void 0 === h ? (h = {
                                        id: r.id,
                                        object: r,
                                        geometry: o,
                                        material: a,
                                        program: a.program,
                                        renderOrder: r.renderOrder,
                                        z: s,
                                        group: l
                                    }, t[e] = h) : (h.id = r.id, h.object = r, h.geometry = o, h.material = a, h.program = a.program, h.renderOrder = r.renderOrder, h.z = s, h.group = l), (!0 === a.transparent ? n : i).push(h), e++
                                },
                                sort: function() {
                                    i.length > 1 && i.sort(pr), n.length > 1 && n.sort(dr)
                                }
                            }
                        }, t[n] = r), r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }, P = new Tr, L = new function(t, e, i, n) {
                var r, o, a, s = new vi(0),
                    l = 0;

                function h(t, i) {
                    e.buffers.color.setClear(t.r, t.g, t.b, i, n)
                }
                return {
                    getClearColor: function() {
                        return s
                    },
                    setClearColor: function(t, e) {
                        s.set(t), h(s, l = void 0 !== e ? e : 1)
                    },
                    getClearAlpha: function() {
                        return l
                    },
                    setClearAlpha: function(t) {
                        h(s, l = t)
                    },
                    render: function(e, n, c, u) {
                        var p = n.background;
                        null === p ? h(s, l) : p && p.isColor && (h(p, 1), u = !0), (t.autoClear || u) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), p && p.isCubeTexture ? (void 0 === a && ((a = new fn(new Ji(1, 1, 1), new cn({
                            uniforms: _i.cube.uniforms,
                            vertexShader: _i.cube.vertexShader,
                            fragmentShader: _i.cube.fragmentShader,
                            side: M,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), a.geometry.removeAttribute("uv"), a.onBeforeRender = function(t, e, i) {
                            this.matrixWorld.copyPosition(i.matrixWorld)
                        }, i.update(a.geometry)), a.material.uniforms.tCube.value = p, e.push(a, a.geometry, a.material, 0, null)) : p && p.isTexture && (void 0 === r && (r = new Ri(-1, 1, 1, -1, 0, 1), o = new fn(new Qi(2, 2), new hn({
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), i.update(o.geometry)), o.material.map = p, t.renderBufferDirect(r, null, o.geometry, o.material, o, null))
                    }
                }
            }(G, y, T, s), U = new function(t, e, i) {
                var n;
                this.setMode = function(t) {
                    n = t
                }, this.render = function(e, r) {
                    t.drawArrays(n, e, r), i.update(r, n)
                }, this.renderInstances = function(t, r, o) {
                    var a = e.get("ANGLE_instanced_arrays");
                    if (null !== a) {
                        var s = t.attributes.position;
                        s.isInterleavedBufferAttribute ? (o = s.data.count, a.drawArraysInstancedANGLE(n, 0, o, t.maxInstancedCount)) : a.drawArraysInstancedANGLE(n, r, o, t.maxInstancedCount), i.update(o, n, t.maxInstancedCount)
                    } else console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                }
            }(p, d, _), k = new function(t, e, i) {
                var n, r, o;
                this.setMode = function(t) {
                    n = t
                }, this.setIndex = function(t) {
                    r = t.type, o = t.bytesPerElement
                }, this.render = function(e, a) {
                    t.drawElements(n, a, r, e * o), i.update(a, n)
                }, this.renderInstances = function(t, a, s) {
                    var l = e.get("ANGLE_instanced_arrays");
                    null !== l ? (l.drawElementsInstancedANGLE(n, s, r, a * o, t.maxInstancedCount), i.update(s, n, t.maxInstancedCount)) : console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                }
            }(p, d, _), V = new function(t, e, i, n, r) {
                var o, a, s, l, h, c, u = new Ye,
                    p = new Xe,
                    d = new Ye;

                function f() {
                    var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        i = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    o = e.createBuffer(), a = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, a), e.bufferData(e.ELEMENT_ARRAY_BUFFER, i, e.STATIC_DRAW), s = function() {
                        var t = e.createProgram(),
                            i = e.createShader(e.VERTEX_SHADER),
                            n = e.createShader(e.FRAGMENT_SHADER);
                        return e.shaderSource(i, ["precision " + r.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 center;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = ( position - center ) * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")), e.shaderSource(n, ["precision " + r.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")), e.compileShader(i), e.compileShader(n), e.attachShader(t, i), e.attachShader(t, n), e.linkProgram(t), t
                    }(), l = {
                        position: e.getAttribLocation(s, "position"),
                        uv: e.getAttribLocation(s, "uv")
                    }, h = {
                        uvOffset: e.getUniformLocation(s, "uvOffset"),
                        uvScale: e.getUniformLocation(s, "uvScale"),
                        rotation: e.getUniformLocation(s, "rotation"),
                        center: e.getUniformLocation(s, "center"),
                        scale: e.getUniformLocation(s, "scale"),
                        color: e.getUniformLocation(s, "color"),
                        map: e.getUniformLocation(s, "map"),
                        opacity: e.getUniformLocation(s, "opacity"),
                        modelViewMatrix: e.getUniformLocation(s, "modelViewMatrix"),
                        projectionMatrix: e.getUniformLocation(s, "projectionMatrix"),
                        fogType: e.getUniformLocation(s, "fogType"),
                        fogDensity: e.getUniformLocation(s, "fogDensity"),
                        fogNear: e.getUniformLocation(s, "fogNear"),
                        fogFar: e.getUniformLocation(s, "fogFar"),
                        fogColor: e.getUniformLocation(s, "fogColor"),
                        fogDepth: e.getUniformLocation(s, "fogDepth"),
                        alphaTest: e.getUniformLocation(s, "alphaTest")
                    };
                    var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    n.width = 8, n.height = 8;
                    var u = n.getContext("2d");
                    u.fillStyle = "white", u.fillRect(0, 0, 8, 8), c = new Ar(n)
                }

                function m(t, e) {
                    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
                }
                this.render = function(r, v, g) {
                    if (0 !== r.length) {
                        void 0 === s && f(), i.useProgram(s), i.initAttributes(), i.enableAttribute(l.position), i.enableAttribute(l.uv), i.disableUnusedAttributes(), i.disable(e.CULL_FACE), i.enable(e.BLEND), e.bindBuffer(e.ARRAY_BUFFER, o), e.vertexAttribPointer(l.position, 2, e.FLOAT, !1, 16, 0), e.vertexAttribPointer(l.uv, 2, e.FLOAT, !1, 16, 8), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, a), e.uniformMatrix4fv(h.projectionMatrix, !1, g.projectionMatrix.elements), i.activeTexture(e.TEXTURE0), e.uniform1i(h.map, 0);
                        var y = 0,
                            _ = 0,
                            x = v.fog;
                        x ? (e.uniform3f(h.fogColor, x.color.r, x.color.g, x.color.b), x.isFog ? (e.uniform1f(h.fogNear, x.near), e.uniform1f(h.fogFar, x.far), e.uniform1i(h.fogType, 1), y = 1, _ = 1) : x.isFogExp2 && (e.uniform1f(h.fogDensity, x.density), e.uniform1i(h.fogType, 2), y = 2, _ = 2)) : (e.uniform1i(h.fogType, 0), y = 0, _ = 0);
                        for (var b = 0, w = r.length; b < w; b++)(M = r[b]).modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, M.matrixWorld), M.z = -M.modelViewMatrix.elements[14];
                        r.sort(m);
                        var T = [],
                            E = [];
                        for (b = 0, w = r.length; b < w; b++) {
                            var M, S = (M = r[b]).material;
                            if (!1 !== S.visible) {
                                M.onBeforeRender(t, v, g, void 0, S, void 0), e.uniform1f(h.alphaTest, S.alphaTest), e.uniformMatrix4fv(h.modelViewMatrix, !1, M.modelViewMatrix.elements), M.matrixWorld.decompose(u, p, d), T[0] = d.x, T[1] = d.y, E[0] = M.center.x - .5, E[1] = M.center.y - .5;
                                var A = 0;
                                v.fog && S.fog && (A = _), y !== A && (e.uniform1i(h.fogType, A), y = A), null !== S.map ? (e.uniform2f(h.uvOffset, S.map.offset.x, S.map.offset.y), e.uniform2f(h.uvScale, S.map.repeat.x, S.map.repeat.y)) : (e.uniform2f(h.uvOffset, 0, 0), e.uniform2f(h.uvScale, 1, 1)), e.uniform1f(h.opacity, S.opacity), e.uniform3f(h.color, S.color.r, S.color.g, S.color.b), e.uniform1f(h.rotation, S.rotation), e.uniform2fv(h.center, E), e.uniform2fv(h.scale, T), i.setBlending(S.blending, S.blendEquation, S.blendSrc, S.blendDst, S.blendEquationAlpha, S.blendSrcAlpha, S.blendDstAlpha, S.premultipliedAlpha), i.buffers.depth.setTest(S.depthTest), i.buffers.depth.setMask(S.depthWrite), i.buffers.color.setMask(S.colorWrite), n.setTexture2D(S.map || c, 0), e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0), M.onAfterRender(t, v, g, void 0, S, void 0)
                            }
                        }
                        i.enable(e.CULL_FACE), i.reset()
                    }
                }
            }(G, p, y, b, f), _.programs = A.programs, G.context = p, G.capabilities = f, G.extensions = d, G.properties = x, G.renderLists = C, G.state = y, G.info = _
        }
        Et();
        var Mt = new Or(G);
        this.vr = Mt;
        var St = new Sr(G, E, f.maxTextureSize);

        function At(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), j = !0
        }

        function Ct() {
            console.log("THREE.WebGLRenderer: Context Restored."), j = !1, Et()
        }

        function Rt(t) {
            var e = t.target;
            e.removeEventListener("dispose", Rt),
                function(t) {
                    Pt(t), x.remove(t)
                }(e)
        }

        function Pt(t) {
            var e = x.get(t).program;
            t.program = void 0, void 0 !== e && A.releaseProgram(e)
        }
        this.shadowMap = St, this.getContext = function() {
            return p
        }, this.getContextAttributes = function() {
            return p.getContextAttributes()
        }, this.forceContextLoss = function() {
            var t = d.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function() {
            var t = d.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function() {
            return ut
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (ut = t, this.setSize(ht, ct, !1))
        }, this.getSize = function() {
            return {
                width: ht,
                height: ct
            }
        }, this.setSize = function(t, i, n) {
            var r = Mt.getDevice();
            r && r.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (ht = t, ct = i, e.width = t * ut, e.height = i * ut, !1 !== n && (e.style.width = t + "px", e.style.height = i + "px"), this.setViewport(0, 0, t, i))
        }, this.getDrawingBufferSize = function() {
            return {
                width: ht * ut,
                height: ct * ut
            }
        }, this.setDrawingBufferSize = function(t, i, n) {
            ht = t, ct = i, ut = n, e.width = t * n, e.height = i * n, this.setViewport(0, 0, t, i)
        }, this.getCurrentViewport = function() {
            return K
        }, this.setViewport = function(t, e, i, n) {
            dt.set(t, ct - e - n, i, n), y.viewport(K.copy(dt).multiplyScalar(ut))
        }, this.setScissor = function(t, e, i, n) {
            ft.set(t, ct - e - n, i, n), y.scissor(Q.copy(ft).multiplyScalar(ut))
        }, this.setScissorTest = function(t) {
            y.setScissorTest(mt = t)
        }, this.getClearColor = function() {
            return L.getClearColor()
        }, this.setClearColor = function() {
            L.setClearColor.apply(L, arguments)
        }, this.getClearAlpha = function() {
            return L.getClearAlpha()
        }, this.setClearAlpha = function() {
            L.setClearAlpha.apply(L, arguments)
        }, this.clear = function(t, e, i) {
            var n = 0;
            (void 0 === t || t) && (n |= p.COLOR_BUFFER_BIT), (void 0 === e || e) && (n |= p.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= p.STENCIL_BUFFER_BIT), p.clear(n)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.clearTarget = function(t, e, i, n) {
            this.setRenderTarget(t), this.clear(e, i, n)
        }, this.dispose = function() {
            e.removeEventListener("webglcontextlost", At, !1), e.removeEventListener("webglcontextrestored", Ct, !1), C.dispose(), P.dispose(), x.dispose(), E.dispose(), Mt.dispose(), Nt()
        }, this.renderBufferImmediate = function(t, e, i) {
            y.initAttributes();
            var n = x.get(t);
            t.hasPositions && !n.position && (n.position = p.createBuffer()), t.hasNormals && !n.normal && (n.normal = p.createBuffer()), t.hasUvs && !n.uv && (n.uv = p.createBuffer()), t.hasColors && !n.color && (n.color = p.createBuffer());
            var r = e.getAttributes();
            if (t.hasPositions && (p.bindBuffer(p.ARRAY_BUFFER, n.position), p.bufferData(p.ARRAY_BUFFER, t.positionArray, p.DYNAMIC_DRAW), y.enableAttribute(r.position), p.vertexAttribPointer(r.position, 3, p.FLOAT, !1, 0, 0)), t.hasNormals) {
                if (p.bindBuffer(p.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && !0 === i.flatShading)
                    for (var o = 0, a = 3 * t.count; o < a; o += 9) {
                        var s = t.normalArray,
                            l = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
                            h = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
                            c = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                        s[o + 0] = l, s[o + 1] = h, s[o + 2] = c, s[o + 3] = l, s[o + 4] = h, s[o + 5] = c, s[o + 6] = l, s[o + 7] = h, s[o + 8] = c
                    }
                p.bufferData(p.ARRAY_BUFFER, t.normalArray, p.DYNAMIC_DRAW), y.enableAttribute(r.normal), p.vertexAttribPointer(r.normal, 3, p.FLOAT, !1, 0, 0)
            }
            t.hasUvs && i.map && (p.bindBuffer(p.ARRAY_BUFFER, n.uv), p.bufferData(p.ARRAY_BUFFER, t.uvArray, p.DYNAMIC_DRAW), y.enableAttribute(r.uv), p.vertexAttribPointer(r.uv, 2, p.FLOAT, !1, 0, 0)), t.hasColors && i.vertexColors !== R && (p.bindBuffer(p.ARRAY_BUFFER, n.color), p.bufferData(p.ARRAY_BUFFER, t.colorArray, p.DYNAMIC_DRAW), y.enableAttribute(r.color), p.vertexAttribPointer(r.color, 3, p.FLOAT, !1, 0, 0)), y.disableUnusedAttributes(), p.drawArrays(p.TRIANGLES, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function(t, e, i, n, r, o) {
            var a = r.isMesh && r.matrixWorld.determinant() < 0;
            y.setMaterial(n, a);
            var s = Gt(t, e, n, r),
                l = i.id + "_" + s.id + "_" + (!0 === n.wireframe),
                h = !1;
            l !== Y && (Y = l, h = !0), r.morphTargetInfluences && (D.update(r, i, n, s), h = !0);
            var c, u = i.index,
                f = i.attributes.position,
                m = 1;
            !0 === n.wireframe && (u = T.getWireframeAttribute(i), m = 2);
            var v = U;
            null !== u && (c = w.get(u), (v = k).setIndex(c)), h && (function(t, e, i) {
                if (i && i.isInstancedBufferGeometry && null === d.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    y.initAttributes();
                    var n = i.attributes,
                        r = e.getAttributes(),
                        o = t.defaultAttributeValues;
                    for (var a in r) {
                        var s = r[a];
                        if (s >= 0) {
                            var l = n[a];
                            if (void 0 !== l) {
                                var h = l.normalized,
                                    c = l.itemSize,
                                    u = w.get(l);
                                if (void 0 === u) continue;
                                var f = u.buffer,
                                    m = u.type,
                                    v = u.bytesPerElement;
                                if (l.isInterleavedBufferAttribute) {
                                    var g = l.data,
                                        _ = g.stride,
                                        x = l.offset;
                                    g && g.isInstancedInterleavedBuffer ? (y.enableAttributeAndDivisor(s, g.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = g.meshPerAttribute * g.count)) : y.enableAttribute(s), p.bindBuffer(p.ARRAY_BUFFER, f), p.vertexAttribPointer(s, c, m, h, _ * v, x * v)
                                } else l.isInstancedBufferAttribute ? (y.enableAttributeAndDivisor(s, l.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : y.enableAttribute(s), p.bindBuffer(p.ARRAY_BUFFER, f), p.vertexAttribPointer(s, c, m, h, 0, 0)
                            } else if (void 0 !== o) {
                                var b = o[a];
                                if (void 0 !== b) switch (b.length) {
                                    case 2:
                                        p.vertexAttrib2fv(s, b);
                                        break;
                                    case 3:
                                        p.vertexAttrib3fv(s, b);
                                        break;
                                    case 4:
                                        p.vertexAttrib4fv(s, b);
                                        break;
                                    default:
                                        p.vertexAttrib1fv(s, b)
                                }
                            }
                        }
                    }
                    y.disableUnusedAttributes()
                }
            }(n, s, i), null !== u && p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, c.buffer));
            var g = 1 / 0;
            null !== u ? g = u.count : void 0 !== f && (g = f.count);
            var _ = i.drawRange.start * m,
                x = i.drawRange.count * m,
                b = null !== o ? o.start * m : 0,
                E = null !== o ? o.count * m : 1 / 0,
                M = Math.max(_, b),
                S = Math.min(g, _ + x, b + E) - 1,
                A = Math.max(0, S - M + 1);
            if (0 !== A) {
                if (r.isMesh)
                    if (!0 === n.wireframe) y.setLineWidth(n.wireframeLinewidth * wt()), v.setMode(p.LINES);
                    else switch (r.drawMode) {
                        case Le:
                            v.setMode(p.TRIANGLES);
                            break;
                        case Oe:
                            v.setMode(p.TRIANGLE_STRIP);
                            break;
                        case Be:
                            v.setMode(p.TRIANGLE_FAN)
                    } else if (r.isLine) {
                        var C = n.linewidth;
                        void 0 === C && (C = 1), y.setLineWidth(C * wt()), r.isLineSegments ? v.setMode(p.LINES) : r.isLineLoop ? v.setMode(p.LINE_LOOP) : v.setMode(p.LINE_STRIP)
                    } else r.isPoints && v.setMode(p.POINTS);
                i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && v.renderInstances(i, M, A) : v.render(M, A)
            }
        }, this.compile = function(t, e) {
            (u = P.get(t, e)).init(), t.traverse(function(t) {
                t.isLight && (u.pushLight(t), t.castShadow && u.pushShadow(t))
            }), u.setupLights(e), t.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var i = 0; i < e.material.length; i++) Ht(e.material[i], t.fog, e);
                    else Ht(e.material, t.fog, e)
            })
        };
        var Lt, Ot = !1,
            It = null;

        function Nt() {
            Ot = !1
        }

        function zt() {
            var t = Mt.getDevice();
            t && t.isPresenting ? t.requestAnimationFrame(Ft) : window.requestAnimationFrame(Ft)
        }

        function Ft(t) {
            !1 !== Ot && (It(t), zt())
        }

        function Dt(t, e, i, n) {
            for (var r = 0, o = t.length; r < o; r++) {
                var a = t[r],
                    s = a.object,
                    l = a.geometry,
                    h = void 0 === n ? a.material : n,
                    c = a.group;
                if (i.isArrayCamera) {
                    J = i;
                    for (var u = i.cameras, p = 0, d = u.length; p < d; p++) {
                        var f = u[p];
                        if (s.layers.test(f.layers)) {
                            var m = f.bounds,
                                v = m.x * ht,
                                g = m.y * ct,
                                _ = m.z * ht,
                                x = m.w * ct;
                            y.viewport(K.set(v, g, _, x).multiplyScalar(ut)), Vt(s, e, f, l, h, c)
                        }
                    }
                } else J = null, Vt(s, e, i, l, h, c)
            }
        }

        function Vt(t, e, i, n, r, o) {
            if (t.onBeforeRender(G, e, i, n, r, o), u = P.get(e, J || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                var a = t.isMesh && t.matrixWorld.determinant() < 0;
                y.setMaterial(r, a);
                var s = Gt(i, e.fog, r, t);
                Y = "",
                    function(t, e, i) {
                        t.render(function(t) {
                            G.renderBufferImmediate(t, e, i)
                        })
                    }(t, s, r)
            } else G.renderBufferDirect(i, e.fog, n, r, t, o);
            t.onAfterRender(G, e, i, n, r, o), u = P.get(e, J || i)
        }

        function Ht(t, e, i) {
            var n = x.get(t),
                r = u.state.lights,
                o = u.state.shadowsArray,
                a = A.getParameters(t, r.state, o, e, gt.numPlanes, gt.numIntersection, i),
                s = A.getProgramCode(t, a),
                l = n.program,
                h = !0;
            if (void 0 === l) t.addEventListener("dispose", Rt);
            else if (l.code !== s) Pt(t);
            else if (n.lightsHash !== r.state.hash) x.update(t, "lightsHash", r.state.hash), h = !1;
            else {
                if (void 0 !== a.shaderID) return;
                h = !1
            }
            if (h) {
                if (a.shaderID) {
                    var c = _i[a.shaderID];
                    n.shader = {
                        name: t.type,
                        uniforms: fi.clone(c.uniforms),
                        vertexShader: c.vertexShader,
                        fragmentShader: c.fragmentShader
                    }
                } else n.shader = {
                    name: t.type,
                    uniforms: t.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                };
                t.onBeforeCompile(n.shader, G), l = A.acquireProgram(t, n.shader, a, s), n.program = l, t.program = l
            }
            var p = l.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var d = 0; d < G.maxMorphTargets; d++) p["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals)
                for (t.numSupportedMorphNormals = 0, d = 0; d < G.maxMorphNormals; d++) p["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++;
            var f = n.shader.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = gt.numPlanes, n.numIntersection = gt.numIntersection, f.clippingPlanes = gt.uniform), n.fog = e, n.lightsHash = r.state.hash, t.lights && (f.ambientLightColor && (f.ambientLightColor.value = r.state.ambient), f.directionalLights && (f.directionalLights.value = r.state.directional), f.spotLights && (f.spotLights.value = r.state.spot), f.rectAreaLights && (f.rectAreaLights.value = r.state.rectArea), f.pointLights && (f.pointLights.value = r.state.point), f.hemisphereLights && (f.hemisphereLights.value = r.state.hemi), f.directionalShadowMap && (f.directionalShadowMap.value = r.state.directionalShadowMap), f.directionalShadowMatrix && (f.directionalShadowMatrix.value = r.state.directionalShadowMatrix), f.spotShadowMap && (f.spotShadowMap.value = r.state.spotShadowMap), f.spotShadowMatrix && (f.spotShadowMatrix.value = r.state.spotShadowMatrix), f.pointShadowMap && (f.pointShadowMap.value = r.state.pointShadowMap), f.pointShadowMatrix && (f.pointShadowMatrix.value = r.state.pointShadowMatrix));
            var m = n.program.getUniforms(),
                v = er.seqWithValue(m.seq, f);
            n.uniformsList = v
        }

        function Gt(t, e, i, n) {
            lt = 0;
            var r = x.get(i),
                o = u.state.lights;
            if (yt && (_t || t !== Z)) {
                var a = t === Z && i.id === X;
                gt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, a)
            }!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : i.lights && r.lightsHash !== o.state.hash ? i.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === gt.numPlanes && r.numIntersection === gt.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (Ht(i, e, n), i.needsUpdate = !1);
            var s = !1,
                l = !1,
                h = !1,
                c = r.program,
                d = c.getUniforms(),
                m = r.shader.uniforms;
            if (y.useProgram(c.program) && (s = !0, l = !0, h = !0), i.id !== X && (X = i.id, l = !0), s || t !== Z) {
                if (d.setValue(p, "projectionMatrix", t.projectionMatrix), f.logarithmicDepthBuffer && d.setValue(p, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), Z !== (J || t) && (Z = J || t, l = !0, h = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                    var v = d.map.cameraPosition;
                    void 0 !== v && v.setValue(p, bt.setFromMatrixPosition(t.matrixWorld))
                }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && d.setValue(p, "viewMatrix", t.matrixWorldInverse)
            }
            if (i.skinning) {
                d.setOptional(p, n, "bindMatrix"), d.setOptional(p, n, "bindMatrixInverse");
                var g = n.skeleton;
                if (g) {
                    var _ = g.bones;
                    if (g.useTexture && f.floatVertexTextures) {
                        if (void 0 === g.boneTexture) {
                            var b = Math.sqrt(4 * _.length);
                            b = je.ceilPowerOfTwo(b), b = Math.max(b, 4);
                            var w = new Float32Array(b * b * 4);
                            w.set(g.boneMatrices);
                            var T = new si(w, b, b, Xt, Ut);
                            T.needsUpdate = !0, g.boneMatrices = w, g.boneTexture = T, g.boneTextureSize = b
                        }
                        d.setValue(p, "boneTexture", g.boneTexture), d.setValue(p, "boneTextureSize", g.boneTextureSize)
                    } else d.setOptional(p, g, "boneMatrices")
                }
            }
            return l && (d.setValue(p, "toneMappingExposure", G.toneMappingExposure), d.setValue(p, "toneMappingWhitePoint", G.toneMappingWhitePoint), i.lights && function(t, e) {
                t.ambientLightColor && (t.ambientLightColor.needsUpdate = e), t.directionalLights && (t.directionalLights.needsUpdate = e), t.pointLights && (t.pointLights.needsUpdate = e), t.spotLights && (t.spotLights.needsUpdate = e), t.rectAreaLights && (t.rectAreaLights.needsUpdate = e), t.hemisphereLights && (t.hemisphereLights.needsUpdate = e)
            }(m, h), e && i.fog && function(t, e) {
                t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }(m, e), i.isMeshBasicMaterial ? jt(m, i) : i.isMeshLambertMaterial ? (jt(m, i), function(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(m, i)) : i.isMeshPhongMaterial ? (jt(m, i), i.isMeshToonMaterial ? function(t, e) {
                Wt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }(m, i) : Wt(m, i)) : i.isMeshStandardMaterial ? (jt(m, i), i.isMeshPhysicalMaterial ? function(t, e) {
                t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness, qt(t, e)
            }(m, i) : qt(m, i)) : i.isMeshDepthMaterial ? (jt(m, i), function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(m, i)) : i.isMeshDistanceMaterial ? (jt(m, i), function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
            }(m, i)) : i.isMeshNormalMaterial ? (jt(m, i), function(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }(m, i)) : i.isLineBasicMaterial ? (function(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity
            }(m, i), i.isLineDashedMaterial && function(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }(m, i)) : i.isPointsMaterial ? function(t, e) {
                if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * ut, t.scale.value = .5 * ct, t.map.value = e.map, null !== e.map) {
                    if (!0 === e.map.matrixAutoUpdate) {
                        var i = e.map.offset,
                            n = e.map.repeat,
                            r = e.map.rotation,
                            o = e.map.center;
                        e.map.matrix.setUvTransform(i.x, i.y, n.x, n.y, r, o.x, o.y)
                    }
                    t.uvTransform.value.copy(e.map.matrix)
                }
            }(m, i) : i.isShadowMaterial && (m.color.value = i.color, m.opacity.value = i.opacity), void 0 !== m.ltc_1 && (m.ltc_1.value = yi.LTC_1), void 0 !== m.ltc_2 && (m.ltc_2.value = yi.LTC_2), er.upload(p, r.uniformsList, m, G)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (er.upload(p, r.uniformsList, m, G), i.uniformsNeedUpdate = !1), d.setValue(p, "modelViewMatrix", n.modelViewMatrix), d.setValue(p, "normalMatrix", n.normalMatrix), d.setValue(p, "modelMatrix", n.matrixWorld), c
        }

        function jt(t, e) {
            var i;
            if (t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = x.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i) {
                if (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate) {
                    var n = i.offset,
                        r = i.repeat,
                        o = i.rotation,
                        a = i.center;
                    i.matrix.setUvTransform(n.x, n.y, r.x, r.y, o, a.x, a.y)
                }
                t.uvTransform.value.copy(i.matrix)
            }
        }

        function Wt(t, e) {
            t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }

        function qt(t, e) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }
        this.animate = function(t) {
            null !== (It = t) ? Ot || (zt(), Ot = !0) : Nt()
        }, this.render = function(t, e, i, n) {
            if (e && e.isCamera) {
                if (!j) {
                    Y = "", X = -1, Z = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Mt.enabled && (e = Mt.getCamera(e)), (u = P.get(t, e)).init(), t.onBeforeRender(G, t, e, i), xt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), vt.setFromMatrix(xt), _t = this.localClippingEnabled, yt = gt.init(this.clippingPlanes, _t, e), (c = C.get(t, e)).init(),
                        function t(e, i, n) {
                            if (!1 !== e.visible) {
                                if (e.layers.test(i.layers))
                                    if (e.isLight) u.pushLight(e), e.castShadow && u.pushShadow(e);
                                    else if (e.isSprite) e.frustumCulled && !vt.intersectsSprite(e) || u.pushSprite(e);
                                else if (e.isImmediateRenderObject) n && bt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(xt), c.push(e, null, e.material, bt.z, null);
                                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || vt.intersectsObject(e))) {
                                    n && bt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(xt);
                                    var r = E.update(e),
                                        o = e.material;
                                    if (Array.isArray(o))
                                        for (var a = r.groups, s = 0, l = a.length; s < l; s++) {
                                            var h = a[s],
                                                p = o[h.materialIndex];
                                            p && p.visible && c.push(e, r, p, bt.z, h)
                                        } else o.visible && c.push(e, r, o, bt.z, null)
                                }
                                var d = e.children;
                                for (s = 0, l = d.length; s < l; s++) t(d[s], i, n)
                            }
                        }(t, e, G.sortObjects), !0 === G.sortObjects && c.sort(), yt && gt.beginShadows();
                    var r = u.state.shadowsArray;
                    St.render(r, t, e), u.setupLights(e), yt && gt.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), L.render(c, t, e, n);
                    var o = c.opaque,
                        a = c.transparent;
                    if (t.overrideMaterial) {
                        var s = t.overrideMaterial;
                        o.length && Dt(o, t, e, s), a.length && Dt(a, t, e, s)
                    } else o.length && Dt(o, t, e), a.length && Dt(a, t, e);
                    var l = u.state.spritesArray;
                    V.render(l, t, e), i && b.updateRenderTargetMipmap(i), y.buffers.depth.setTest(!0), y.buffers.depth.setMask(!0), y.buffers.color.setMask(!0), y.setPolygonOffset(!1), t.onAfterRender(G, t, e), Mt.enabled && Mt.submitFrame(), c = null, u = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.allocTextureUnit = function() {
            var t = lt;
            return t >= f.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + f.maxTextures), lt += 1, t
        }, this.setTexture2D = (Lt = !1, function(t, e) {
            t && t.isWebGLRenderTarget && (Lt || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), Lt = !0), t = t.texture), b.setTexture2D(t, e)
        }), this.setTexture = function() {
            var t = !1;
            return function(e, i) {
                t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), b.setTexture2D(e, i)
            }
        }(), this.setTextureCube = function() {
            var t = !1;
            return function(e, i) {
                e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? b.setTextureCube(e, i) : b.setTextureCubeDynamic(e, i)
            }
        }(), this.getRenderTarget = function() {
            return W
        }, this.setRenderTarget = function(t) {
            W = t, t && void 0 === x.get(t).__webglFramebuffer && b.setupRenderTarget(t);
            var e = null,
                i = !1;
            if (t) {
                var n = x.get(t).__webglFramebuffer;
                t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, K.copy(t.viewport), Q.copy(t.scissor), $ = t.scissorTest
            } else K.copy(dt).multiplyScalar(ut), Q.copy(ft).multiplyScalar(ut), $ = mt;
            if (q !== e && (p.bindFramebuffer(p.FRAMEBUFFER, e), q = e), y.viewport(K), y.scissor(Q), y.setScissorTest($), i) {
                var r = x.get(t.texture);
                p.framebufferTexture2D(p.FRAMEBUFFER, p.COLOR_ATTACHMENT0, p.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
            }
        }, this.readRenderTargetPixels = function(t, e, i, n, r, o) {
            if (t && t.isWebGLRenderTarget) {
                var a = x.get(t).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== q && (p.bindFramebuffer(p.FRAMEBUFFER, a), s = !0);
                    try {
                        var l = t.texture,
                            h = l.format,
                            c = l.type;
                        if (h !== Xt && H.convert(h) !== p.getParameter(p.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(c === Bt || H.convert(c) === p.getParameter(p.IMPLEMENTATION_COLOR_READ_TYPE) || c === Ut && (d.get("OES_texture_float") || d.get("WEBGL_color_buffer_float")) || c === kt && d.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        p.checkFramebufferStatus(p.FRAMEBUFFER) === p.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && p.readPixels(e, i, n, r, H.convert(h), H.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && p.bindFramebuffer(p.FRAMEBUFFER, q)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function(t, e, i) {
            var n = e.image.width,
                r = e.image.height,
                o = H.convert(e.format);
            this.setTexture2D(e, 0), p.copyTexImage2D(p.TEXTURE_2D, i || 0, o, t.x, t.y, n, r, 0)
        }, this.copyTextureToTexture = function(t, e, i, n) {
            var r = e.image.width,
                o = e.image.height,
                a = H.convert(i.format),
                s = H.convert(i.type),
                l = e.isDataTexture ? e.image.data : e.image;
            this.setTexture2D(i, 0), p.texSubImage2D(p.TEXTURE_2D, n || 0, t.x, t.y, r, o, a, s, l)
        }
    }

    function Ir(t, e) {
        this.name = "", this.color = new vi(t), this.density = void 0 !== e ? e : 25e-5
    }

    function Nr(t, e, i) {
        this.name = "", this.color = new vi(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
    }

    function zr() {
        Ai.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
    }

    function Fr(t) {
        ln.call(this), this.type = "SpriteMaterial", this.color = new vi(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t)
    }

    function Dr(t) {
        Ai.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new Fr, this.center = new We(.5, .5)
    }

    function Ur() {
        Ai.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }

    function kr(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.useTexture = !1, void 0 === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new qe)
        }
    }

    function Vr() {
        Ai.call(this), this.type = "Bone"
    }

    function Hr(t, e) {
        fn.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new qe, this.bindMatrixInverse = new qe;
        var i = new kr(this.initBones());
        this.bind(i, this.matrixWorld), this.normalizeSkinWeights()
    }

    function Gr(t) {
        ln.call(this), this.type = "LineBasicMaterial", this.color = new vi(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
    }

    function jr(t, e, i) {
        if (1 === i) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new Wr(t, e);
        Ai.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Yi, this.material = void 0 !== e ? e : new Gr({
            color: 16777215 * Math.random()
        })
    }

    function Wr(t, e) {
        jr.call(this, t, e), this.type = "LineSegments"
    }

    function qr(t, e) {
        jr.call(this, t, e), this.type = "LineLoop"
    }

    function Xr(t) {
        ln.call(this), this.type = "PointsMaterial", this.color = new vi(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
    }

    function Yr(t, e) {
        Ai.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Yi, this.material = void 0 !== e ? e : new Xr({
            color: 16777215 * Math.random()
        })
    }

    function Zr() {
        Ai.call(this), this.type = "Group"
    }

    function Jr(t, e, i, n, r, o, a, s, l) {
        ni.call(this, t, e, i, n, r, o, a, s, l), this.generateMipmaps = !1
    }

    function Kr(t, e, i, n, r, o, a, s, l, h, c, u) {
        ni.call(this, null, o, a, s, l, h, n, r, c, u), this.image = {
            width: e,
            height: i
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
    }

    function Qr(t, e, i, n, r, o, a, s, l, h) {
        if ((h = void 0 !== h ? h : Kt) !== Kt && h !== Qt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && h === Kt && (i = zt), void 0 === i && h === Qt && (i = jt), ni.call(this, null, n, r, o, a, s, h, i, l), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== a ? a : At, this.minFilter = void 0 !== s ? s : At, this.flipY = !1, this.generateMipmaps = !1
    }

    function $r(t) {
        t = t || {}, this.mapping = void 0 !== t.mapping ? t.mapping : $r.DEFAULT_MAPPING, this.wrapS = void 0 !== t.wrapS ? t.wrapS : Mt, this.wrapT = void 0 !== t.wrapT ? t.wrapT : Mt, this.magFilter = void 0 !== t.magFilter ? t.magFilter : Pt, this.minFilter = void 0 !== t.minFilter ? t.minFilter : Ot, this.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, this.format = void 0 !== t.format ? t.format : Xt, this.type = void 0 !== t.type ? t.type : Bt, this.encoding = void 0 !== t.encoding ? t.encoding : Ie, this.offset = new We(0, 0), void 0 !== t.offset && this.offset.copy(t.offset), this.repeat = new We(1, 1), void 0 !== t.repeat && this.repeat.copy(t.repeat), this.center = new We(0, 0), void 0 !== t.center && this.center.copy(t.center), this.rotation = 0, this.generateMipmaps = void 0 === t.generateMipmaps || t.generateMipmaps
    }

    function to(t) {
        Yi.call(this), this.type = "WireframeGeometry";
        var e, i, n, r, o, a, s, l, h, c, u = [],
            p = [0, 0],
            d = {},
            f = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var m = t.faces;
            for (e = 0, n = m.length; e < n; e++) {
                var v = m[e];
                for (i = 0; i < 3; i++) s = v[f[i]], l = v[f[(i + 1) % 3]], p[0] = Math.min(s, l), p[1] = Math.max(s, l), void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                    index1: p[0],
                    index2: p[1]
                })
            }
            for (h in d) a = d[h], c = t.vertices[a.index1], u.push(c.x, c.y, c.z), c = t.vertices[a.index2], u.push(c.x, c.y, c.z)
        } else if (t && t.isBufferGeometry) {
            var g, y, _, x, b, w, T;
            if (c = new Ye, null !== t.index) {
                for (g = t.attributes.position, y = t.index, 0 === (_ = t.groups).length && (_ = [{
                        start: 0,
                        count: y.count,
                        materialIndex: 0
                    }]), r = 0, o = _.length; r < o; ++r)
                    for (e = b = (x = _[r]).start, n = b + x.count; e < n; e += 3)
                        for (i = 0; i < 3; i++) s = y.getX(e + i), l = y.getX(e + (i + 1) % 3), p[0] = Math.min(s, l), p[1] = Math.max(s, l), void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                            index1: p[0],
                            index2: p[1]
                        });
                for (h in d) a = d[h], c.fromBufferAttribute(g, a.index1), u.push(c.x, c.y, c.z), c.fromBufferAttribute(g, a.index2), u.push(c.x, c.y, c.z)
            } else
                for (e = 0, n = (g = t.attributes.position).count / 3; e < n; e++)
                    for (i = 0; i < 3; i++) w = 3 * e + i, c.fromBufferAttribute(g, w), u.push(c.x, c.y, c.z), T = 3 * e + (i + 1) % 3, c.fromBufferAttribute(g, T), u.push(c.x, c.y, c.z)
        }
        this.addAttribute("position", new Gi(u, 3))
    }

    function eo(t, e, i) {
        Ii.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: i
        }, this.fromBufferGeometry(new io(t, e, i)), this.mergeVertices()
    }

    function io(t, e, i) {
        Yi.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: i
        };
        var n, r, o = [],
            a = [],
            s = [],
            l = [],
            h = new Ye,
            c = new Ye,
            u = new Ye,
            p = new Ye,
            d = new Ye,
            f = e + 1;
        for (n = 0; n <= i; n++) {
            var m = n / i;
            for (r = 0; r <= e; r++) {
                var v = r / e;
                t(v, m, c), a.push(c.x, c.y, c.z), v - 1e-5 >= 0 ? (t(v - 1e-5, m, u), p.subVectors(c, u)) : (t(v + 1e-5, m, u), p.subVectors(u, c)), m - 1e-5 >= 0 ? (t(v, m - 1e-5, u), d.subVectors(c, u)) : (t(v, m + 1e-5, u), d.subVectors(u, c)), h.crossVectors(p, d).normalize(), s.push(h.x, h.y, h.z), l.push(v, m)
            }
        }
        for (n = 0; n < i; n++)
            for (r = 0; r < e; r++) {
                var g = n * f + r,
                    y = n * f + r + 1,
                    _ = (n + 1) * f + r + 1,
                    x = (n + 1) * f + r;
                o.push(g, y, x), o.push(y, _, x)
            }
        this.setIndex(o), this.addAttribute("position", new Gi(a, 3)), this.addAttribute("normal", new Gi(s, 3)), this.addAttribute("uv", new Gi(l, 2))
    }

    function no(t, e, i, n) {
        Ii.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new ro(t, e, i, n)), this.mergeVertices()
    }

    function ro(t, e, i, n) {
        Yi.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        }, i = i || 1;
        var r = [],
            o = [];

        function a(t, e, i, n) {
            var r, o, a = Math.pow(2, n),
                l = [];
            for (r = 0; r <= a; r++) {
                l[r] = [];
                var h = t.clone().lerp(i, r / a),
                    c = e.clone().lerp(i, r / a),
                    u = a - r;
                for (o = 0; o <= u; o++) l[r][o] = 0 === o && r === a ? h : h.clone().lerp(c, o / u)
            }
            for (r = 0; r < a; r++)
                for (o = 0; o < 2 * (a - r) - 1; o++) {
                    var p = Math.floor(o / 2);
                    o % 2 == 0 ? (s(l[r][p + 1]), s(l[r + 1][p]), s(l[r][p])) : (s(l[r][p + 1]), s(l[r + 1][p + 1]), s(l[r + 1][p]))
                }
        }

        function s(t) {
            r.push(t.x, t.y, t.z)
        }

        function l(e, i) {
            var n = 3 * e;
            i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
        }

        function h(t, e, i, n) {
            n < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === i.x && 0 === i.z && (o[e] = n / 2 / Math.PI + .5)
        }

        function c(t) {
            return Math.atan2(t.z, -t.x)
        }! function(t) {
            for (var i = new Ye, n = new Ye, r = new Ye, o = 0; o < e.length; o += 3) l(e[o + 0], i), l(e[o + 1], n), l(e[o + 2], r), a(i, n, r, t)
        }(n = n || 0),
        function(t) {
            for (var e = new Ye, i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
        }(i),
        function() {
            for (var t = new Ye, e = 0; e < r.length; e += 3) {
                t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                var i = c(t) / 2 / Math.PI + .5,
                    n = (a = t, Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5);
                o.push(i, 1 - n)
            }
            var a;
            (function() {
                for (var t = new Ye, e = new Ye, i = new Ye, n = new Ye, a = new We, s = new We, l = new We, u = 0, p = 0; u < r.length; u += 9, p += 6) {
                    t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[u + 6], r[u + 7], r[u + 8]), a.set(o[p + 0], o[p + 1]), s.set(o[p + 2], o[p + 3]), l.set(o[p + 4], o[p + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                    var d = c(n);
                    h(a, p + 0, t, d), h(s, p + 2, e, d), h(l, p + 4, i, d)
                }
            })(),
            function() {
                for (var t = 0; t < o.length; t += 6) {
                    var e = o[t + 0],
                        i = o[t + 2],
                        n = o[t + 4],
                        r = Math.max(e, i, n),
                        a = Math.min(e, i, n);
                    r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), i < .2 && (o[t + 2] += 1), n < .2 && (o[t + 4] += 1))
                }
            }()
        }(), this.addAttribute("position", new Gi(r, 3)), this.addAttribute("normal", new Gi(r.slice(), 3)), this.addAttribute("uv", new Gi(o, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function oo(t, e) {
        Ii.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ao(t, e)), this.mergeVertices()
    }

    function ao(t, e) {
        ro.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function so(t, e) {
        Ii.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new lo(t, e)), this.mergeVertices()
    }

    function lo(t, e) {
        ro.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ho(t, e) {
        Ii.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new co(t, e)), this.mergeVertices()
    }

    function co(t, e) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
        ro.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function uo(t, e) {
        Ii.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new po(t, e)), this.mergeVertices()
    }

    function po(t, e) {
        var i = (1 + Math.sqrt(5)) / 2,
            n = 1 / i,
            r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n];
        ro.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function fo(t, e, i, n, r, o) {
        Ii.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new mo(t, e, i, n, r);
        this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
    }

    function mo(t, e, i, n, r) {
        Yi.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: r
        }, e = e || 64, i = i || 1, n = n || 8, r = r || !1;
        var o = t.computeFrenetFrames(e, r);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        var a, s, l = new Ye,
            h = new Ye,
            c = new We,
            u = new Ye,
            p = [],
            d = [],
            f = [],
            m = [];

        function v(r) {
            u = t.getPointAt(r / e, u);
            var a = o.normals[r],
                c = o.binormals[r];
            for (s = 0; s <= n; s++) {
                var f = s / n * Math.PI * 2,
                    m = Math.sin(f),
                    v = -Math.cos(f);
                h.x = v * a.x + m * c.x, h.y = v * a.y + m * c.y, h.z = v * a.z + m * c.z, h.normalize(), d.push(h.x, h.y, h.z), l.x = u.x + i * h.x, l.y = u.y + i * h.y, l.z = u.z + i * h.z, p.push(l.x, l.y, l.z)
            }
        }! function() {
            for (a = 0; a < e; a++) v(a);
            v(!1 === r ? e : 0),
                function() {
                    for (a = 0; a <= e; a++)
                        for (s = 0; s <= n; s++) c.x = a / e, c.y = s / n, f.push(c.x, c.y)
                }(),
                function() {
                    for (s = 1; s <= e; s++)
                        for (a = 1; a <= n; a++) {
                            var t = (n + 1) * (s - 1) + (a - 1),
                                i = (n + 1) * s + (a - 1),
                                r = (n + 1) * s + a,
                                o = (n + 1) * (s - 1) + a;
                            m.push(t, i, o), m.push(i, r, o)
                        }
                }()
        }(), this.setIndex(m), this.addAttribute("position", new Gi(p, 3)), this.addAttribute("normal", new Gi(d, 3)), this.addAttribute("uv", new Gi(f, 2))
    }

    function vo(t, e, i, n, r, o, a) {
        Ii.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: o
        }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new go(t, e, i, n, r, o)), this.mergeVertices()
    }

    function go(t, e, i, n, r, o) {
        Yi.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: o
        }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, o = o || 3;
        var a, s, l = [],
            h = [],
            c = [],
            u = [],
            p = new Ye,
            d = new Ye,
            f = new Ye,
            m = new Ye,
            v = new Ye,
            g = new Ye,
            y = new Ye;
        for (a = 0; a <= i; ++a) {
            var _ = a / i * r * Math.PI * 2;
            for (A(_, r, o, t, f), A(_ + .01, r, o, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= n; ++s) {
                var x = s / n * Math.PI * 2,
                    b = -e * Math.cos(x),
                    w = e * Math.sin(x);
                p.x = f.x + (b * y.x + w * v.x), p.y = f.y + (b * y.y + w * v.y), p.z = f.z + (b * y.z + w * v.z), h.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), c.push(d.x, d.y, d.z), u.push(a / i), u.push(s / n)
            }
        }
        for (s = 1; s <= i; s++)
            for (a = 1; a <= n; a++) {
                var T = (n + 1) * (s - 1) + (a - 1),
                    E = (n + 1) * s + (a - 1),
                    M = (n + 1) * s + a,
                    S = (n + 1) * (s - 1) + a;
                l.push(T, E, S), l.push(E, M, S)
            }

        function A(t, e, i, n, r) {
            var o = Math.cos(t),
                a = Math.sin(t),
                s = i / e * t,
                l = Math.cos(s);
            r.x = n * (2 + l) * .5 * o, r.y = n * (2 + l) * a * .5, r.z = n * Math.sin(s) * .5
        }
        this.setIndex(l), this.addAttribute("position", new Gi(h, 3)), this.addAttribute("normal", new Gi(c, 3)), this.addAttribute("uv", new Gi(u, 2))
    }

    function yo(t, e, i, n, r) {
        Ii.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new _o(t, e, i, n, r)), this.mergeVertices()
    }

    function _o(t, e, i, n, r) {
        Yi.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
        var o, a, s = [],
            l = [],
            h = [],
            c = [],
            u = new Ye,
            p = new Ye,
            d = new Ye;
        for (o = 0; o <= i; o++)
            for (a = 0; a <= n; a++) {
                var f = a / n * r,
                    m = o / i * Math.PI * 2;
                p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), l.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), d.subVectors(p, u).normalize(), h.push(d.x, d.y, d.z), c.push(a / n), c.push(o / i)
            }
        for (o = 1; o <= i; o++)
            for (a = 1; a <= n; a++) {
                var v = (n + 1) * o + a - 1,
                    g = (n + 1) * (o - 1) + a - 1,
                    y = (n + 1) * (o - 1) + a,
                    _ = (n + 1) * o + a;
                s.push(v, g, _), s.push(g, y, _)
            }
        this.setIndex(s), this.addAttribute("position", new Gi(l, 3)), this.addAttribute("normal", new Gi(h, 3)), this.addAttribute("uv", new Gi(c, 2))
    }
    Er.prototype = Object.create(ln.prototype), Er.prototype.constructor = Er, Er.prototype.isMeshDepthMaterial = !0, Er.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, Mr.prototype = Object.create(ln.prototype), Mr.prototype.constructor = Mr, Mr.prototype.isMeshDistanceMaterial = !0, Mr.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }, Ar.prototype = Object.create(ni.prototype), Ar.prototype.constructor = Ar, Pr.prototype = Object.assign(Object.create(Ci.prototype), {
        constructor: Pr,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return Ci.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        },
        setFocalLength: function(t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * je.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * je.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * je.RAD2DEG * Math.atan(Math.tan(.5 * je.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, i, n, r, o) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near,
                e = t * Math.tan(.5 * je.DEG2RAD * this.fov) / this.zoom,
                i = 2 * e,
                n = this.aspect * i,
                r = -.5 * n,
                o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth,
                    s = o.fullHeight;
                r += o.offsetX * n / a, e -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s
            }
            var l = this.filmOffset;
            0 !== l && (r += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far)
        },
        toJSON: function(t) {
            var e = Ai.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }), Lr.prototype = Object.assign(Object.create(Pr.prototype), {
        constructor: Lr,
        isArrayCamera: !0
    }), Ir.prototype.isFogExp2 = !0, Ir.prototype.clone = function() {
        return new Ir(this.color.getHex(), this.density)
    }, Ir.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }, Nr.prototype.isFog = !0, Nr.prototype.clone = function() {
        return new Nr(this.color.getHex(), this.near, this.far)
    }, Nr.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }, zr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: zr,
        copy: function(t, e) {
            return Ai.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        },
        toJSON: function(t) {
            var e = Ai.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }
    }), Fr.prototype = Object.create(ln.prototype), Fr.prototype.constructor = Fr, Fr.prototype.isSpriteMaterial = !0, Fr.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
    }, Dr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Dr,
        isSprite: !0,
        raycast: (fr = new Ye, mr = new Ye, vr = new Ye, function(t, e) {
            mr.setFromMatrixPosition(this.matrixWorld), t.ray.closestPointToPoint(mr, fr), vr.setFromMatrixScale(this.matrixWorld);
            var i = vr.x * vr.y / 4;
            if (!(mr.distanceToSquared(fr) > i)) {
                var n = t.ray.origin.distanceTo(fr);
                n < t.near || n > t.far || e.push({
                    distance: n,
                    point: fr.clone(),
                    face: null,
                    object: this
                })
            }
        }),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(t) {
            return Ai.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
        }
    }), Ur.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Ur,
        copy: function(t) {
            Ai.prototype.copy.call(this, t, !1);
            for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0), e = Math.abs(e);
            for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
            i.splice(n, 0, {
                distance: e,
                object: t
            }), this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
            return e[i - 1].object
        },
        raycast: (gr = new Ye, function(t, e) {
            gr.setFromMatrixPosition(this.matrixWorld);
            var i = t.ray.origin.distanceTo(gr);
            this.getObjectForDistance(i).raycast(t, e)
        }),
        update: function() {
            var t = new Ye,
                e = new Ye;
            return function(i) {
                var n = this.levels;
                if (n.length > 1) {
                    t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                    var r = t.distanceTo(e);
                    n[0].object.visible = !0;
                    for (var o = 1, a = n.length; o < a && r >= n[o].distance; o++) n[o - 1].object.visible = !1, n[o].object.visible = !0;
                    for (; o < a; o++) n[o].object.visible = !1
                }
            }
        }(),
        toJSON: function(t) {
            var e = Ai.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                var o = i[n];
                e.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return e
        }
    }), Object.assign(kr.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var i = new qe;
                this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
            }
        },
        pose: function() {
            var t, e, i;
            for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: (yr = new qe, _r = new qe, function() {
            for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, o = t.length; r < o; r++) {
                var a = t[r] ? t[r].matrixWorld : _r;
                yr.multiplyMatrices(a, e[r]), yr.toArray(i, 16 * r)
            }
            void 0 !== n && (n.needsUpdate = !0)
        }),
        clone: function() {
            return new kr(this.bones, this.boneInverses)
        },
        getBoneByName: function(t) {
            for (var e = 0, i = this.bones.length; e < i; e++) {
                var n = this.bones[e];
                if (n.name === t) return n
            }
        }
    }), Vr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Vr,
        isBone: !0
    }), Hr.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: Hr,
        isSkinnedMesh: !0,
        initBones: function() {
            var t, e, i, n, r = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (i = 0, n = this.geometry.bones.length; i < n; i++) e = this.geometry.bones[i], t = new Vr, r.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                for (i = 0, n = this.geometry.bones.length; i < n; i++) - 1 !== (e = this.geometry.bones[i]).parent && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[i]) : this.add(r[i])
            }
            return this.updateMatrixWorld(!0), r
        },
        bind: function(t, e) {
            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var t, e;
            if (this.geometry && this.geometry.isGeometry)
                for (e = 0; e < this.geometry.skinWeights.length; e++) {
                    var i = this.geometry.skinWeights[e];
                    (t = 1 / i.manhattanLength()) != 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry) {
                    var n = new ri,
                        r = this.geometry.attributes.skinWeight;
                    for (e = 0; e < r.count; e++) n.x = r.getX(e), n.y = r.getY(e), n.z = r.getZ(e), n.w = r.getW(e), (t = 1 / n.manhattanLength()) != 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0), r.setXYZW(e, n.x, n.y, n.z, n.w)
                }
        },
        updateMatrixWorld: function(t) {
            fn.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Gr.prototype = Object.create(ln.prototype), Gr.prototype.constructor = Gr, Gr.prototype.isLineBasicMaterial = !0, Gr.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
    }, jr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: jr,
        isLine: !0,
        computeLineDistances: (xr = new Ye, br = new Ye, function() {
            var t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n < r; n++) xr.fromBufferAttribute(e, n - 1), br.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += xr.distanceTo(br);
                    t.addAttribute("lineDistance", new Gi(i, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                var o = t.vertices;
                for ((i = t.lineDistances)[0] = 0, n = 1, r = o.length; n < r; n++) i[n] = i[n - 1], i[n] += o[n - 1].distanceTo(o[n])
            }
            return this
        }),
        raycast: function() {
            var t = new qe,
                e = new un,
                i = new hi;
            return function(n, r) {
                var o = n.linePrecision,
                    a = o * o,
                    s = this.geometry,
                    l = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(l), !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(l), e.copy(n.ray).applyMatrix4(t);
                    var h = new Ye,
                        c = new Ye,
                        u = new Ye,
                        p = new Ye,
                        d = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var f = s.index,
                            m = s.attributes.position.array;
                        if (null !== f)
                            for (var v = f.array, g = 0, y = v.length - 1; g < y; g += d) {
                                var _ = v[g],
                                    x = v[g + 1];
                                h.fromArray(m, 3 * _), c.fromArray(m, 3 * x), e.distanceSqToSegment(h, c, p, u) > a || (p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                    distance: T,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: g,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            } else
                                for (g = 0, y = m.length / 3 - 1; g < y; g += d) h.fromArray(m, 3 * g), c.fromArray(m, 3 * g + 3), e.distanceSqToSegment(h, c, p, u) > a || (p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                    distance: T,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: g,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                    } else if (s.isGeometry) {
                        var b = s.vertices,
                            w = b.length;
                        for (g = 0; g < w - 1; g += d) {
                            var T;
                            e.distanceSqToSegment(b[g], b[g + 1], p, u) > a || (p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                distance: T,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: g,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Wr.prototype = Object.assign(Object.create(jr.prototype), {
        constructor: Wr,
        isLineSegments: !0,
        computeLineDistances: function() {
            var t = new Ye,
                e = new Ye;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry)
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [], o = 0, a = n.count; o < a; o += 2) t.fromBufferAttribute(n, o), e.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e);
                        i.addAttribute("lineDistance", new Gi(r, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (i.isGeometry) {
                    var s = i.vertices;
                    for (r = i.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e)
                }
                return this
            }
        }()
    }), qr.prototype = Object.assign(Object.create(jr.prototype), {
        constructor: qr,
        isLineLoop: !0
    }), Xr.prototype = Object.create(ln.prototype), Xr.prototype.constructor = Xr, Xr.prototype.isPointsMaterial = !0, Xr.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
    }, Yr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Yr,
        isPoints: !0,
        raycast: function() {
            var t = new qe,
                e = new un,
                i = new hi;
            return function(n, r) {
                var o = this,
                    a = this.geometry,
                    s = this.matrixWorld,
                    l = n.params.Points.threshold;
                if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(s), i.radius += l, !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
                    var h = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        c = h * h,
                        u = new Ye,
                        p = new Ye;
                    if (a.isBufferGeometry) {
                        var d = a.index,
                            f = a.attributes.position.array;
                        if (null !== d)
                            for (var m = d.array, v = 0, g = m.length; v < g; v++) {
                                var y = m[v];
                                u.fromArray(f, 3 * y), b(u, y)
                            } else {
                                v = 0;
                                for (var _ = f.length / 3; v < _; v++) u.fromArray(f, 3 * v), b(u, v)
                            }
                    } else {
                        var x = a.vertices;
                        for (v = 0, _ = x.length; v < _; v++) b(x[v], v)
                    }
                }

                function b(t, i) {
                    var a = e.distanceSqToPoint(t);
                    if (a < c) {
                        e.closestPointToPoint(t, p), p.applyMatrix4(s);
                        var l = n.ray.origin.distanceTo(p);
                        if (l < n.near || l > n.far) return;
                        r.push({
                            distance: l,
                            distanceToRay: Math.sqrt(a),
                            point: p.clone(),
                            index: i,
                            face: null,
                            object: o
                        })
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Zr.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: Zr,
        isGroup: !0
    }), Jr.prototype = Object.assign(Object.create(ni.prototype), {
        constructor: Jr,
        isVideoTexture: !0,
        update: function() {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), Kr.prototype = Object.create(ni.prototype), Kr.prototype.constructor = Kr, Kr.prototype.isCompressedTexture = !0, Qr.prototype = Object.create(ni.prototype), Qr.prototype.constructor = Qr, Qr.prototype.isDepthTexture = !0, $r.prototype = {
        constructor: $r,
        clone: function(t) {
            return void 0 === t ? new $r(this) : ($r.call(t, this), t)
        }
    }, $r.DEFAULT_MAPPING = vt, to.prototype = Object.create(Yi.prototype), to.prototype.constructor = to, eo.prototype = Object.create(Ii.prototype), eo.prototype.constructor = eo, io.prototype = Object.create(Yi.prototype), io.prototype.constructor = io, no.prototype = Object.create(Ii.prototype), no.prototype.constructor = no, ro.prototype = Object.create(Yi.prototype), ro.prototype.constructor = ro, oo.prototype = Object.create(Ii.prototype), oo.prototype.constructor = oo, ao.prototype = Object.create(ro.prototype), ao.prototype.constructor = ao, so.prototype = Object.create(Ii.prototype), so.prototype.constructor = so, lo.prototype = Object.create(ro.prototype), lo.prototype.constructor = lo, ho.prototype = Object.create(Ii.prototype), ho.prototype.constructor = ho, co.prototype = Object.create(ro.prototype), co.prototype.constructor = co, uo.prototype = Object.create(Ii.prototype), uo.prototype.constructor = uo, po.prototype = Object.create(ro.prototype), po.prototype.constructor = po, fo.prototype = Object.create(Ii.prototype), fo.prototype.constructor = fo, mo.prototype = Object.create(Yi.prototype), mo.prototype.constructor = mo, vo.prototype = Object.create(Ii.prototype), vo.prototype.constructor = vo, go.prototype = Object.create(Yi.prototype), go.prototype.constructor = go, yo.prototype = Object.create(Ii.prototype), yo.prototype.constructor = yo, _o.prototype = Object.create(Yi.prototype), _o.prototype.constructor = _o;

    function xo(t, e, i, n, r) {
        var o, a;
        if (r === function(t, e, i, n) {
                for (var r = 0, o = e, a = i - n; o < i; o += n) r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                return r
            }(t, e, i, n) > 0)
            for (o = e; o < i; o += n) a = Do(o, t[o], t[o + 1], a);
        else
            for (o = i - n; o >= e; o -= n) a = Do(o, t[o], t[o + 1], a);
        return a && Io(a, a.next) && (Uo(a), a = a.next), a
    }

    function bo(t, e) {
        if (!t) return t;
        e || (e = t);
        var i, n = t;
        do {
            if (i = !1, n.steiner || !Io(n, n.next) && 0 !== Bo(n.prev, n, n.next)) n = n.next;
            else {
                if (Uo(n), (n = e = n.prev) === n.next) break;
                i = !0
            }
        } while (i || n !== e);
        return e
    }

    function wo(t, e, i, n, r, o, a) {
        if (t) {
            !a && o && function(t, e, i, n) {
                var r = t;
                do {
                    null === r.z && (r.z = Ro(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null, r.prevZ = null,
                    function(t) {
                        var e, i, n, r, o, a, s, l, h = 1;
                        do {
                            for (i = t, t = null, o = null, a = 0; i;) {
                                for (a++, n = i, s = 0, e = 0; e < h && (s++, n = n.nextZ); e++);
                                for (l = h; s > 0 || l > 0 && n;) 0 !== s && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, s--) : (r = n, n = n.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                i = n
                            }
                            o.nextZ = null, h *= 2
                        } while (a > 1)
                    }(r)
            }(t, n, r, o);
            for (var s, l, h = t; t.prev !== t.next;)
                if (s = t.prev, l = t.next, o ? Eo(t, n, r, o) : To(t)) e.push(s.i / i), e.push(t.i / i), e.push(l.i / i), Uo(t), t = l.next, h = l.next;
                else if ((t = l) === h) {
                a ? 1 === a ? wo(t = Mo(t, e, i), e, i, n, r, o, 2) : 2 === a && So(t, e, i, n, r, o) : wo(bo(t), e, i, n, r, o, 1);
                break
            }
        }
    }

    function To(t) {
        var e = t.prev,
            i = t,
            n = t.next;
        if (Bo(e, i, n) >= 0) return !1;
        for (var r = t.next.next; r !== t.prev;) {
            if (Lo(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && Bo(r.prev, r, r.next) >= 0) return !1;
            r = r.next
        }
        return !0
    }

    function Eo(t, e, i, n) {
        var r = t.prev,
            o = t,
            a = t.next;
        if (Bo(r, o, a) >= 0) return !1;
        for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, l = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, h = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, c = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = Ro(s, l, e, i, n), p = Ro(h, c, e, i, n), d = t.nextZ; d && d.z <= p;) {
            if (d !== t.prev && d !== t.next && Lo(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && Bo(d.prev, d, d.next) >= 0) return !1;
            d = d.nextZ
        }
        for (d = t.prevZ; d && d.z >= u;) {
            if (d !== t.prev && d !== t.next && Lo(r.x, r.y, o.x, o.y, a.x, a.y, d.x, d.y) && Bo(d.prev, d, d.next) >= 0) return !1;
            d = d.prevZ
        }
        return !0
    }

    function Mo(t, e, i) {
        var n = t;
        do {
            var r = n.prev,
                o = n.next.next;
            !Io(r, o) && No(r, n, n.next, o) && zo(r, o) && zo(o, r) && (e.push(r.i / i), e.push(n.i / i), e.push(o.i / i), Uo(n), Uo(n.next), n = t = o), n = n.next
        } while (n !== t);
        return n
    }

    function So(t, e, i, n, r, o) {
        var a = t;
        do {
            for (var s = a.next.next; s !== a.prev;) {
                if (a.i !== s.i && Oo(a, s)) {
                    var l = Fo(a, s);
                    return a = bo(a, a.next), l = bo(l, l.next), wo(a, e, i, n, r, o), void wo(l, e, i, n, r, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== t)
    }

    function Ao(t, e) {
        return t.x - e.x
    }

    function Co(t, e) {
        if (e = function(t, e) {
                var i, n = e,
                    r = t.x,
                    o = t.y,
                    a = -1 / 0;
                do {
                    if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                        var s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (s <= r && s > a) {
                            if (a = s, s === r) {
                                if (o === n.y) return n;
                                if (o === n.next.y) return n.next
                            }
                            i = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!i) return null;
                if (r === a) return i.prev;
                var l, h = i,
                    c = i.x,
                    u = i.y,
                    p = 1 / 0;
                for (n = i.next; n !== h;) r >= n.x && n.x >= c && r !== n.x && Lo(o < u ? r : a, o, c, u, o < u ? a : r, o, n.x, n.y) && ((l = Math.abs(o - n.y) / (r - n.x)) < p || l === p && n.x > i.x) && zo(n, t) && (i = n, p = l), n = n.next;
                return i
            }(t, e)) {
            var i = Fo(e, t);
            bo(i, i.next)
        }
    }

    function Ro(t, e, i, n, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function Po(t) {
        var e = t,
            i = t;
        do {
            e.x < i.x && (i = e), e = e.next
        } while (e !== t);
        return i
    }

    function Lo(t, e, i, n, r, o, a, s) {
        return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (n - s) - (i - a) * (e - s) >= 0 && (i - a) * (o - s) - (r - a) * (n - s) >= 0
    }

    function Oo(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && No(i, i.next, t, e)) return !0;
                i = i.next
            } while (i !== t);
            return !1
        }(t, e) && zo(t, e) && zo(e, t) && function(t, e) {
            var i = t,
                n = !1,
                r = (t.x + e.x) / 2,
                o = (t.y + e.y) / 2;
            do {
                i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
            } while (i !== t);
            return n
        }(t, e)
    }

    function Bo(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
    }

    function Io(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function No(t, e, i, n) {
        return !!(Io(t, e) && Io(i, n) || Io(t, n) && Io(i, e)) || Bo(t, e, i) > 0 != Bo(t, e, n) > 0 && Bo(i, n, t) > 0 != Bo(i, n, e) > 0
    }

    function zo(t, e) {
        return Bo(t.prev, t, t.next) < 0 ? Bo(t, e, t.next) >= 0 && Bo(t, t.prev, e) >= 0 : Bo(t, e, t.prev) < 0 || Bo(t, t.next, e) < 0
    }

    function Fo(t, e) {
        var i = new ko(t.i, t.x, t.y),
            n = new ko(e.i, e.x, e.y),
            r = t.next,
            o = e.prev;
        return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
    }

    function Do(t, e, i, n) {
        var r = new ko(t, e, i);
        return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
    }

    function Uo(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function ko(t, e, i) {
        this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    var Vo = {
        area: function(t) {
            for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
            return .5 * i
        },
        isClockWise: function(t) {
            return Vo.area(t) < 0
        },
        triangulateShape: function(t, e) {
            var i = [],
                n = [],
                r = [];
            Ho(t), Go(i, t);
            var o = t.length;
            e.forEach(Ho);
            for (var a = 0; a < e.length; a++) n.push(o), o += e[a].length, Go(i, e[a]);
            var s = function(t, e, i) {
                i = i || 2;
                var n, r, o, a, s, l, h, c = e && e.length,
                    u = c ? e[0] * i : t.length,
                    p = xo(t, 0, u, i, !0),
                    d = [];
                if (!p) return d;
                if (c && (p = function(t, e, i, n) {
                        var r, o, a, s = [];
                        for (r = 0, o = e.length; r < o; r++)(a = xo(t, e[r] * n, r < o - 1 ? e[r + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), s.push(Po(a));
                        for (s.sort(Ao), r = 0; r < s.length; r++) Co(s[r], i), i = bo(i, i.next);
                        return i
                    }(t, e, p, i)), t.length > 80 * i) {
                    n = o = t[0], r = a = t[1];
                    for (var f = i; f < u; f += i) s = t[f], l = t[f + 1], s < n && (n = s), l < r && (r = l), s > o && (o = s), l > a && (a = l);
                    h = 0 !== (h = Math.max(o - n, a - r)) ? 1 / h : 0
                }
                return wo(p, d, i, n, r, h), d
            }(i, n);
            for (a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
            return r
        }
    };

    function Ho(t) {
        var e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }

    function Go(t, e) {
        for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
    }

    function jo(t, e) {
        Ii.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, this.fromBufferGeometry(new Wo(t, e)), this.mergeVertices()
    }

    function Wo(t, e) {
        void 0 !== t && (Yi.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
    }

    function qo(t, e) {
        Ii.call(this), this.type = "TextGeometry", this.parameters = {
            text: t,
            parameters: e
        }, this.fromBufferGeometry(new Xo(t, e)), this.mergeVertices()
    }

    function Xo(t, e) {
        var i = (e = e || {}).font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Ii;
        var n = i.generateShapes(t, e.size, e.curveSegments);
        e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Wo.call(this, n, e), this.type = "TextBufferGeometry"
    }

    function Yo(t, e, i, n, r, o, a) {
        Ii.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, this.fromBufferGeometry(new Zo(t, e, i, n, r, o, a)), this.mergeVertices()
    }

    function Zo(t, e, i, n, r, o, a) {
        Yi.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: o,
            thetaLength: a
        }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var s, l, h = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI),
            c = 0,
            u = [],
            p = new Ye,
            d = new Ye,
            f = [],
            m = [],
            v = [],
            g = [];
        for (l = 0; l <= i; l++) {
            var y = [],
                _ = l / i;
            for (s = 0; s <= e; s++) {
                var x = s / e;
                p.x = -t * Math.cos(n + x * r) * Math.sin(o + _ * a), p.y = t * Math.cos(o + _ * a), p.z = t * Math.sin(n + x * r) * Math.sin(o + _ * a), m.push(p.x, p.y, p.z), d.set(p.x, p.y, p.z).normalize(), v.push(d.x, d.y, d.z), g.push(x, 1 - _), y.push(c++)
            }
            u.push(y)
        }
        for (l = 0; l < i; l++)
            for (s = 0; s < e; s++) {
                var b = u[l][s + 1],
                    w = u[l][s],
                    T = u[l + 1][s],
                    E = u[l + 1][s + 1];
                (0 !== l || o > 0) && f.push(b, w, E), (l !== i - 1 || h < Math.PI) && f.push(w, T, E)
            }
        this.setIndex(f), this.addAttribute("position", new Gi(m, 3)), this.addAttribute("normal", new Gi(v, 3)), this.addAttribute("uv", new Gi(g, 2))
    }

    function Jo(t, e, i, n, r, o) {
        Ii.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: o
        }, this.fromBufferGeometry(new Ko(t, e, i, n, r, o)), this.mergeVertices()
    }

    function Ko(t, e, i, n, r, o) {
        Yi.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: o
        }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
        var a, s, l, h = [],
            c = [],
            u = [],
            p = [],
            d = t,
            f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
            m = new Ye,
            v = new We;
        for (s = 0; s <= n; s++) {
            for (l = 0; l <= i; l++) a = r + l / i * o, m.x = d * Math.cos(a), m.y = d * Math.sin(a), c.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, p.push(v.x, v.y);
            d += f
        }
        for (s = 0; s < n; s++) {
            var g = s * (i + 1);
            for (l = 0; l < i; l++) {
                var y = a = l + g,
                    _ = a + i + 1,
                    x = a + i + 2,
                    b = a + 1;
                h.push(y, _, b), h.push(_, x, b)
            }
        }
        this.setIndex(h), this.addAttribute("position", new Gi(c, 3)), this.addAttribute("normal", new Gi(u, 3)), this.addAttribute("uv", new Gi(p, 2))
    }

    function Qo(t, e, i, n) {
        Ii.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new $o(t, e, i, n)), this.mergeVertices()
    }

    function $o(t, e, i, n) {
        Yi.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
        }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = je.clamp(n, 0, 2 * Math.PI);
        var r, o, a, s = [],
            l = [],
            h = [],
            c = 1 / e,
            u = new Ye,
            p = new We;
        for (o = 0; o <= e; o++) {
            var d = i + o * c * n,
                f = Math.sin(d),
                m = Math.cos(d);
            for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, l.push(u.x, u.y, u.z), p.x = o / e, p.y = a / (t.length - 1), h.push(p.x, p.y)
        }
        for (o = 0; o < e; o++)
            for (a = 0; a < t.length - 1; a++) {
                var v = r = a + o * t.length,
                    g = r + t.length,
                    y = r + t.length + 1,
                    _ = r + 1;
                s.push(v, g, _), s.push(g, y, _)
            }
        if (this.setIndex(s), this.addAttribute("position", new Gi(l, 3)), this.addAttribute("uv", new Gi(h, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
            var x = this.attributes.normal.array,
                b = new Ye,
                w = new Ye,
                T = new Ye;
            for (r = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[r + a + 0], w.y = x[r + a + 1], w.z = x[r + a + 2], T.addVectors(b, w).normalize(), x[a + 0] = x[r + a + 0] = T.x, x[a + 1] = x[r + a + 1] = T.y, x[a + 2] = x[r + a + 2] = T.z
        }
    }

    function ta(t, e) {
        Ii.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
            shapes: t,
            curveSegments: e
        }, this.fromBufferGeometry(new ea(t, e)), this.mergeVertices()
    }

    function ea(t, e) {
        Yi.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: t,
            curveSegments: e
        }, e = e || 12;
        var i = [],
            n = [],
            r = [],
            o = [],
            a = 0,
            s = 0;
        if (!1 === Array.isArray(t)) h(t);
        else
            for (var l = 0; l < t.length; l++) h(t[l]), this.addGroup(a, s, l), a += s, s = 0;

        function h(t) {
            var a, l, h, c = n.length / 3,
                u = t.extractPoints(e),
                p = u.shape,
                d = u.holes;
            if (!1 === Vo.isClockWise(p))
                for (p = p.reverse(), a = 0, l = d.length; a < l; a++) h = d[a], !0 === Vo.isClockWise(h) && (d[a] = h.reverse());
            var f = Vo.triangulateShape(p, d);
            for (a = 0, l = d.length; a < l; a++) h = d[a], p = p.concat(h);
            for (a = 0, l = p.length; a < l; a++) {
                var m = p[a];
                n.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
            }
            for (a = 0, l = f.length; a < l; a++) {
                var v = f[a],
                    g = v[0] + c,
                    y = v[1] + c,
                    _ = v[2] + c;
                i.push(g, y, _), s += 3
            }
        }
        this.setIndex(i), this.addAttribute("position", new Gi(n, 3)), this.addAttribute("normal", new Gi(r, 3)), this.addAttribute("uv", new Gi(o, 2))
    }

    function ia(t, e) {
        if (e.shapes = [], Array.isArray(t))
            for (var i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.shapes.push(r.uuid)
            } else e.shapes.push(t.uuid);
        return e
    }

    function na(t, e) {
        Yi.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: e
        }, e = void 0 !== e ? e : 1;
        var i, n, r, o, a = [],
            s = Math.cos(je.DEG2RAD * e),
            l = [0, 0],
            h = {},
            c = ["a", "b", "c"];
        t.isBufferGeometry ? (o = new Ii).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
        for (var u = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
            for (var m = p[d], v = 0; v < 3; v++) i = m[c[v]], n = m[c[(v + 1) % 3]], l[0] = Math.min(i, n), l[1] = Math.max(i, n), void 0 === h[r = l[0] + "," + l[1]] ? h[r] = {
                index1: l[0],
                index2: l[1],
                face1: d,
                face2: void 0
            } : h[r].face2 = d;
        for (r in h) {
            var g = h[r];
            if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
                var y = u[g.index1];
                a.push(y.x, y.y, y.z), y = u[g.index2], a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new Gi(a, 3))
    }

    function ra(t, e, i, n, r, o, a, s) {
        Ii.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        }, this.fromBufferGeometry(new oa(t, e, i, n, r, o, a, s)), this.mergeVertices()
    }

    function oa(t, e, i, n, r, o, a, s) {
        Yi.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var l = this;
        t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, i = i || 1, n = Math.floor(n) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
        var h = [],
            c = [],
            u = [],
            p = [],
            d = 0,
            f = [],
            m = i / 2,
            v = 0;

        function g(i) {
            var r, o, f, g = new We,
                y = new Ye,
                _ = 0,
                x = !0 === i ? t : e,
                b = !0 === i ? 1 : -1;
            for (o = d, r = 1; r <= n; r++) c.push(0, m * b, 0), u.push(0, b, 0), p.push(.5, .5), d++;
            for (f = d, r = 0; r <= n; r++) {
                var w = r / n * s + a,
                    T = Math.cos(w),
                    E = Math.sin(w);
                y.x = x * E, y.y = m * b, y.z = x * T, c.push(y.x, y.y, y.z), u.push(0, b, 0), g.x = .5 * T + .5, g.y = .5 * E * b + .5, p.push(g.x, g.y), d++
            }
            for (r = 0; r < n; r++) {
                var M = o + r,
                    S = f + r;
                !0 === i ? h.push(S, S + 1, M) : h.push(S + 1, S, M), _ += 3
            }
            l.addGroup(v, _, !0 === i ? 1 : 2), v += _
        }! function() {
            var o, g, y = new Ye,
                _ = new Ye,
                x = 0,
                b = (e - t) / i;
            for (g = 0; g <= r; g++) {
                var w = [],
                    T = g / r,
                    E = T * (e - t) + t;
                for (o = 0; o <= n; o++) {
                    var M = o / n,
                        S = M * s + a,
                        A = Math.sin(S),
                        C = Math.cos(S);
                    _.x = E * A, _.y = -T * i + m, _.z = E * C, c.push(_.x, _.y, _.z), y.set(A, b, C).normalize(), u.push(y.x, y.y, y.z), p.push(M, 1 - T), w.push(d++)
                }
                f.push(w)
            }
            for (o = 0; o < n; o++)
                for (g = 0; g < r; g++) {
                    var R = f[g][o],
                        P = f[g + 1][o],
                        L = f[g + 1][o + 1],
                        O = f[g][o + 1];
                    h.push(R, P, O), h.push(P, L, O), x += 6
                }
            l.addGroup(v, x, 0), v += x
        }(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(h), this.addAttribute("position", new Gi(c, 3)), this.addAttribute("normal", new Gi(u, 3)), this.addAttribute("uv", new Gi(p, 2))
    }

    function aa(t, e, i, n, r, o, a) {
        ra.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function sa(t, e, i, n, r, o, a) {
        oa.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: o,
            thetaLength: a
        }
    }

    function la(t, e, i, n) {
        Ii.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new ha(t, e, i, n)), this.mergeVertices()
    }

    function ha(t, e, i, n) {
        Yi.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: i,
            thetaLength: n
        }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
        var r, o, a = [],
            s = [],
            l = [],
            h = [],
            c = new Ye,
            u = new We;
        for (s.push(0, 0, 0), l.push(0, 0, 1), h.push(.5, .5), o = 0, r = 3; o <= e; o++, r += 3) {
            var p = i + o / e * n;
            c.x = t * Math.cos(p), c.y = t * Math.sin(p), s.push(c.x, c.y, c.z), l.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, h.push(u.x, u.y)
        }
        for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
        this.setIndex(a), this.addAttribute("position", new Gi(s, 3)), this.addAttribute("normal", new Gi(l, 3)), this.addAttribute("uv", new Gi(h, 2))
    }
    jo.prototype = Object.create(Ii.prototype), jo.prototype.constructor = jo, Wo.prototype = Object.create(Yi.prototype), Wo.prototype.constructor = Wo, Wo.prototype.getArrays = function() {
        var t = this.getAttribute("position"),
            e = t ? Array.prototype.slice.call(t.array) : [],
            i = this.getAttribute("uv"),
            n = i ? Array.prototype.slice.call(i.array) : [],
            r = this.index;
        return {
            position: e,
            uv: n,
            index: r ? Array.prototype.slice.call(r.array) : []
        }
    }, Wo.prototype.addShapeList = function(t, e) {
        var i = t.length;
        e.arrays = this.getArrays();
        for (var n = 0; n < i; n++) {
            var r = t[n];
            this.addShape(r, e)
        }
        this.setIndex(e.arrays.index), this.addAttribute("position", new Gi(e.arrays.position, 3)), this.addAttribute("uv", new Gi(e.arrays.uv, 2))
    }, Wo.prototype.addShape = function(t, e) {
        var i, n, r, o, a, s, l, h, c = e.arrays ? e.arrays : this.getArrays(),
            u = c.position,
            p = c.index,
            d = c.uv,
            f = [],
            m = void 0 !== e.amount ? e.amount : 100,
            v = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
            g = void 0 !== e.bevelSize ? e.bevelSize : v - 2,
            y = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
            _ = void 0 === e.bevelEnabled || e.bevelEnabled,
            x = void 0 !== e.curveSegments ? e.curveSegments : 12,
            b = void 0 !== e.steps ? e.steps : 1,
            w = e.extrudePath,
            T = !1,
            E = void 0 !== e.UVGenerator ? e.UVGenerator : jo.WorldUVGenerator;
        w && (i = w.getSpacedPoints(b), T = !0, _ = !1, n = void 0 !== e.frames ? e.frames : w.computeFrenetFrames(b, !1), r = new Ye, o = new Ye, a = new Ye), _ || (y = 0, v = 0, g = 0);
        var M = this,
            S = t.extractPoints(x),
            A = S.shape,
            C = S.holes;
        if (!Vo.isClockWise(A))
            for (A = A.reverse(), l = 0, h = C.length; l < h; l++) s = C[l], Vo.isClockWise(s) && (C[l] = s.reverse());
        var R = Vo.triangulateShape(A, C),
            P = A;
        for (l = 0, h = C.length; l < h; l++) s = C[l], A = A.concat(s);

        function L(t, e, i) {
            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
        }
        var O, B, I, N, z, F, D = A.length,
            U = R.length;

        function k(t, e, i) {
            var n, r, o, a = t.x - e.x,
                s = t.y - e.y,
                l = i.x - t.x,
                h = i.y - t.y,
                c = a * a + s * s,
                u = a * h - s * l;
            if (Math.abs(u) > Number.EPSILON) {
                var p = Math.sqrt(c),
                    d = Math.sqrt(l * l + h * h),
                    f = e.x - s / p,
                    m = e.y + a / p,
                    v = ((i.x - h / d - f) * h - (i.y + l / d - m) * l) / (a * h - s * l),
                    g = (n = f + a * v - t.x) * n + (r = m + s * v - t.y) * r;
                if (g <= 2) return new We(n, r);
                o = Math.sqrt(g / 2)
            } else {
                var y = !1;
                a > Number.EPSILON ? l > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(h) && (y = !0), y ? (n = -s, r = a, o = Math.sqrt(c)) : (n = a, r = s, o = Math.sqrt(c / 2))
            }
            return new We(n / o, r / o)
        }
        for (var V = [], H = 0, G = P.length, j = G - 1, W = H + 1; H < G; H++, j++, W++) j === G && (j = 0), W === G && (W = 0), V[H] = k(P[H], P[j], P[W]);
        var q, X, Y = [],
            Z = V.concat();
        for (l = 0, h = C.length; l < h; l++) {
            for (s = C[l], q = [], H = 0, j = (G = s.length) - 1, W = H + 1; H < G; H++, j++, W++) j === G && (j = 0), W === G && (W = 0), q[H] = k(s[H], s[j], s[W]);
            Y.push(q), Z = Z.concat(q)
        }
        for (O = 0; O < y; O++) {
            for (I = O / y, N = v * Math.cos(I * Math.PI / 2), B = g * Math.sin(I * Math.PI / 2), H = 0, G = P.length; H < G; H++) K((z = L(P[H], V[H], B)).x, z.y, -N);
            for (l = 0, h = C.length; l < h; l++)
                for (s = C[l], q = Y[l], H = 0, G = s.length; H < G; H++) K((z = L(s[H], q[H], B)).x, z.y, -N)
        }
        for (B = g, H = 0; H < D; H++) z = _ ? L(A[H], Z[H], B) : A[H], T ? (o.copy(n.normals[0]).multiplyScalar(z.x), r.copy(n.binormals[0]).multiplyScalar(z.y), a.copy(i[0]).add(o).add(r), K(a.x, a.y, a.z)) : K(z.x, z.y, 0);
        for (X = 1; X <= b; X++)
            for (H = 0; H < D; H++) z = _ ? L(A[H], Z[H], B) : A[H], T ? (o.copy(n.normals[X]).multiplyScalar(z.x), r.copy(n.binormals[X]).multiplyScalar(z.y), a.copy(i[X]).add(o).add(r), K(a.x, a.y, a.z)) : K(z.x, z.y, m / b * X);
        for (O = y - 1; O >= 0; O--) {
            for (I = O / y, N = v * Math.cos(I * Math.PI / 2), B = g * Math.sin(I * Math.PI / 2), H = 0, G = P.length; H < G; H++) K((z = L(P[H], V[H], B)).x, z.y, m + N);
            for (l = 0, h = C.length; l < h; l++)
                for (s = C[l], q = Y[l], H = 0, G = s.length; H < G; H++) z = L(s[H], q[H], B), T ? K(z.x, z.y + i[b - 1].y, i[b - 1].x + N) : K(z.x, z.y, m + N)
        }

        function J(t, e) {
            var i, n;
            for (H = t.length; --H >= 0;) {
                i = H, (n = H - 1) < 0 && (n = t.length - 1);
                var r = 0,
                    o = b + 2 * y;
                for (r = 0; r < o; r++) {
                    var a = D * r,
                        s = D * (r + 1);
                    $(e + i + a, e + n + a, e + n + s, e + i + s)
                }
            }
        }

        function K(t, e, i) {
            f.push(t), f.push(e), f.push(i)
        }

        function Q(t, e, i) {
            tt(t), tt(e), tt(i);
            var n = u.length / 3,
                r = E.generateTopUV(M, u, n - 3, n - 2, n - 1);
            et(r[0]), et(r[1]), et(r[2])
        }

        function $(t, e, i, n) {
            tt(t), tt(e), tt(n), tt(e), tt(i), tt(n);
            var r = u.length / 3,
                o = E.generateSideWallUV(M, u, r - 6, r - 3, r - 2, r - 1);
            et(o[0]), et(o[1]), et(o[3]), et(o[1]), et(o[2]), et(o[3])
        }

        function tt(t) {
            p.push(u.length / 3), u.push(f[3 * t + 0]), u.push(f[3 * t + 1]), u.push(f[3 * t + 2])
        }

        function et(t) {
            d.push(t.x), d.push(t.y)
        }! function() {
            var t = u.length / 3;
            if (_) {
                var e = 0,
                    i = D * e;
                for (H = 0; H < U; H++) Q((F = R[H])[2] + i, F[1] + i, F[0] + i);
                for (i = D * (e = b + 2 * y), H = 0; H < U; H++) Q((F = R[H])[0] + i, F[1] + i, F[2] + i)
            } else {
                for (H = 0; H < U; H++) Q((F = R[H])[2], F[1], F[0]);
                for (H = 0; H < U; H++) Q((F = R[H])[0] + D * b, F[1] + D * b, F[2] + D * b)
            }
            M.addGroup(t, u.length / 3 - t, 0)
        }(),
        function() {
            var t = u.length / 3,
                e = 0;
            for (J(P, e), e += P.length, l = 0, h = C.length; l < h; l++) J(s = C[l], e), e += s.length;
            M.addGroup(t, u.length / 3 - t, 1)
        }(), e.arrays || (this.setIndex(p), this.addAttribute("position", new Gi(u, 3)), this.addAttribute("uv", new Gi(d, 2)))
    }, jo.WorldUVGenerator = {
        generateTopUV: function(t, e, i, n, r) {
            var o = e[3 * i],
                a = e[3 * i + 1],
                s = e[3 * n],
                l = e[3 * n + 1],
                h = e[3 * r],
                c = e[3 * r + 1];
            return [new We(o, a), new We(s, l), new We(h, c)]
        },
        generateSideWallUV: function(t, e, i, n, r, o) {
            var a = e[3 * i],
                s = e[3 * i + 1],
                l = e[3 * i + 2],
                h = e[3 * n],
                c = e[3 * n + 1],
                u = e[3 * n + 2],
                p = e[3 * r],
                d = e[3 * r + 1],
                f = e[3 * r + 2],
                m = e[3 * o],
                v = e[3 * o + 1],
                g = e[3 * o + 2];
            return Math.abs(s - c) < .01 ? [new We(a, 1 - l), new We(h, 1 - u), new We(p, 1 - f), new We(m, 1 - g)] : [new We(s, 1 - l), new We(c, 1 - u), new We(d, 1 - f), new We(v, 1 - g)]
        }
    }, qo.prototype = Object.create(Ii.prototype), qo.prototype.constructor = qo, Xo.prototype = Object.create(Wo.prototype), Xo.prototype.constructor = Xo, Yo.prototype = Object.create(Ii.prototype), Yo.prototype.constructor = Yo, Zo.prototype = Object.create(Yi.prototype), Zo.prototype.constructor = Zo, Jo.prototype = Object.create(Ii.prototype), Jo.prototype.constructor = Jo, Ko.prototype = Object.create(Yi.prototype), Ko.prototype.constructor = Ko, Qo.prototype = Object.create(Ii.prototype), Qo.prototype.constructor = Qo, $o.prototype = Object.create(Yi.prototype), $o.prototype.constructor = $o, ta.prototype = Object.create(Ii.prototype), ta.prototype.constructor = ta, ta.prototype.toJSON = function() {
        var t = Ii.prototype.toJSON.call(this);
        return ia(this.parameters.shapes, t)
    }, ea.prototype = Object.create(Yi.prototype), ea.prototype.constructor = ea, ea.prototype.toJSON = function() {
        var t = Yi.prototype.toJSON.call(this);
        return ia(this.parameters.shapes, t)
    }, na.prototype = Object.create(Yi.prototype), na.prototype.constructor = na, ra.prototype = Object.create(Ii.prototype), ra.prototype.constructor = ra, oa.prototype = Object.create(Yi.prototype), oa.prototype.constructor = oa, aa.prototype = Object.create(ra.prototype), aa.prototype.constructor = aa, sa.prototype = Object.create(oa.prototype), sa.prototype.constructor = sa, la.prototype = Object.create(Ii.prototype), la.prototype.constructor = la, ha.prototype = Object.create(Yi.prototype), ha.prototype.constructor = ha;
    var ca = Object.freeze({
        WireframeGeometry: to,
        ParametricGeometry: eo,
        ParametricBufferGeometry: io,
        TetrahedronGeometry: oo,
        TetrahedronBufferGeometry: ao,
        OctahedronGeometry: so,
        OctahedronBufferGeometry: lo,
        IcosahedronGeometry: ho,
        IcosahedronBufferGeometry: co,
        DodecahedronGeometry: uo,
        DodecahedronBufferGeometry: po,
        PolyhedronGeometry: no,
        PolyhedronBufferGeometry: ro,
        TubeGeometry: fo,
        TubeBufferGeometry: mo,
        TorusKnotGeometry: vo,
        TorusKnotBufferGeometry: go,
        TorusGeometry: yo,
        TorusBufferGeometry: _o,
        TextGeometry: qo,
        TextBufferGeometry: Xo,
        SphereGeometry: Yo,
        SphereBufferGeometry: Zo,
        RingGeometry: Jo,
        RingBufferGeometry: Ko,
        PlaneGeometry: Ki,
        PlaneBufferGeometry: Qi,
        LatheGeometry: Qo,
        LatheBufferGeometry: $o,
        ShapeGeometry: ta,
        ShapeBufferGeometry: ea,
        ExtrudeGeometry: jo,
        ExtrudeBufferGeometry: Wo,
        EdgesGeometry: na,
        ConeGeometry: aa,
        ConeBufferGeometry: sa,
        CylinderGeometry: ra,
        CylinderBufferGeometry: oa,
        CircleGeometry: la,
        CircleBufferGeometry: ha,
        BoxGeometry: Zi,
        BoxBufferGeometry: Ji
    });

    function ua(t) {
        ln.call(this), this.type = "ShadowMaterial", this.color = new vi(0), this.transparent = !0, this.setValues(t)
    }

    function pa(t) {
        cn.call(this, t), this.type = "RawShaderMaterial"
    }

    function da(t) {
        ln.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new vi(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function fa(t) {
        da.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
    }

    function ma(t) {
        ln.call(this), this.type = "MeshPhongMaterial", this.color = new vi(16777215), this.specular = new vi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = lt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function va(t) {
        ma.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
    }

    function ga(t) {
        ln.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new We(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function ya(t) {
        ln.call(this), this.type = "MeshLambertMaterial", this.color = new vi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new vi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = lt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
    }

    function _a(t) {
        Gr.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }
    ua.prototype = Object.create(ln.prototype), ua.prototype.constructor = ua, ua.prototype.isShadowMaterial = !0, ua.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this
    }, pa.prototype = Object.create(cn.prototype), pa.prototype.constructor = pa, pa.prototype.isRawShaderMaterial = !0, da.prototype = Object.create(ln.prototype), da.prototype.constructor = da, da.prototype.isMeshStandardMaterial = !0, da.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, fa.prototype = Object.create(da.prototype), fa.prototype.constructor = fa, fa.prototype.isMeshPhysicalMaterial = !0, fa.prototype.copy = function(t) {
        return da.prototype.copy.call(this, t), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
    }, ma.prototype = Object.create(ln.prototype), ma.prototype.constructor = ma, ma.prototype.isMeshPhongMaterial = !0, ma.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, va.prototype = Object.create(ma.prototype), va.prototype.constructor = va, va.prototype.isMeshToonMaterial = !0, va.prototype.copy = function(t) {
        return ma.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
    }, ga.prototype = Object.create(ln.prototype), ga.prototype.constructor = ga, ga.prototype.isMeshNormalMaterial = !0, ga.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, ya.prototype = Object.create(ln.prototype), ya.prototype.constructor = ya, ya.prototype.isMeshLambertMaterial = !0, ya.prototype.copy = function(t) {
        return ln.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, _a.prototype = Object.create(Gr.prototype), _a.prototype.constructor = _a, _a.prototype.isLineDashedMaterial = !0, _a.prototype.copy = function(t) {
        return Gr.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    };
    var xa = Object.freeze({
            ShadowMaterial: ua,
            SpriteMaterial: Fr,
            RawShaderMaterial: pa,
            ShaderMaterial: cn,
            PointsMaterial: Xr,
            MeshPhysicalMaterial: fa,
            MeshStandardMaterial: da,
            MeshPhongMaterial: ma,
            MeshToonMaterial: va,
            MeshNormalMaterial: ga,
            MeshLambertMaterial: ya,
            MeshDepthMaterial: Er,
            MeshDistanceMaterial: Mr,
            MeshBasicMaterial: hn,
            LineDashedMaterial: _a,
            LineBasicMaterial: Gr,
            Material: ln
        }),
        ba = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };

    function wa(t, e, i) {
        var n = this,
            r = !1,
            o = 0,
            a = 0,
            s = void 0;
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
            a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0
        }, this.itemEnd = function(t) {
            o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
        }, this.itemError = function(t) {
            void 0 !== n.onError && n.onError(t)
        }, this.resolveURL = function(t) {
            return s ? s(t) : t
        }, this.setURLModifier = function(t) {
            return s = t, this
        }
    }
    var Ta = new wa,
        Ea = {};

    function Ma(t) {
        this.manager = void 0 !== t ? t : Ta
    }

    function Sa(t) {
        this.manager = void 0 !== t ? t : Ta, this._parser = null
    }

    function Aa(t) {
        this.manager = void 0 !== t ? t : Ta, this._parser = null
    }

    function Ca(t) {
        this.manager = void 0 !== t ? t : Ta
    }

    function Ra(t) {
        this.manager = void 0 !== t ? t : Ta
    }

    function Pa(t) {
        this.manager = void 0 !== t ? t : Ta
    }

    function La() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function Oa(t, e, i, n, r, o, a, s) {
        La.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
    }

    function Ba(t, e, i, n, r, o) {
        Oa.call(this, t, e, i, i, n, r, o), this.type = "ArcCurve"
    }

    function Ia() {
        var t = 0,
            e = 0,
            i = 0,
            n = 0;

        function r(r, o, a, s) {
            t = r, e = a, i = -3 * r + 3 * o - 2 * a - s, n = 2 * r - 2 * o + a + s
        }
        return {
            initCatmullRom: function(t, e, i, n, o) {
                r(e, i, o * (i - t), o * (n - e))
            },
            initNonuniformCatmullRom: function(t, e, i, n, o, a, s) {
                var l = (e - t) / o - (i - t) / (o + a) + (i - e) / a,
                    h = (i - e) / a - (n - e) / (a + s) + (n - i) / s;
                r(e, i, l *= a, h *= a)
            },
            calc: function(r) {
                var o = r * r;
                return t + e * r + i * o + n * (o * r)
            }
        }
    }
    Object.assign(Ma.prototype, {
        load: function(t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this,
                o = ba.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                e && e(o), r.manager.itemEnd(t)
            }, 0), o;
            if (void 0 === Ea[t]) {
                var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1],
                        l = !!a[2],
                        h = a[3];
                    h = window.decodeURIComponent(h), l && (h = window.atob(h));
                    try {
                        var c, u = (this.responseType || "").toLowerCase();
                        switch (u) {
                            case "arraybuffer":
                            case "blob":
                                for (var p = new Uint8Array(h.length), d = 0; d < h.length; d++) p[d] = h.charCodeAt(d);
                                c = "blob" === u ? new Blob([p.buffer], {
                                    type: s
                                }) : p.buffer;
                                break;
                            case "document":
                                var f = new DOMParser;
                                c = f.parseFromString(h, s);
                                break;
                            case "json":
                                c = JSON.parse(h);
                                break;
                            default:
                                c = h
                        }
                        window.setTimeout(function() {
                            e && e(c), r.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function() {
                            n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                        }, 0)
                    }
                } else {
                    Ea[t] = [], Ea[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    });
                    var m = new XMLHttpRequest;
                    for (var v in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                            var i = this.response;
                            ba.add(t, i);
                            var n = Ea[t];
                            if (delete Ea[t], 200 === this.status) {
                                for (var o = 0, a = n.length; o < a; o++)(s = n[o]).onLoad && s.onLoad(i);
                                r.manager.itemEnd(t)
                            } else if (0 === this.status) {
                                for (console.warn("THREE.FileLoader: HTTP Status 0 received."), o = 0, a = n.length; o < a; o++)(s = n[o]).onLoad && s.onLoad(i);
                                r.manager.itemEnd(t)
                            } else {
                                for (o = 0, a = n.length; o < a; o++) {
                                    var s;
                                    (s = n[o]).onError && s.onError(e)
                                }
                                r.manager.itemEnd(t), r.manager.itemError(t)
                            }
                        }, !1), m.addEventListener("progress", function(e) {
                            for (var i = Ea[t], n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                o.onProgress && o.onProgress(e)
                            }
                        }, !1), m.addEventListener("error", function(e) {
                            var i = Ea[t];
                            delete Ea[t];
                            for (var n = 0, o = i.length; n < o; n++) {
                                var a = i[n];
                                a.onError && a.onError(e)
                            }
                            r.manager.itemEnd(t), r.manager.itemError(t)
                        }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                    m.send(null)
                }
                return r.manager.itemStart(t), m
            }
            Ea[t].push({
                onLoad: e,
                onProgress: i,
                onError: n
            })
        },
        setPath: function(t) {
            return this.path = t, this
        },
        setResponseType: function(t) {
            return this.responseType = t, this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t, this
        },
        setMimeType: function(t) {
            return this.mimeType = t, this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t, this
        }
    }), Object.assign(Sa.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                o = [],
                a = new Kr;
            a.image = o;
            var s = new Ma(this.manager);

            function l(l) {
                s.load(t[l], function(t) {
                    var i = r._parser(t, !0);
                    o[l] = {
                        width: i.width,
                        height: i.height,
                        format: i.format,
                        mipmaps: i.mipmaps
                    }, 6 === (h += 1) && (1 === i.mipmapCount && (a.minFilter = Pt), a.format = i.format, a.needsUpdate = !0, e && e(a))
                }, i, n)
            }
            if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                for (var h = 0, c = 0, u = t.length; c < u; ++c) l(c);
            else s.load(t, function(t) {
                var i = r._parser(t, !0);
                if (i.isCubemap)
                    for (var n = i.mipmaps.length / i.mipmapCount, s = 0; s < n; s++) {
                        o[s] = {
                            mipmaps: []
                        };
                        for (var l = 0; l < i.mipmapCount; l++) o[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + l]), o[s].format = i.format, o[s].width = i.width, o[s].height = i.height
                    } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                1 === i.mipmapCount && (a.minFilter = Pt), a.format = i.format, a.needsUpdate = !0, e && e(a)
            }, i, n);
            return a
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(Aa.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                o = new si,
                a = new Ma(this.manager);
            return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                var i = r._parser(t);
                i && (void 0 !== i.image ? o.image = i.image : void 0 !== i.data && (o.image.width = i.width, o.image.height = i.height, o.image.data = i.data), o.wrapS = void 0 !== i.wrapS ? i.wrapS : Mt, o.wrapT = void 0 !== i.wrapT ? i.wrapT : Mt, o.magFilter = void 0 !== i.magFilter ? i.magFilter : Pt, o.minFilter = void 0 !== i.minFilter ? i.minFilter : Ot, o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (o.format = i.format), void 0 !== i.type && (o.type = i.type), void 0 !== i.mipmaps && (o.mipmaps = i.mipmaps), 1 === i.mipmapCount && (o.minFilter = Pt), o.needsUpdate = !0, e && e(o, i))
            }, i, n), o
        }
    }), Object.assign(Ca.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this,
                o = ba.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                e && e(o), r.manager.itemEnd(t)
            }, 0), o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return a.addEventListener("load", function() {
                ba.add(t, this), e && e(this), r.manager.itemEnd(t)
            }, !1), a.addEventListener("error", function(e) {
                n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
            }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(Ra.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, i, n) {
            var r = new vn,
                o = new Ca(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var a = 0;

            function s(i) {
                o.load(t[i], function(t) {
                    r.images[i] = t, 6 == ++a && (r.needsUpdate = !0, e && e(r))
                }, void 0, n)
            }
            for (var l = 0; l < t.length; ++l) s(l);
            return r
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(Pa.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, i, n) {
            var r = new ni,
                o = new Ca(this.manager);
            return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(i) {
                r.image = i;
                var n = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                r.format = n ? qt : Xt, r.needsUpdate = !0, void 0 !== e && e(r)
            }, i, n), r
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t, this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }), Object.assign(La.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        },
        getPointAt: function(t, e) {
            var i = this.getUtoTmapping(t);
            return this.getPoint(i, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, i, n = [],
                r = this.getPoint(0),
                o = 0;
            for (n.push(0), i = 1; i <= t; i++) o += (e = this.getPoint(i / t)).distanceTo(r), n.push(o), r = e;
            return this.cacheArcLengths = n, n
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var i, n = this.getLengths(),
                r = 0,
                o = n.length;
            i = e || t * n[o - 1];
            for (var a, s = 0, l = o - 1; s <= l;)
                if ((a = n[r = Math.floor(s + (l - s) / 2)] - i) < 0) s = r + 1;
                else {
                    if (!(a > 0)) {
                        l = r;
                        break
                    }
                    l = r - 1
                }
            if (n[r = l] === i) return r / (o - 1);
            var h = n[r];
            return (r + (i - h) / (n[r + 1] - h)) / (o - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4,
                i = t + 1e-4;
            e < 0 && (e = 0), i > 1 && (i = 1);
            var n = this.getPoint(e);
            return this.getPoint(i).clone().sub(n).normalize()
        },
        getTangentAt: function(t) {
            var e = this.getUtoTmapping(t);
            return this.getTangent(e)
        },
        computeFrenetFrames: function(t, e) {
            var i, n, r, o = new Ye,
                a = [],
                s = [],
                l = [],
                h = new Ye,
                c = new qe;
            for (i = 0; i <= t; i++) n = i / t, a[i] = this.getTangentAt(n), a[i].normalize();
            s[0] = new Ye, l[0] = new Ye;
            var u = Number.MAX_VALUE,
                p = Math.abs(a[0].x),
                d = Math.abs(a[0].y),
                f = Math.abs(a[0].z);
            for (p <= u && (u = p, o.set(1, 0, 0)), d <= u && (u = d, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), h.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], h), l[0].crossVectors(a[0], s[0]), i = 1; i <= t; i++) s[i] = s[i - 1].clone(), l[i] = l[i - 1].clone(), h.crossVectors(a[i - 1], a[i]), h.length() > Number.EPSILON && (h.normalize(), r = Math.acos(je.clamp(a[i - 1].dot(a[i]), -1, 1)), s[i].applyMatrix4(c.makeRotationAxis(h, r))), l[i].crossVectors(a[i], s[i]);
            if (!0 === e)
                for (r = Math.acos(je.clamp(s[0].dot(s[t]), -1, 1)), r /= t, a[0].dot(h.crossVectors(s[0], s[t])) > 0 && (r = -r), i = 1; i <= t; i++) s[i].applyMatrix4(c.makeRotationAxis(a[i], r * i)), l[i].crossVectors(a[i], s[i]);
            return {
                tangents: a,
                normals: s,
                binormals: l
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }), Oa.prototype = Object.create(La.prototype), Oa.prototype.constructor = Oa, Oa.prototype.isEllipseCurve = !0, Oa.prototype.getPoint = function(t, e) {
        for (var i = e || new We, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r === n ? r = -n : r -= n);
        var a = this.aStartAngle + t * r,
            s = this.aX + this.xRadius * Math.cos(a),
            l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var h = Math.cos(this.aRotation),
                c = Math.sin(this.aRotation),
                u = s - this.aX,
                p = l - this.aY;
            s = u * h - p * c + this.aX, l = u * c + p * h + this.aY
        }
        return i.set(s, l)
    }, Oa.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, Oa.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }, Oa.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, Ba.prototype = Object.create(Oa.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isArcCurve = !0;
    var Na = new Ye,
        za = new Ia,
        Fa = new Ia,
        Da = new Ia;

    function Ua(t, e, i, n) {
        La.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
    }

    function ka(t, e, i, n, r) {
        var o = .5 * (n - e),
            a = .5 * (r - i),
            s = t * t;
        return (2 * i - 2 * n + o + a) * (t * s) + (-3 * i + 3 * n - 2 * o - a) * s + o * t + i
    }

    function Va(t, e, i, n) {
        return function(t, e) {
            var i = 1 - t;
            return i * i * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * i
        }(t) + function(t, e) {
            return t * t * n
        }(t)
    }

    function Ha(t, e, i, n, r) {
        return function(t, e) {
            var i = 1 - t;
            return i * i * i * e
        }(t, e) + function(t, e) {
            var i = 1 - t;
            return 3 * i * i * t * e
        }(t, i) + function(t, e) {
            return 3 * (1 - t) * t * t * n
        }(t) + function(t, e) {
            return t * t * t * r
        }(t)
    }

    function Ga(t, e, i, n) {
        La.call(this), this.type = "CubicBezierCurve", this.v0 = t || new We, this.v1 = e || new We, this.v2 = i || new We, this.v3 = n || new We
    }

    function ja(t, e, i, n) {
        La.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Ye, this.v1 = e || new Ye, this.v2 = i || new Ye, this.v3 = n || new Ye
    }

    function Wa(t, e) {
        La.call(this), this.type = "LineCurve", this.v1 = t || new We, this.v2 = e || new We
    }

    function qa(t, e) {
        La.call(this), this.type = "LineCurve3", this.v1 = t || new Ye, this.v2 = e || new Ye
    }

    function Xa(t, e, i) {
        La.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new We, this.v1 = e || new We, this.v2 = i || new We
    }

    function Ya(t, e, i) {
        La.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Ye, this.v1 = e || new Ye, this.v2 = i || new Ye
    }

    function Za(t) {
        La.call(this), this.type = "SplineCurve", this.points = t || []
    }
    Ua.prototype = Object.create(La.prototype), Ua.prototype.constructor = Ua, Ua.prototype.isCatmullRomCurve3 = !0, Ua.prototype.getPoint = function(t, e) {
        var i, n, r, o, a = e || new Ye,
            s = this.points,
            l = s.length,
            h = (l - (this.closed ? 0 : 1)) * t,
            c = Math.floor(h),
            u = h - c;
        if (this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / s.length) + 1) * s.length : 0 === u && c === l - 1 && (c = l - 2, u = 1), this.closed || c > 0 ? i = s[(c - 1) % l] : (Na.subVectors(s[0], s[1]).add(s[0]), i = Na), n = s[c % l], r = s[(c + 1) % l], this.closed || c + 2 < l ? o = s[(c + 2) % l] : (Na.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), o = Na), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var p = "chordal" === this.curveType ? .5 : .25,
                d = Math.pow(i.distanceToSquared(n), p),
                f = Math.pow(n.distanceToSquared(r), p),
                m = Math.pow(r.distanceToSquared(o), p);
            f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), za.initNonuniformCatmullRom(i.x, n.x, r.x, o.x, d, f, m), Fa.initNonuniformCatmullRom(i.y, n.y, r.y, o.y, d, f, m), Da.initNonuniformCatmullRom(i.z, n.z, r.z, o.z, d, f, m)
        } else "catmullrom" === this.curveType && (za.initCatmullRom(i.x, n.x, r.x, o.x, this.tension), Fa.initCatmullRom(i.y, n.y, r.y, o.y, this.tension), Da.initCatmullRom(i.z, n.z, r.z, o.z, this.tension));
        return a.set(za.calc(u), Fa.calc(u), Da.calc(u)), a
    }, Ua.prototype.copy = function(t) {
        La.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) {
            var n = t.points[e];
            this.points.push(n.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, Ua.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, i = this.points.length; e < i; e++) {
            var n = this.points[e];
            t.points.push(n.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }, Ua.prototype.fromJSON = function(t) {
        La.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) {
            var n = t.points[e];
            this.points.push((new Ye).fromArray(n))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, Ga.prototype = Object.create(La.prototype), Ga.prototype.constructor = Ga, Ga.prototype.isCubicBezierCurve = !0, Ga.prototype.getPoint = function(t, e) {
        var i = e || new We,
            n = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(Ha(t, n.x, r.x, o.x, a.x), Ha(t, n.y, r.y, o.y, a.y)), i
    }, Ga.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Ga.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Ga.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, ja.prototype = Object.create(La.prototype), ja.prototype.constructor = ja, ja.prototype.isCubicBezierCurve3 = !0, ja.prototype.getPoint = function(t, e) {
        var i = e || new Ye,
            n = this.v0,
            r = this.v1,
            o = this.v2,
            a = this.v3;
        return i.set(Ha(t, n.x, r.x, o.x, a.x), Ha(t, n.y, r.y, o.y, a.y), Ha(t, n.z, r.z, o.z, a.z)), i
    }, ja.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, ja.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, ja.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, Wa.prototype = Object.create(La.prototype), Wa.prototype.constructor = Wa, Wa.prototype.isLineCurve = !0, Wa.prototype.getPoint = function(t, e) {
        var i = e || new We;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
    }, Wa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }, Wa.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }, Wa.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Wa.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Wa.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, qa.prototype = Object.create(La.prototype), qa.prototype.constructor = qa, qa.prototype.isLineCurve3 = !0, qa.prototype.getPoint = function(t, e) {
        var i = e || new Ye;
        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
    }, qa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }, qa.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, qa.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, qa.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Xa.prototype = Object.create(La.prototype), Xa.prototype.constructor = Xa, Xa.prototype.isQuadraticBezierCurve = !0, Xa.prototype.getPoint = function(t, e) {
        var i = e || new We,
            n = this.v0,
            r = this.v1,
            o = this.v2;
        return i.set(Va(t, n.x, r.x, o.x), Va(t, n.y, r.y, o.y)), i
    }, Xa.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Xa.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Xa.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Ya.prototype = Object.create(La.prototype), Ya.prototype.constructor = Ya, Ya.prototype.isQuadraticBezierCurve3 = !0, Ya.prototype.getPoint = function(t, e) {
        var i = e || new Ye,
            n = this.v0,
            r = this.v1,
            o = this.v2;
        return i.set(Va(t, n.x, r.x, o.x), Va(t, n.y, r.y, o.y), Va(t, n.z, r.z, o.z)), i
    }, Ya.prototype.copy = function(t) {
        return La.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Ya.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Ya.prototype.fromJSON = function(t) {
        return La.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Za.prototype = Object.create(La.prototype), Za.prototype.constructor = Za, Za.prototype.isSplineCurve = !0, Za.prototype.getPoint = function(t, e) {
        var i = e || new We,
            n = this.points,
            r = (n.length - 1) * t,
            o = Math.floor(r),
            a = r - o,
            s = n[0 === o ? o : o - 1],
            l = n[o],
            h = n[o > n.length - 2 ? n.length - 1 : o + 1],
            c = n[o > n.length - 3 ? n.length - 1 : o + 2];
        return i.set(ka(a, s.x, l.x, h.x, c.x), ka(a, s.y, l.y, h.y, c.y)), i
    }, Za.prototype.copy = function(t) {
        La.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) {
            var n = t.points[e];
            this.points.push(n.clone())
        }
        return this
    }, Za.prototype.toJSON = function() {
        var t = La.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, i = this.points.length; e < i; e++) {
            var n = this.points[e];
            t.points.push(n.toArray())
        }
        return t
    }, Za.prototype.fromJSON = function(t) {
        La.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) {
            var n = t.points[e];
            this.points.push((new We).fromArray(n))
        }
        return this
    };
    var Ja = Object.freeze({
        ArcCurve: Ba,
        CatmullRomCurve3: Ua,
        CubicBezierCurve: Ga,
        CubicBezierCurve3: ja,
        EllipseCurve: Oa,
        LineCurve: Wa,
        LineCurve3: qa,
        QuadraticBezierCurve: Xa,
        QuadraticBezierCurve3: Ya,
        SplineCurve: Za
    });

    function Ka() {
        La.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function Qa(t) {
        Ka.call(this), this.type = "Path", this.currentPoint = new We, t && this.setFromPoints(t)
    }

    function $a(t) {
        Qa.call(this, t), this.uuid = je.generateUUID(), this.type = "Shape", this.holes = []
    }

    function ts(t, e) {
        Ai.call(this), this.type = "Light", this.color = new vi(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
    }

    function es(t, e, i) {
        ts.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Ai.DefaultUp), this.updateMatrix(), this.groundColor = new vi(e)
    }

    function is(t) {
        this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new We(512, 512), this.map = null, this.matrix = new qe
    }

    function ns() {
        is.call(this, new Pr(50, 1, .5, 500))
    }

    function rs(t, e, i, n, r, o) {
        ts.call(this, t, e), this.type = "SpotLight", this.position.copy(Ai.DefaultUp), this.updateMatrix(), this.target = new Ai, Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new ns
    }

    function os(t, e, i, n) {
        ts.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new is(new Pr(90, 1, .5, 500))
    }

    function as() {
        is.call(this, new Ri(-5, 5, 5, -5, .5, 500))
    }

    function ss(t, e) {
        ts.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Ai.DefaultUp), this.updateMatrix(), this.target = new Ai, this.shadow = new as
    }

    function ls(t, e) {
        ts.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
    }

    function hs(t, e, i, n) {
        ts.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function cs(t, e, i, n) {
        bs.call(this, t, e, i, n)
    }

    function us(t, e, i) {
        bs.call(this, t, e, i)
    }

    function ps(t, e, i, n) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
    }

    function ds(t, e, i, n) {
        ps.call(this, t, e, i, n)
    }

    function fs(t, e, i, n) {
        bs.call(this, t, e, i, n)
    }

    function ms(t, e, i, n) {
        bs.call(this, t, e, i, n)
    }

    function vs(t, e, i, n) {
        bs.call(this, t, e, i, n)
    }

    function gs(t, e, i, n) {
        ps.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function ys(t, e, i, n) {
        ps.call(this, t, e, i, n)
    }

    function _s(t, e, i, n) {
        ps.call(this, t, e, i, n)
    }
    Ka.prototype = Object.assign(Object.create(La.prototype), {
        constructor: Ka,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0),
                e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Wa(e, t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                if (i[n] >= e) {
                    var r = i[n] - e,
                        o = this.curves[n],
                        a = o.getLength(),
                        s = 0 === a ? 0 : 1 - r / a;
                    return o.getPointAt(s)
                }
                n++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
            return this.cacheLengths = t, t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
            return this.autoClose && e.push(e[0]), e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                for (var o = r[n], a = o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), l = 0; l < s.length; l++) {
                    var h = s[l];
                    e && e.equals(h) || (i.push(h), e = h)
                }
            return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        },
        copy: function(t) {
            La.prototype.copy.call(this, t), this.curves = [];
            for (var e = 0, i = t.curves.length; e < i; e++) {
                var n = t.curves[e];
                this.curves.push(n.clone())
            }
            return this.autoClose = t.autoClose, this
        },
        toJSON: function() {
            var t = La.prototype.toJSON.call(this);
            t.autoClose = this.autoClose, t.curves = [];
            for (var e = 0, i = this.curves.length; e < i; e++) {
                var n = this.curves[e];
                t.curves.push(n.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            La.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
            for (var e = 0, i = t.curves.length; e < i; e++) {
                var n = t.curves[e];
                this.curves.push((new Ja[n.type]).fromJSON(n))
            }
            return this
        }
    }), Qa.prototype = Object.assign(Object.create(Ka.prototype), {
        constructor: Qa,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
        },
        moveTo: function(t, e) {
            this.currentPoint.set(t, e)
        },
        lineTo: function(t, e) {
            var i = new Wa(this.currentPoint.clone(), new We(t, e));
            this.curves.push(i), this.currentPoint.set(t, e)
        },
        quadraticCurveTo: function(t, e, i, n) {
            var r = new Xa(this.currentPoint.clone(), new We(t, e), new We(i, n));
            this.curves.push(r), this.currentPoint.set(i, n)
        },
        bezierCurveTo: function(t, e, i, n, r, o) {
            var a = new Ga(this.currentPoint.clone(), new We(t, e), new We(i, n), new We(r, o));
            this.curves.push(a), this.currentPoint.set(r, o)
        },
        splineThru: function(t) {
            var e = new Za([this.currentPoint.clone()].concat(t));
            this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
        },
        arc: function(t, e, i, n, r, o) {
            var a = this.currentPoint.x,
                s = this.currentPoint.y;
            this.absarc(t + a, e + s, i, n, r, o)
        },
        absarc: function(t, e, i, n, r, o) {
            this.absellipse(t, e, i, i, n, r, o)
        },
        ellipse: function(t, e, i, n, r, o, a, s) {
            var l = this.currentPoint.x,
                h = this.currentPoint.y;
            this.absellipse(t + l, e + h, i, n, r, o, a, s)
        },
        absellipse: function(t, e, i, n, r, o, a, s) {
            var l = new Oa(t, e, i, n, r, o, a, s);
            if (this.curves.length > 0) {
                var h = l.getPoint(0);
                h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
            }
            this.curves.push(l);
            var c = l.getPoint(1);
            this.currentPoint.copy(c)
        },
        copy: function(t) {
            return Ka.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
        },
        toJSON: function() {
            var t = Ka.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(), t
        },
        fromJSON: function(t) {
            return Ka.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
        }
    }), $a.prototype = Object.assign(Object.create(Qa.prototype), {
        constructor: $a,
        getPointsHoles: function(t) {
            for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            Qa.prototype.copy.call(this, t), this.holes = [];
            for (var e = 0, i = t.holes.length; e < i; e++) {
                var n = t.holes[e];
                this.holes.push(n.clone())
            }
            return this
        },
        toJSON: function() {
            var t = Qa.prototype.toJSON.call(this);
            t.uuid = this.uuid, t.holes = [];
            for (var e = 0, i = this.holes.length; e < i; e++) {
                var n = this.holes[e];
                t.holes.push(n.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Qa.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
            for (var e = 0, i = t.holes.length; e < i; e++) {
                var n = t.holes[e];
                this.holes.push((new Qa).fromJSON(n))
            }
            return this
        }
    }), ts.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: ts,
        isLight: !0,
        copy: function(t) {
            return Ai.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
        },
        toJSON: function(t) {
            var e = Ai.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }), es.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: es,
        isHemisphereLight: !0,
        copy: function(t) {
            return ts.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        }
    }), Object.assign(is.prototype, {
        copy: function(t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }), ns.prototype = Object.assign(Object.create(is.prototype), {
        constructor: ns,
        isSpotLightShadow: !0,
        update: function(t) {
            var e = this.camera,
                i = 2 * je.RAD2DEG * t.angle,
                n = this.mapSize.width / this.mapSize.height,
                r = t.distance || e.far;
            i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix())
        }
    }), rs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: rs,
        isSpotLight: !0,
        copy: function(t) {
            return ts.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), os.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: os,
        isPointLight: !0,
        copy: function(t) {
            return ts.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }), as.prototype = Object.assign(Object.create(is.prototype), {
        constructor: as
    }), ss.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: ss,
        isDirectionalLight: !0,
        copy: function(t) {
            return ts.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), ls.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: ls,
        isAmbientLight: !0
    }), hs.prototype = Object.assign(Object.create(ts.prototype), {
        constructor: hs,
        isRectAreaLight: !0,
        copy: function(t) {
            return ts.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
        },
        toJSON: function(t) {
            var e = ts.prototype.toJSON.call(this, t);
            return e.object.width = this.width, e.object.height = this.height, e
        }
    }), cs.prototype = Object.assign(Object.create(bs.prototype), {
        constructor: cs,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: Me,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), us.prototype = Object.assign(Object.create(bs.prototype), {
        constructor: us,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: Me,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Object.assign(ps.prototype, {
        evaluate: function(t) {
            var e = this.parameterPositions,
                i = this._cachedIndex,
                n = e[i],
                r = e[i - 1];
            t: {
                e: {
                    var o;i: {
                        n: if (!(t < n)) {
                            for (var a = i + 2;;) {
                                if (void 0 === n) {
                                    if (t < r) break n;
                                    return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                }
                                if (i === a) break;
                                if (r = n, t < (n = e[++i])) break e
                            }
                            o = e.length;
                            break i
                        }if (t >= r) break t;
                        var s = e[1];
                        for (t < s && (i = 2, r = s), a = i - 2;;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                            if (i === a) break;
                            if (n = r, t >= (r = e[--i - 1])) break e
                        }
                        o = i,
                        i = 0
                    }
                    for (; i < o;) {
                        var l = i + o >>> 1;
                        t < e[l] ? o = l : i = l + 1
                    }
                    if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                    if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, t, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, o = 0; o !== n; ++o) e[o] = i[r + o];
            return e
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }), Object.assign(ps.prototype, {
        beforeStart_: ps.prototype.copySampleValue_,
        afterEnd_: ps.prototype.copySampleValue_
    }), ds.prototype = Object.assign(Object.create(ps.prototype), {
        constructor: ds,
        interpolate_: function(t, e, i, n) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = (i - e) / (n - e), h = s + a; s !== h; s += 4) Xe.slerpFlat(r, 0, o, s - a, o, s, l);
            return r
        }
    }), fs.prototype = Object.assign(Object.create(bs.prototype), {
        constructor: fs,
        ValueTypeName: "quaternion",
        DefaultInterpolation: Se,
        InterpolantFactoryMethodLinear: function(t) {
            return new ds(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), ms.prototype = Object.assign(Object.create(bs.prototype), {
        constructor: ms,
        ValueTypeName: "color"
    }), vs.prototype = Object.assign(Object.create(bs.prototype), {
        constructor: vs,
        ValueTypeName: "number"
    }), gs.prototype = Object.assign(Object.create(ps.prototype), {
        constructor: gs,
        DefaultSettings_: {
            endingStart: Ce,
            endingEnd: Ce
        },
        intervalChanged_: function(t, e, i) {
            var n = this.parameterPositions,
                r = t - 2,
                o = t + 1,
                a = n[r],
                s = n[o];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case Re:
                    r = t, a = 2 * e - i;
                    break;
                case Pe:
                    a = e + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = t, a = i
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case Re:
                    o = t, s = 2 * i - e;
                    break;
                case Pe:
                    o = 1, s = i + n[1] - n[0];
                    break;
                default:
                    o = t - 1, s = e
            }
            var l = .5 * (i - e),
                h = this.valueSize;
            this._weightPrev = l / (e - a), this._weightNext = l / (s - i), this._offsetPrev = r * h, this._offsetNext = o * h
        },
        interpolate_: function(t, e, i, n) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, h = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m = f * d, v = -u * m + 2 * u * f - u * d, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, _ = p * m - p * f, x = 0; x !== a; ++x) r[x] = v * o[h + x] + g * o[l + x] + y * o[s + x] + _ * o[c + x];
            return r
        }
    }), ys.prototype = Object.assign(Object.create(ps.prototype), {
        constructor: ys,
        interpolate_: function(t, e, i, n) {
            for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, l = s - a, h = (i - e) / (n - e), c = 1 - h, u = 0; u !== a; ++u) r[u] = o[l + u] * c + o[s + u] * h;
            return r
        }
    }), _s.prototype = Object.assign(Object.create(ps.prototype), {
        constructor: _s,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    });
    var xs = {
        arraySlice: function(t, e, i) {
            return xs.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
        },
        convertArray: function(t, e, i) {
            return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
            return i.sort(function(e, i) {
                return t[e] - t[i]
            }), i
        },
        sortedArray: function(t, e, i) {
            for (var n = t.length, r = new t.constructor(n), o = 0, a = 0; a !== n; ++o)
                for (var s = i[o] * e, l = 0; l !== e; ++l) r[a++] = t[s + l];
            return r
        },
        flattenJSON: function(t, e, i, n) {
            for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];) o = t[r++];
            if (void 0 !== o) {
                var a = o[n];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = o[n]) && (e.push(o.time), i.push.apply(i, a)), o = t[r++]
                        } while (void 0 !== o);
                    else if (void 0 !== a.toArray)
                    do {
                        void 0 !== (a = o[n]) && (e.push(o.time), a.toArray(i, i.length)), o = t[r++]
                    } while (void 0 !== o);
                else
                    do {
                        void 0 !== (a = o[n]) && (e.push(o.time), i.push(a)), o = t[r++]
                    } while (void 0 !== o)
            }
        }
    };

    function bs(t, e, i, n) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = xs.convertArray(e, this.TimeBufferType), this.values = xs.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
    }

    function ws(t, e, i, n) {
        bs.call(this, t, e, i, n)
    }

    function Ts(t, e, i) {
        this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = je.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
    }

    function Es(t) {
        this.manager = void 0 !== t ? t : Ta, this.textures = {}
    }

    function Ms(t) {
        this.manager = void 0 !== t ? t : Ta
    }
    Object.assign(bs, {
        parse: function(t) {
            if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var e = bs._getTrackTypeForValueTypeName(t.type);
            if (void 0 === t.times) {
                var i = [],
                    n = [];
                xs.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        },
        toJSON: function(t) {
            var e, i = t.constructor;
            if (void 0 !== i.toJSON) e = i.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: xs.convertArray(t.times, Array),
                    values: xs.convertArray(t.values, Array)
                };
                var n = t.getInterpolation();
                n !== t.DefaultInterpolation && (e.interpolation = n)
            }
            return e.type = t.ValueTypeName, e
        },
        _getTrackTypeForValueTypeName: function(t) {
            switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return vs;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return ws;
                case "color":
                    return ms;
                case "quaternion":
                    return fs;
                case "bool":
                case "boolean":
                    return us;
                case "string":
                    return cs
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }
    }), Object.assign(bs.prototype, {
        constructor: bs,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: Se,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new _s(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new ys(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new gs(this.times, this.values, this.getValueSize(), t)
        },
        setInterpolation: function(t) {
            var e;
            switch (t) {
                case Me:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Se:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case Ae:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 !== e) this.createInterpolant = e;
            else {
                var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(i);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                console.warn("THREE.KeyframeTrack:", i)
            }
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Me;
                case this.InterpolantFactoryMethodLinear:
                    return Se;
                case this.InterpolantFactoryMethodSmooth:
                    return Ae
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
            return this
        },
        trim: function(t, e) {
            for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;) ++r;
            for (; - 1 !== o && i[o] > e;) --o;
            if (++o, 0 !== r || o !== n) {
                r >= o && (r = (o = Math.max(o, 1)) - 1);
                var a = this.getValueSize();
                this.times = xs.arraySlice(i, r, o), this.values = xs.arraySlice(this.values, r * a, o * a)
            }
            return this
        },
        validate: function() {
            var t = !0,
                e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            var i = this.times,
                n = this.values,
                r = i.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            for (var o = null, a = 0; a !== r; a++) {
                var s = i[a];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                    break
                }
                if (null !== o && o > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                    break
                }
                o = s
            }
            if (void 0 !== n && xs.isTypedArray(n)) {
                a = 0;
                for (var l = n.length; a !== l; ++a) {
                    var h = n[a];
                    if (isNaN(h)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, h), t = !1;
                        break
                    }
                }
            }
            return t
        },
        optimize: function() {
            for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === Ae, r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                var s = !1,
                    l = t[a];
                if (l !== t[a + 1] && (1 !== a || l !== l[0]))
                    if (n) s = !0;
                    else
                        for (var h = a * i, c = h - i, u = h + i, p = 0; p !== i; ++p) {
                            var d = e[h + p];
                            if (d !== e[c + p] || d !== e[u + p]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (a !== r) {
                        t[r] = t[a];
                        var f = a * i,
                            m = r * i;
                        for (p = 0; p !== i; ++p) e[m + p] = e[f + p]
                    }++r
                }
            }
            if (o > 0) {
                for (t[r] = t[o], f = o * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
                ++r
            }
            return r !== t.length && (this.times = xs.arraySlice(t, 0, r), this.values = xs.arraySlice(e, 0, r * i)), this
        }
    }), ws.prototype = Object.assign(Object.create(bs.prototype), {
        constructor: ws,
        ValueTypeName: "vector"
    }), Object.assign(Ts, {
        parse: function(t) {
            for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r) e.push(bs.parse(i[r]).scale(n));
            return new Ts(t.name, t.duration, e)
        },
        toJSON: function(t) {
            for (var e = [], i = t.tracks, n = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                }, r = 0, o = i.length; r !== o; ++r) e.push(bs.toJSON(i[r]));
            return n
        },
        CreateFromMorphTargetSequence: function(t, e, i, n) {
            for (var r = e.length, o = [], a = 0; a < r; a++) {
                var s = [],
                    l = [];
                s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                var h = xs.getKeyframeOrder(s);
                s = xs.sortedArray(s, 1, h), l = xs.sortedArray(l, 1, h), n || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new vs(".morphTargetInfluences[" + e[a].name + "]", s, l).scale(1 / i))
            }
            return new Ts(t, -1, o)
        },
        findByName: function(t, e) {
            var i = t;
            if (!Array.isArray(t)) {
                var n = t;
                i = n.geometry && n.geometry.animations || n.animations
            }
            for (var r = 0; r < i.length; r++)
                if (i[r].name === e) return i[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                var s = t[o],
                    l = s.name.match(r);
                if (l && l.length > 1) {
                    var h = n[u = l[1]];
                    h || (n[u] = h = []), h.push(s)
                }
            }
            var c = [];
            for (var u in n) c.push(Ts.CreateFromMorphTargetSequence(u, n[u], e, i));
            return c
        },
        parseAnimation: function(t, e) {
            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            for (var i = function(t, e, i, n, r) {
                    if (0 !== i.length) {
                        var o = [],
                            a = [];
                        xs.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a))
                    }
                }, n = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) {
                var h = s[l].keys;
                if (h && 0 !== h.length)
                    if (h[0].morphTargets) {
                        for (var c = {}, u = 0; u < h.length; u++)
                            if (h[u].morphTargets)
                                for (var p = 0; p < h[u].morphTargets.length; p++) c[h[u].morphTargets[p]] = -1;
                        for (var d in c) {
                            var f = [],
                                m = [];
                            for (p = 0; p !== h[u].morphTargets.length; ++p) {
                                var v = h[u];
                                f.push(v.time), m.push(v.morphTarget === d ? 1 : 0)
                            }
                            n.push(new vs(".morphTargetInfluence[" + d + "]", f, m))
                        }
                        o = c.length * (a || 1)
                    } else {
                        var g = ".bones[" + e[l].name + "]";
                        i(ws, g + ".position", h, "pos", n), i(fs, g + ".quaternion", h, "rot", n), i(ws, g + ".scale", h, "scl", n)
                    }
            }
            return 0 === n.length ? null : new Ts(r, o, n)
        }
    }), Object.assign(Ts.prototype, {
        resetDuration: function() {
            for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                var n = this.tracks[e];
                t = Math.max(t, n.times[n.times.length - 1])
            }
            this.duration = t
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this
        }
    }), Object.assign(Es.prototype, {
        load: function(t, e, i, n) {
            var r = this;
            new Ma(r.manager).load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        setTextures: function(t) {
            this.textures = t
        },
        parse: function(t) {
            var e = this.textures;

            function i(t) {
                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
            }
            var n = new xa[t.type];
            if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (n.uniforms = t.uniforms), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalScale) {
                var r = t.normalScale;
                !1 === Array.isArray(r) && (r = [r, r]), n.normalScale = (new We).fromArray(r)
            }
            return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)), n
        }
    }), Object.assign(Ms.prototype, {
        load: function(t, e, i, n) {
            var r = this;
            new Ma(r.manager).load(t, function(t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        },
        parse: function(t) {
            var e = new Yi,
                i = t.data.index;
            if (void 0 !== i) {
                var n = new Ps[i.type](i.array);
                e.setIndex(new Ni(n, 1))
            }
            var r = t.data.attributes;
            for (var o in r) {
                var a = r[o];
                n = new Ps[a.type](a.array), e.addAttribute(o, new Ni(n, a.itemSize, a.normalized))
            }
            var s = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== s)
                for (var l = 0, h = s.length; l !== h; ++l) {
                    var c = s[l];
                    e.addGroup(c.start, c.count, c.materialIndex)
                }
            var u = t.data.boundingSphere;
            if (void 0 !== u) {
                var p = new Ye;
                void 0 !== u.center && p.fromArray(u.center), e.boundingSphere = new hi(p, u.radius)
            }
            return e
        }
    });
    var Ss, As, Cs, Rs, Ps = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function Ls() {}
    Ls.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                var r = e[i],
                    o = e[i + 1];
                if (r.test(t)) return o
            }
            return null
        }
    }, Object.assign(Ls.prototype, {
        crossOrigin: void 0,
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(t, e, i) {
            for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
            return n
        },
        createMaterial: (Ss = {
            NoBlending: O,
            NormalBlending: B,
            AdditiveBlending: I,
            SubtractiveBlending: N,
            MultiplyBlending: z,
            CustomBlending: F
        }, As = new vi, Cs = new Pa, Rs = new Es, function(t, e, i) {
            var n = {};

            function r(t, r, o, a, s) {
                var l, h = e + t,
                    c = Ls.Handlers.get(h);
                null !== c ? l = c.load(h) : (Cs.setCrossOrigin(i), l = Cs.load(h)), void 0 !== r && (l.repeat.fromArray(r), 1 !== r[0] && (l.wrapS = Et), 1 !== r[1] && (l.wrapT = Et)), void 0 !== o && l.offset.fromArray(o), void 0 !== a && ("repeat" === a[0] && (l.wrapS = Et), "mirror" === a[0] && (l.wrapS = St), "repeat" === a[1] && (l.wrapT = Et), "mirror" === a[1] && (l.wrapT = St)), void 0 !== s && (l.anisotropy = s);
                var u = je.generateUUID();
                return n[u] = l, u
            }
            var o = {
                uuid: je.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for (var a in t) {
                var s = t[a];
                switch (a) {
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                        break;
                    case "DbgName":
                        o.name = s;
                        break;
                    case "blending":
                        o.blending = Ss[s];
                        break;
                    case "colorAmbient":
                    case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", a, "is no longer supported.");
                        break;
                    case "colorDiffuse":
                        o.color = As.fromArray(s).getHex();
                        break;
                    case "colorSpecular":
                        o.specular = As.fromArray(s).getHex();
                        break;
                    case "colorEmissive":
                        o.emissive = As.fromArray(s).getHex();
                        break;
                    case "specularCoef":
                        o.shininess = s;
                        break;
                    case "shading":
                        "basic" === s.toLowerCase() && (o.type = "MeshBasicMaterial"), "phong" === s.toLowerCase() && (o.type = "MeshPhongMaterial"), "standard" === s.toLowerCase() && (o.type = "MeshStandardMaterial");
                        break;
                    case "mapDiffuse":
                        o.map = r(s, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
                        break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                        break;
                    case "mapEmissive":
                        o.emissiveMap = r(s, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
                        break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                        break;
                    case "mapLight":
                        o.lightMap = r(s, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
                        break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                        break;
                    case "mapAO":
                        o.aoMap = r(s, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
                        break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                        break;
                    case "mapBump":
                        o.bumpMap = r(s, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
                        break;
                    case "mapBumpScale":
                        o.bumpScale = s;
                        break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                        break;
                    case "mapNormal":
                        o.normalMap = r(s, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
                        break;
                    case "mapNormalFactor":
                        o.normalScale = s;
                        break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                        break;
                    case "mapSpecular":
                        o.specularMap = r(s, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
                        break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                        break;
                    case "mapMetalness":
                        o.metalnessMap = r(s, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
                        break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                        break;
                    case "mapRoughness":
                        o.roughnessMap = r(s, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
                        break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                        break;
                    case "mapAlpha":
                        o.alphaMap = r(s, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
                        break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                        break;
                    case "flipSided":
                        o.side = M;
                        break;
                    case "doubleSided":
                        o.side = S;
                        break;
                    case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), o.opacity = s;
                        break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                        o[a] = s;
                        break;
                    case "vertexColors":
                        !0 === s && (o.vertexColors = L), "face" === s && (o.vertexColors = P);
                        break;
                    default:
                        console.error("THREE.Loader.createMaterial: Unsupported", a, s)
                }
            }
            return "MeshBasicMaterial" === o.type && delete o.emissive, "MeshPhongMaterial" !== o.type && delete o.specular, o.opacity < 1 && (o.transparent = !0), Rs.setTextures(n), Rs.parse(o)
        })
    });
    var Os = {
        decodeText: function(t) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
            for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
            return decodeURIComponent(escape(e))
        },
        extractUrlBase: function(t) {
            var e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    };

    function Bs(t) {
        "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : Ta, this.withCredentials = !1
    }

    function Is(t) {
        this.manager = void 0 !== t ? t : Ta, this.texturePath = ""
    }
    Object.assign(Bs.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Os.extractUrlBase(t),
                a = new Ma(this.manager);
            a.setWithCredentials(this.withCredentials), a.load(t, function(i) {
                var n = JSON.parse(i),
                    a = n.metadata;
                if (void 0 !== a) {
                    var s = a.type;
                    if (void 0 !== s && "object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.")
                }
                var l = r.parse(n, o);
                e(l.geometry, l.materials)
            }, i, n)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        parse: function(t, e) {
            void 0 !== t.data && (t = t.data), void 0 !== t.scale ? t.scale = 1 / t.scale : t.scale = 1;
            var i = new Ii;
            return function(t, e) {
                    function i(t, e) {
                        return t & 1 << e
                    }
                    var n, r, o, a, s, l, h, c, u, p, d, f, m, v, g, y, _, x, b, w, T, E, M, S, A, C = t.faces,
                        R = t.vertices,
                        P = t.normals,
                        L = t.colors,
                        O = t.scale,
                        B = 0;
                    if (void 0 !== t.uvs) {
                        for (n = 0; n < t.uvs.length; n++) t.uvs[n].length && B++;
                        for (n = 0; n < B; n++) e.faceVertexUvs[n] = []
                    }
                    for (a = 0, s = R.length; a < s;)(x = new Ye).x = R[a++] * O, x.y = R[a++] * O, x.z = R[a++] * O, e.vertices.push(x);
                    for (a = 0, s = C.length; a < s;)
                        if (d = i(p = C[a++], 0), f = i(p, 1), m = i(p, 3), v = i(p, 4), g = i(p, 5), y = i(p, 6), _ = i(p, 7), d) {
                            if ((w = new Pi).a = C[a], w.b = C[a + 1], w.c = C[a + 3], (T = new Pi).a = C[a + 1], T.b = C[a + 2], T.c = C[a + 3], a += 4, f && (u = C[a++], w.materialIndex = u, T.materialIndex = u), o = e.faces.length, m)
                                for (n = 0; n < B; n++)
                                    for (S = t.uvs[n], e.faceVertexUvs[n][o] = [], e.faceVertexUvs[n][o + 1] = [], r = 0; r < 4; r++) A = new We(S[2 * (c = C[a++])], S[2 * c + 1]), 2 !== r && e.faceVertexUvs[n][o].push(A), 0 !== r && e.faceVertexUvs[n][o + 1].push(A);
                            if (v && (h = 3 * C[a++], w.normal.set(P[h++], P[h++], P[h]), T.normal.copy(w.normal)), g)
                                for (n = 0; n < 4; n++) h = 3 * C[a++], M = new Ye(P[h++], P[h++], P[h]), 2 !== n && w.vertexNormals.push(M), 0 !== n && T.vertexNormals.push(M);
                            if (y && (E = L[l = C[a++]], w.color.setHex(E), T.color.setHex(E)), _)
                                for (n = 0; n < 4; n++) E = L[l = C[a++]], 2 !== n && w.vertexColors.push(new vi(E)), 0 !== n && T.vertexColors.push(new vi(E));
                            e.faces.push(w), e.faces.push(T)
                        } else {
                            if ((b = new Pi).a = C[a++], b.b = C[a++], b.c = C[a++], f && (u = C[a++], b.materialIndex = u), o = e.faces.length, m)
                                for (n = 0; n < B; n++)
                                    for (S = t.uvs[n], e.faceVertexUvs[n][o] = [], r = 0; r < 3; r++) A = new We(S[2 * (c = C[a++])], S[2 * c + 1]), e.faceVertexUvs[n][o].push(A);
                            if (v && (h = 3 * C[a++], b.normal.set(P[h++], P[h++], P[h])), g)
                                for (n = 0; n < 3; n++) h = 3 * C[a++], M = new Ye(P[h++], P[h++], P[h]), b.vertexNormals.push(M);
                            if (y && (l = C[a++], b.color.setHex(L[l])), _)
                                for (n = 0; n < 3; n++) l = C[a++], b.vertexColors.push(new vi(L[l]));
                            e.faces.push(b)
                        }
                }(t, i),
                function(t, e) {
                    var i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                    if (t.skinWeights)
                        for (var n = 0, r = t.skinWeights.length; n < r; n += i) {
                            var o = t.skinWeights[n],
                                a = i > 1 ? t.skinWeights[n + 1] : 0,
                                s = i > 2 ? t.skinWeights[n + 2] : 0,
                                l = i > 3 ? t.skinWeights[n + 3] : 0;
                            e.skinWeights.push(new ri(o, a, s, l))
                        }
                    if (t.skinIndices)
                        for (n = 0, r = t.skinIndices.length; n < r; n += i) {
                            var h = t.skinIndices[n],
                                c = i > 1 ? t.skinIndices[n + 1] : 0,
                                u = i > 2 ? t.skinIndices[n + 2] : 0,
                                p = i > 3 ? t.skinIndices[n + 3] : 0;
                            e.skinIndices.push(new ri(h, c, u, p))
                        }
                    e.bones = t.bones, e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
                }(t, i),
                function(t, e) {
                    var i = t.scale;
                    if (void 0 !== t.morphTargets)
                        for (var n = 0, r = t.morphTargets.length; n < r; n++) {
                            e.morphTargets[n] = {}, e.morphTargets[n].name = t.morphTargets[n].name, e.morphTargets[n].vertices = [];
                            for (var o = e.morphTargets[n].vertices, a = t.morphTargets[n].vertices, s = 0, l = a.length; s < l; s += 3) {
                                var h = new Ye;
                                h.x = a[s] * i, h.y = a[s + 1] * i, h.z = a[s + 2] * i, o.push(h)
                            }
                        }
                    if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                        var c = e.faces,
                            u = t.morphColors[0].colors;
                        for (n = 0, r = c.length; n < r; n++) c[n].color.fromArray(u, 3 * n)
                    }
                }(t, i),
                function(t, e) {
                    var i = [],
                        n = [];
                    void 0 !== t.animation && n.push(t.animation), void 0 !== t.animations && (t.animations.length ? n = n.concat(t.animations) : n.push(t.animations));
                    for (var r = 0; r < n.length; r++) {
                        var o = Ts.parseAnimation(n[r], e.bones);
                        o && i.push(o)
                    }
                    if (e.morphTargets) {
                        var a = Ts.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                        i = i.concat(a)
                    }
                    i.length > 0 && (e.animations = i)
                }(t, i), i.computeFaceNormals(), i.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {
                    geometry: i
                } : {
                    geometry: i,
                    materials: Ls.prototype.initMaterials(t.materials, e, this.crossOrigin)
                }
        }
    }), Object.assign(Is.prototype, {
        load: function(t, e, i, n) {
            "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
            var r = this;
            new Ma(r.manager).load(t, function(i) {
                var o = null;
                try {
                    o = JSON.parse(i)
                } catch (e) {
                    return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                var a = o.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.")
            }, i, n)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t, e) {
            var i = this.parseShape(t.shapes),
                n = this.parseGeometries(t.geometries, i),
                r = this.parseImages(t.images, function() {
                    void 0 !== e && e(s)
                }),
                o = this.parseTextures(t.textures, r),
                a = this.parseMaterials(t.materials, o),
                s = this.parseObject(t.object, n, a);
            return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var i = 0, n = t.length; i < n; i++) {
                    var r = (new $a).fromJSON(t[i]);
                    e[r.uuid] = r
                }
            return e
        },
        parseGeometries: function(t, e) {
            var i = {};
            if (void 0 !== t)
                for (var n = new Bs, r = new Ms, o = 0, a = t.length; o < a; o++) {
                    var s, l = t[o];
                    switch (l.type) {
                        case "PlaneGeometry":
                        case "PlaneBufferGeometry":
                            s = new ca[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                            break;
                        case "BoxGeometry":
                        case "BoxBufferGeometry":
                        case "CubeGeometry":
                            s = new ca[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                            break;
                        case "CircleGeometry":
                        case "CircleBufferGeometry":
                            s = new ca[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                            break;
                        case "CylinderGeometry":
                        case "CylinderBufferGeometry":
                            s = new ca[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                            break;
                        case "ConeGeometry":
                        case "ConeBufferGeometry":
                            s = new ca[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                            break;
                        case "SphereGeometry":
                        case "SphereBufferGeometry":
                            s = new ca[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                            break;
                        case "DodecahedronGeometry":
                        case "DodecahedronBufferGeometry":
                        case "IcosahedronGeometry":
                        case "IcosahedronBufferGeometry":
                        case "OctahedronGeometry":
                        case "OctahedronBufferGeometry":
                        case "TetrahedronGeometry":
                        case "TetrahedronBufferGeometry":
                            s = new ca[l.type](l.radius, l.detail);
                            break;
                        case "RingGeometry":
                        case "RingBufferGeometry":
                            s = new ca[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                            break;
                        case "TorusGeometry":
                        case "TorusBufferGeometry":
                            s = new ca[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                            break;
                        case "TorusKnotGeometry":
                        case "TorusKnotBufferGeometry":
                            s = new ca[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                            break;
                        case "LatheGeometry":
                        case "LatheBufferGeometry":
                            s = new ca[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                            break;
                        case "PolyhedronGeometry":
                        case "PolyhedronBufferGeometry":
                            s = new ca[l.type](l.vertices, l.indices, l.radius, l.details);
                            break;
                        case "ShapeGeometry":
                        case "ShapeBufferGeometry":
                            for (var h = [], c = 0, u = l.shapes.length; c < u; c++) {
                                var p = e[l.shapes[c]];
                                h.push(p)
                            }
                            s = new ca[l.type](h, l.curveSegments);
                            break;
                        case "BufferGeometry":
                            s = r.parse(l);
                            break;
                        case "Geometry":
                            s = n.parse(l, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"');
                            continue
                    }
                    s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), i[l.uuid] = s
                }
            return i
        },
        parseMaterials: function(t, e) {
            var i = {};
            if (void 0 !== t) {
                var n = new Es;
                n.setTextures(e);
                for (var r = 0, o = t.length; r < o; r++) {
                    var a = t[r];
                    if ("MultiMaterial" === a.type) {
                        for (var s = [], l = 0; l < a.materials.length; l++) s.push(n.parse(a.materials[l]));
                        i[a.uuid] = s
                    } else i[a.uuid] = n.parse(a)
                }
            }
            return i
        },
        parseAnimations: function(t) {
            for (var e = [], i = 0; i < t.length; i++) {
                var n = Ts.parse(t[i]);
                e.push(n)
            }
            return e
        },
        parseImages: function(t, e) {
            var i = this,
                n = {};

            function r(t) {
                return i.manager.itemStart(t), o.load(t, function() {
                    i.manager.itemEnd(t)
                }, void 0, function() {
                    i.manager.itemEnd(t), i.manager.itemError(t)
                })
            }
            if (void 0 !== t && t.length > 0) {
                var o = new Ca(new wa(e));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = t.length; a < s; a++) {
                    var l = t[a],
                        h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.texturePath + l.url;
                    n[l.uuid] = r(h)
                }
            }
            return n
        },
        parseTextures: function(t, e) {
            function i(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
            }
            var n = {};
            if (void 0 !== t)
                for (var r = 0, o = t.length; r < o; r++) {
                    var a = t[r];
                    void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                    var s = new ni(e[a.image]);
                    s.needsUpdate = !0, s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = i(a.mapping, zs)), void 0 !== a.offset && s.offset.fromArray(a.offset), void 0 !== a.repeat && s.repeat.fromArray(a.repeat), void 0 !== a.center && s.center.fromArray(a.center), void 0 !== a.rotation && (s.rotation = a.rotation), void 0 !== a.wrap && (s.wrapS = i(a.wrap[0], Fs), s.wrapT = i(a.wrap[1], Fs)), void 0 !== a.format && (s.format = a.format), void 0 !== a.minFilter && (s.minFilter = i(a.minFilter, Ds)), void 0 !== a.magFilter && (s.magFilter = i(a.magFilter, Ds)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), void 0 !== a.flipY && (s.flipY = a.flipY), n[a.uuid] = s
                }
            return n
        },
        parseObject: function(t, e, i) {
            var n;

            function r(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
            }

            function o(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var o = t[n];
                            void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(i[o])
                        }
                        return e
                    }
                    return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                }
            }
            switch (t.type) {
                case "Scene":
                    n = new zr, void 0 !== t.background && Number.isInteger(t.background) && (n.background = new vi(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? n.fog = new Nr(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (n.fog = new Ir(t.fog.color, t.fog.density)));
                    break;
                case "PerspectiveCamera":
                    n = new Pr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (n.focus = t.focus), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (n.filmOffset = t.filmOffset), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                    break;
                case "OrthographicCamera":
                    n = new Ri(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                    break;
                case "AmbientLight":
                    n = new ls(t.color, t.intensity);
                    break;
                case "DirectionalLight":
                    n = new ss(t.color, t.intensity);
                    break;
                case "PointLight":
                    n = new os(t.color, t.intensity, t.distance, t.decay);
                    break;
                case "RectAreaLight":
                    n = new hs(t.color, t.intensity, t.width, t.height);
                    break;
                case "SpotLight":
                    n = new rs(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                    break;
                case "HemisphereLight":
                    n = new es(t.color, t.groundColor, t.intensity);
                    break;
                case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case "Mesh":
                    var a = r(t.geometry),
                        s = o(t.material);
                    n = a.bones && a.bones.length > 0 ? new Hr(a, s) : new fn(a, s);
                    break;
                case "LOD":
                    n = new Ur;
                    break;
                case "Line":
                    n = new jr(r(t.geometry), o(t.material), t.mode);
                    break;
                case "LineLoop":
                    n = new qr(r(t.geometry), o(t.material));
                    break;
                case "LineSegments":
                    n = new Wr(r(t.geometry), o(t.material));
                    break;
                case "PointCloud":
                case "Points":
                    n = new Yr(r(t.geometry), o(t.material));
                    break;
                case "Sprite":
                    n = new Dr(o(t.material));
                    break;
                case "Group":
                    n = new Zr;
                    break;
                default:
                    n = new Ai
            }
            if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ? (n.matrix.fromArray(t.matrix), n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t.position && n.position.fromArray(t.position), void 0 !== t.rotation && n.rotation.fromArray(t.rotation), void 0 !== t.quaternion && n.quaternion.fromArray(t.quaternion), void 0 !== t.scale && n.scale.fromArray(t.scale)), void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (n.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (n.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && n.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (n.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.frustumCulled && (n.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (n.renderOrder = t.renderOrder), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.children)
                for (var l = t.children, h = 0; h < l.length; h++) n.add(this.parseObject(l[h], e, i));
            if ("LOD" === t.type)
                for (var c = t.levels, u = 0; u < c.length; u++) {
                    var p = c[u],
                        d = n.getObjectByProperty("uuid", p.object);
                    void 0 !== d && n.addLevel(d, p.distance)
                }
            return n
        }
    });
    var Ns, zs = {
            UVMapping: vt,
            CubeReflectionMapping: gt,
            CubeRefractionMapping: yt,
            EquirectangularReflectionMapping: _t,
            EquirectangularRefractionMapping: xt,
            SphericalReflectionMapping: bt,
            CubeUVReflectionMapping: wt,
            CubeUVRefractionMapping: Tt
        },
        Fs = {
            RepeatWrapping: Et,
            ClampToEdgeWrapping: Mt,
            MirroredRepeatWrapping: St
        },
        Ds = {
            NearestFilter: At,
            NearestMipMapNearestFilter: Ct,
            NearestMipMapLinearFilter: Rt,
            LinearFilter: Pt,
            LinearMipMapNearestFilter: Lt,
            LinearMipMapLinearFilter: Ot
        };

    function Us(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Ta, this.options = void 0
    }

    function ks() {
        this.type = "ShapePath", this.subPaths = [], this.currentPath = null
    }

    function Vs(t) {
        this.type = "Font", this.data = t
    }

    function Hs(t, e, i, n, r, o) {
        var a = o.glyphs[t] || o.glyphs["?"];
        if (a) {
            var s, l, h, c, u, p, d, f, m = new ks;
            if (a.o)
                for (var v = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, y = v.length; g < y;) switch (v[g++]) {
                    case "m":
                        s = v[g++] * i + n, l = v[g++] * i + r, m.moveTo(s, l);
                        break;
                    case "l":
                        s = v[g++] * i + n, l = v[g++] * i + r, m.lineTo(s, l);
                        break;
                    case "q":
                        h = v[g++] * i + n, c = v[g++] * i + r, u = v[g++] * i + n, p = v[g++] * i + r, m.quadraticCurveTo(u, p, h, c);
                        break;
                    case "b":
                        h = v[g++] * i + n, c = v[g++] * i + r, u = v[g++] * i + n, p = v[g++] * i + r, d = v[g++] * i + n, f = v[g++] * i + r, m.bezierCurveTo(u, p, d, f, h, c)
                }
            return {
                offsetX: a.ha * i,
                path: m
            }
        }
    }

    function Gs(t) {
        this.manager = void 0 !== t ? t : Ta
    }
    Us.prototype = {
        constructor: Us,
        setOptions: function(t) {
            return this.options = t, this
        },
        load: function(t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
            var r = this,
                o = ba.get(t);
            if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                e && e(o), r.manager.itemEnd(t)
            }, 0), o;
            fetch(t).then(function(t) {
                return t.blob()
            }).then(function(t) {
                return createImageBitmap(t, r.options)
            }).then(function(i) {
                ba.add(t, i), e && e(i), r.manager.itemEnd(t)
            }).catch(function(e) {
                n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(t) {
            return this.path = t, this
        }
    }, Object.assign(ks.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new Qa, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, i, n) {
            this.currentPath.quadraticCurveTo(t, e, i, n)
        },
        bezierCurveTo: function(t, e, i, n, r, o) {
            this.currentPath.bezierCurveTo(t, e, i, n, r, o)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function i(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i],
                        o = new $a;
                    o.curves = r.curves, e.push(o)
                }
                return e
            }

            function n(t, e) {
                for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                    var a = e[r],
                        s = e[o],
                        l = s.x - a.x,
                        h = s.y - a.y;
                    if (Math.abs(h) > Number.EPSILON) {
                        if (h < 0 && (a = e[o], l = -l, s = e[r], h = -h), t.y < a.y || t.y > s.y) continue;
                        if (t.y === a.y) {
                            if (t.x === a.x) return !0
                        } else {
                            var c = h * (t.x - a.x) - l * (t.y - a.y);
                            if (0 === c) return !0;
                            if (c < 0) continue;
                            n = !n
                        }
                    } else {
                        if (t.y !== a.y) continue;
                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                    }
                }
                return n
            }
            var r = Vo.isClockWise,
                o = this.subPaths;
            if (0 === o.length) return [];
            if (!0 === e) return i(o);
            var a, s, l, h = [];
            if (1 === o.length) return s = o[0], (l = new $a).curves = s.curves, h.push(l), h;
            var c = !r(o[0].getPoints());
            c = t ? !c : c;
            var u, p, d = [],
                f = [],
                m = [],
                v = 0;
            f[v] = void 0, m[v] = [];
            for (var g = 0, y = o.length; g < y; g++) a = r(u = (s = o[g]).getPoints()), (a = t ? !a : a) ? (!c && f[v] && v++, f[v] = {
                s: new $a,
                p: u
            }, f[v].s.curves = s.curves, c && v++, m[v] = []) : m[v].push({
                h: s,
                p: u[0]
            });
            if (!f[0]) return i(o);
            if (f.length > 1) {
                for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) d[b] = [];
                for (b = 0, w = f.length; b < w; b++)
                    for (var T = m[b], E = 0; E < T.length; E++) {
                        for (var M = T[E], S = !0, A = 0; A < f.length; A++) n(M.p, f[A].p) && (b !== A && x.push({
                            froms: b,
                            tos: A,
                            hole: E
                        }), S ? (S = !1, d[A].push(M)) : _ = !0);
                        S && d[b].push(M)
                    }
                x.length > 0 && (_ || (m = d))
            }
            g = 0;
            for (var C = f.length; g < C; g++) {
                l = f[g].s, h.push(l);
                for (var R = 0, P = (p = m[g]).length; R < P; R++) l.holes.push(p[R].h)
            }
            return h
        }
    }), Object.assign(Vs.prototype, {
        isFont: !0,
        generateShapes: function(t, e, i) {
            void 0 === e && (e = 100), void 0 === i && (i = 4);
            for (var n = [], r = function(t, e, i, n) {
                    for (var r = String(t).split(""), o = e / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * o, s = [], l = 0, h = 0, c = 0; c < r.length; c++) {
                        var u = r[c];
                        if ("\n" === u) l = 0, h -= a;
                        else {
                            var p = Hs(u, 0, o, l, h, n);
                            l += p.offsetX, s.push(p.path)
                        }
                    }
                    return s
                }(t, e, 0, this.data), o = 0, a = r.length; o < a; o++) Array.prototype.push.apply(n, r[o].toShapes());
            return n
        }
    }), Object.assign(Gs.prototype, {
        load: function(t, e, i, n) {
            var r = this,
                o = new Ma(this.manager);
            o.setPath(this.path), o.load(t, function(t) {
                var i;
                try {
                    i = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                }
                var n = r.parse(i);
                e && e(n)
            }, i, n)
        },
        parse: function(t) {
            return new Vs(t)
        },
        setPath: function(t) {
            return this.path = t, this
        }
    });
    var js, Ws, qs, Xs, Ys, Zs, Js, Ks, Qs, $s, tl, el, il, nl, rl, ol, al, sl, ll, hl, cl, ul, pl, dl = {
        getContext: function() {
            return void 0 === Ns && (Ns = new(window.AudioContext || window.webkitAudioContext)), Ns
        },
        setContext: function(t) {
            Ns = t
        }
    };

    function fl(t) {
        this.manager = void 0 !== t ? t : Ta
    }

    function ml() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Pr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Pr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function vl(t, e, i) {
        Ai.call(this), this.type = "CubeCamera";
        var n = new Pr(90, 1, t, e);
        n.up.set(0, -1, 0), n.lookAt(new Ye(1, 0, 0)), this.add(n);
        var r = new Pr(90, 1, t, e);
        r.up.set(0, -1, 0), r.lookAt(new Ye(-1, 0, 0)), this.add(r);
        var o = new Pr(90, 1, t, e);
        o.up.set(0, 0, 1), o.lookAt(new Ye(0, 1, 0)), this.add(o);
        var a = new Pr(90, 1, t, e);
        a.up.set(0, 0, -1), a.lookAt(new Ye(0, -1, 0)), this.add(a);
        var s = new Pr(90, 1, t, e);
        s.up.set(0, -1, 0), s.lookAt(new Ye(0, 0, 1)), this.add(s);
        var l = new Pr(90, 1, t, e);
        l.up.set(0, -1, 0), l.lookAt(new Ye(0, 0, -1)), this.add(l);
        var h = {
            format: qt,
            magFilter: Pt,
            minFilter: Pt
        };
        this.renderTarget = new ai(i, i, h), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var i = this.renderTarget,
                h = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, n, i), i.activeCubeFace = 1, t.render(e, r, i), i.activeCubeFace = 2, t.render(e, o, i), i.activeCubeFace = 3, t.render(e, a, i), i.activeCubeFace = 4, t.render(e, s, i), i.texture.generateMipmaps = h, i.activeCubeFace = 5, t.render(e, l, i), t.setRenderTarget(null)
        }, this.clear = function(t, e, i, n) {
            for (var r = this.renderTarget, o = 0; o < 6; o++) r.activeCubeFace = o, t.setRenderTarget(r), t.clear(e, i, n);
            t.setRenderTarget(null)
        }
    }

    function gl() {
        Ai.call(this), this.type = "AudioListener", this.context = dl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }

    function yl(t) {
        Ai.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function _l(t) {
        yl.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function xl(t, e) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    function bl(t, e, i) {
        this.binding = t, this.valueSize = i;
        var n, r = Float64Array;
        switch (e) {
            case "quaternion":
                n = this._slerp;
                break;
            case "string":
            case "bool":
                r = Array, n = this._select;
                break;
            default:
                n = this._lerp
        }
        this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }

    function wl(t, e, i) {
        var n = i || Tl.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, n)
    }

    function Tl(t, e, i) {
        this.path = e, this.parsedPath = i || Tl.parseTrackName(e), this.node = Tl.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
    }

    function El() {
        this.uuid = je.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }

    function Ml(t, e, i) {
        this._mixer = t, this._clip = e, this._localRoot = i || null;
        for (var n = e.tracks, r = n.length, o = new Array(r), a = {
                endingStart: Ce,
                endingEnd: Ce
            }, s = 0; s !== r; ++s) {
            var l = n[s].createInterpolant(null);
            o[s] = l, l.settings = a
        }
        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Te, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function Sl(t) {
        this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function Al(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
    }

    function Cl() {
        Yi.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function Rl(t, e, i, n) {
        this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
    }

    function Pl(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Ll(t, e, i) {
        Pl.call(this, t, e), this.meshPerAttribute = i || 1
    }

    function Ol(t, e, i) {
        Ni.call(this, t, e), this.meshPerAttribute = i || 1
    }

    function Bl(t, e, i, n) {
        this.ray = new un(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Il(t, e) {
        return t.distance - e.distance
    }

    function Nl(t, e, i, n) {
        if (t.raycast(e, i), !0 === n)
            for (var r = t.children, o = 0, a = r.length; o < a; o++) Nl(r[o], e, i, !0)
    }

    function zl(t) {
        this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }

    function Fl(t, e, i) {
        return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function Dl(t, e, i) {
        return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
    }

    function Ul(t, e) {
        this.min = void 0 !== t ? t : new We(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new We(-1 / 0, -1 / 0)
    }

    function kl(t) {
        Ai.call(this), this.material = t, this.render = function() {}
    }

    function Vl(t, e, i, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        var r = void 0 !== i ? i : 16711680,
            o = void 0 !== n ? n : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var l = new Yi,
            h = new Gi(2 * a * 3, 3);
        l.addAttribute("position", h), Wr.call(this, l, new Gr({
            color: r,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Hl(t, e) {
        Ai.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        for (var i = new Yi, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
            var a = r / 32 * Math.PI * 2,
                s = o / 32 * Math.PI * 2;
            n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        i.addAttribute("position", new Gi(n, 3));
        var l = new Gr({
            fog: !1
        });
        this.cone = new Wr(i, l), this.add(this.cone), this.update()
    }

    function Gl(t) {
        for (var e = function t(e) {
                var i = [];
                e && e.isBone && i.push(e);
                for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                return i
            }(t), i = new Yi, n = [], r = [], o = new vi(0, 0, 1), a = new vi(0, 1, 0), s = 0; s < e.length; s++) {
            var l = e[s];
            l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
        }
        i.addAttribute("position", new Gi(n, 3)), i.addAttribute("color", new Gi(r, 3));
        var h = new Gr({
            vertexColors: L,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Wr.call(this, i, h), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    function jl(t, e, i) {
        this.light = t, this.light.updateMatrixWorld(), this.color = i;
        var n = new Zo(e, 4, 2),
            r = new hn({
                wireframe: !0,
                fog: !1
            });
        fn.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function Wl(t, e) {
        Ai.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        var i = new Gr({
                fog: !1
            }),
            n = new Yi;
        n.addAttribute("position", new Ni(new Float32Array(15), 3)), this.line = new jr(n, i), this.add(this.line), this.update()
    }

    function ql(t, e, i) {
        Ai.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
        var n = new lo(e);
        n.rotateY(.5 * Math.PI), this.material = new hn({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = L);
        var r = n.getAttribute("position"),
            o = new Float32Array(3 * r.count);
        n.addAttribute("color", new Ni(o, 3)), this.add(new fn(n, this.material)), this.update()
    }

    function Xl(t, e, i, n) {
        t = t || 10, e = e || 10, i = new vi(void 0 !== i ? i : 4473924), n = new vi(void 0 !== n ? n : 8947848);
        for (var r = e / 2, o = t / e, a = t / 2, s = [], l = [], h = 0, c = 0, u = -a; h <= e; h++, u += o) {
            s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
            var p = h === r ? i : n;
            p.toArray(l, c), c += 3, p.toArray(l, c), c += 3, p.toArray(l, c), c += 3, p.toArray(l, c), c += 3
        }
        var d = new Yi;
        d.addAttribute("position", new Gi(s, 3)), d.addAttribute("color", new Gi(l, 3));
        var f = new Gr({
            vertexColors: L
        });
        Wr.call(this, d, f)
    }

    function Yl(t, e, i, n, r, o) {
        t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new vi(void 0 !== r ? r : 4473924), o = new vi(void 0 !== o ? o : 8947848);
        var a, s, l, h, c, u, p, d = [],
            f = [];
        for (h = 0; h <= e; h++) l = h / e * (2 * Math.PI), a = Math.sin(l) * t, s = Math.cos(l) * t, d.push(0, 0, 0), d.push(a, 0, s), p = 1 & h ? r : o, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p.b);
        for (h = 0; h <= i; h++)
            for (p = 1 & h ? r : o, u = t - t / i * h, c = 0; c < n; c++) l = c / n * (2 * Math.PI), a = Math.sin(l) * u, s = Math.cos(l) * u, d.push(a, 0, s), f.push(p.r, p.g, p.b), l = (c + 1) / n * (2 * Math.PI), a = Math.sin(l) * u, s = Math.cos(l) * u, d.push(a, 0, s), f.push(p.r, p.g, p.b);
        var m = new Yi;
        m.addAttribute("position", new Gi(d, 3)), m.addAttribute("color", new Gi(f, 3));
        var v = new Gr({
            vertexColors: L
        });
        Wr.call(this, m, v)
    }

    function Zl(t, e, i, n) {
        this.object = t, this.size = void 0 !== e ? e : 1;
        var r = void 0 !== i ? i : 16776960,
            o = void 0 !== n ? n : 1,
            a = 0,
            s = this.object.geometry;
        s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var l = new Yi,
            h = new Gi(2 * a * 3, 3);
        l.addAttribute("position", h), Wr.call(this, l, new Gr({
            color: r,
            linewidth: o
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Jl(t, e, i) {
        Ai.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
        var n = new Yi;
        n.addAttribute("position", new Gi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        var r = new Gr({
            fog: !1
        });
        this.lightPlane = new jr(n, r), this.add(this.lightPlane), (n = new Yi).addAttribute("position", new Gi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new jr(n, r), this.add(this.targetLine), this.update()
    }

    function Kl(t) {
        var e = new Yi,
            i = new Gr({
                color: 16777215,
                vertexColors: P
            }),
            n = [],
            r = [],
            o = {},
            a = new vi(16755200),
            s = new vi(16711680),
            l = new vi(43775),
            h = new vi(16777215),
            c = new vi(3355443);

        function u(t, e, i) {
            p(t, i), p(e, i)
        }

        function p(t, e) {
            n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(n.length / 3 - 1)
        }
        u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", h), u("p", "c", c), u("cn1", "cn2", c), u("cn3", "cn4", c), u("cf1", "cf2", c), u("cf3", "cf4", c), e.addAttribute("position", new Gi(n, 3)), e.addAttribute("color", new Gi(r, 3)), Wr.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
    }

    function Ql(t, e) {
        this.object = t, void 0 === e && (e = 16776960);
        var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Float32Array(24),
            r = new Yi;
        r.setIndex(new Ni(i, 1)), r.addAttribute("position", new Ni(n, 3)), Wr.call(this, r, new Gr({
            color: e
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function $l(t, e) {
        this.type = "Box3Helper", this.box = t;
        var i = void 0 !== e ? e : 16776960,
            n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            r = new Yi;
        r.setIndex(new Ni(n, 1)), r.addAttribute("position", new Gi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Wr.call(this, r, new Gr({
            color: i
        })), this.geometry.computeBoundingSphere()
    }

    function th(t, e, i) {
        this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
        var n = void 0 !== i ? i : 16776960,
            r = new Yi;
        r.addAttribute("position", new Gi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), jr.call(this, r, new Gr({
            color: n
        }));
        var o = new Yi;
        o.addAttribute("position", new Gi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new fn(o, new hn({
            color: n,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function eh(t, e, i, n, r, o) {
        Ai.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === o && (o = .2 * r), void 0 === hl && ((hl = new Yi).addAttribute("position", new Gi([0, 0, 0, 0, 1, 0], 3)), (cl = new oa(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new jr(hl, new Gr({
            color: n
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new fn(cl, new hn({
            color: n
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, o)
    }

    function ih(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
            i = new Yi;
        i.addAttribute("position", new Gi(e, 3)), i.addAttribute("color", new Gi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        var n = new Gr({
            vertexColors: L
        });
        Wr.call(this, i, n)
    }

    function nh(t, e, i, n, r, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Pi(t, e, i, r, o, a)
    }
    Object.assign(fl.prototype, {
        load: function(t, e, i, n) {
            var r = new Ma(this.manager);
            r.setResponseType("arraybuffer"), r.load(t, function(t) {
                dl.getContext().decodeAudioData(t, function(t) {
                    e(t)
                })
            }, i, n)
        }
    }), Object.assign(ml.prototype, {
        update: (Qs = new qe, $s = new qe, function(t) {
            if (js !== this || Ws !== t.focus || qs !== t.fov || Xs !== t.aspect * this.aspect || Ys !== t.near || Zs !== t.far || Js !== t.zoom || Ks !== this.eyeSep) {
                js = this, Ws = t.focus, qs = t.fov, Xs = t.aspect * this.aspect, Ys = t.near, Zs = t.far, Js = t.zoom;
                var e, i, n = t.projectionMatrix.clone(),
                    r = (Ks = this.eyeSep / 2) * Ys / Ws,
                    o = Ys * Math.tan(je.DEG2RAD * qs * .5) / Js;
                $s.elements[12] = -Ks, Qs.elements[12] = Ks, e = -o * Xs + r, i = o * Xs + r, n.elements[0] = 2 * Ys / (i - e), n.elements[8] = (i + e) / (i - e), this.cameraL.projectionMatrix.copy(n), e = -o * Xs - r, i = o * Xs - r, n.elements[0] = 2 * Ys / (i - e), n.elements[8] = (i + e) / (i - e), this.cameraR.projectionMatrix.copy(n)
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply($s), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Qs)
        })
    }), vl.prototype = Object.create(Ai.prototype), vl.prototype.constructor = vl, gl.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: gl,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            this.gain.gain.value = t
        },
        updateMatrixWorld: function() {
            var t = new Ye,
                e = new Xe,
                i = new Ye,
                n = new Ye;
            return function(r) {
                Ai.prototype.updateMatrixWorld.call(this, r);
                var o = this.context.listener,
                    a = this.up;
                this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime), o.positionY.setValueAtTime(t.y, this.context.currentTime), o.positionZ.setValueAtTime(t.z, this.context.currentTime), o.forwardX.setValueAtTime(n.x, this.context.currentTime), o.forwardY.setValueAtTime(n.y, this.context.currentTime), o.forwardZ.setValueAtTime(n.z, this.context.currentTime), o.upX.setValueAtTime(a.x, this.context.currentTime), o.upY.setValueAtTime(a.y, this.context.currentTime), o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z, a.x, a.y, a.z))
            }
        }()
    }), yl.prototype = Object.assign(Object.create(Ai.prototype), {
        constructor: yl,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
        },
        setBuffer: function(t) {
            return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
        },
        play: function() {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.value = t, this
        }
    }), _l.prototype = Object.assign(Object.create(yl.prototype), {
        constructor: _l,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            this.panner.refDistance = t
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            this.panner.rolloffFactor = t
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            this.panner.distanceModel = t
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            this.panner.maxDistance = t
        },
        updateMatrixWorld: function() {
            var t = new Ye;
            return function(e) {
                Ai.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
            }
        }()
    }), Object.assign(xl.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data
        },
        getAverageFrequency: function() {
            for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
            return t / e.length
        }
    }), Object.assign(bl.prototype, {
        accumulate: function(t, e) {
            var i = this.buffer,
                n = this.valueSize,
                r = t * n + n,
                o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== n; ++a) i[r + a] = i[a];
                o = e
            } else {
                var s = e / (o += e);
                this._mixBufferRegion(i, r, 0, s, n)
            }
            this.cumulativeWeight = o
        },
        apply: function(t) {
            var e = this.valueSize,
                i = this.buffer,
                n = t * e + e,
                r = this.cumulativeWeight,
                o = this.binding;
            if (this.cumulativeWeight = 0, r < 1) {
                var a = 3 * e;
                this._mixBufferRegion(i, n, a, 1 - r, e)
            }
            for (var s = e, l = e + e; s !== l; ++s)
                if (i[s] !== i[s + e]) {
                    o.setValue(i, n);
                    break
                }
        },
        saveOriginalState: function() {
            var t = this.binding,
                e = this.buffer,
                i = this.valueSize,
                n = 3 * i;
            t.getValue(e, n);
            for (var r = i, o = n; r !== o; ++r) e[r] = e[n + r % i];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _select: function(t, e, i, n, r) {
            if (n >= .5)
                for (var o = 0; o !== r; ++o) t[e + o] = t[i + o]
        },
        _slerp: function(t, e, i, n) {
            Xe.slerpFlat(t, e, t, e, t, i, n)
        },
        _lerp: function(t, e, i, n, r) {
            for (var o = 1 - n, a = 0; a !== r; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[i + a] * n
            }
        }
    }), Object.assign(wl.prototype, {
        getValue: function(t, e) {
            this.bind();
            var i = this._targetGroup.nCachedObjects_,
                n = this._bindings[i];
            void 0 !== n && n.getValue(t, e)
        },
        setValue: function(t, e) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
        },
        bind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
        },
        unbind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
        }
    }), Object.assign(Tl, {
        Composite: wl,
        create: function(t, e, i) {
            return t && t.isAnimationObjectGroup ? new Tl.Composite(t, e, i) : new Tl(t, e, i)
        },
        sanitizeNodeName: (ll = new RegExp("[\\[\\]\\.:\\/]", "g"), function(t) {
            return t.replace(/\s/g, "_").replace(ll, "")
        }),
        parseTrackName: (tl = "[^\\[\\]\\.:\\/]", el = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", il = /((?:WC+[\/:])*)/.source.replace("WC", tl), nl = /(WCOD+)?/.source.replace("WCOD", el), rl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tl), ol = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tl), al = new RegExp("^" + il + nl + rl + ol + "$"), sl = ["material", "materials", "bones"], function(t) {
            var e = al.exec(t);
            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            var i = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                },
                n = i.nodeName && i.nodeName.lastIndexOf(".");
            if (void 0 !== n && -1 !== n) {
                var r = i.nodeName.substring(n + 1); - 1 !== sl.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r)
            }
            if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return i
        }),
        findNode: function(t, e) {
            if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
            if (t.skeleton) {
                var i = t.skeleton.getBoneByName(e);
                if (void 0 !== i) return i
            }
            if (t.children) {
                var n = function(t) {
                        for (var i = 0; i < t.length; i++) {
                            var r = t[i];
                            if (r.name === e || r.uuid === e) return r;
                            var o = n(r.children);
                            if (o) return o
                        }
                        return null
                    },
                    r = n(t.children);
                if (r) return r
            }
            return null
        }
    }), Object.assign(Tl.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }, function(t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
        }, function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }, function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }],
        SetterByBindingTypeAndVersioning: [
            [function(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }, function(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }, function(t, e) {
                this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }, function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }, function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }],
            [function(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }, function(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }, function(t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }]
        ],
        getValue: function(t, e) {
            this.bind(), this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(), this.setValue(t, e)
        },
        bind: function() {
            var t = this.node,
                e = this.parsedPath,
                i = e.objectName,
                n = e.propertyName,
                r = e.propertyIndex;
            if (t || (t = Tl.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                if (i) {
                    var o = e.objectIndex;
                    switch (i) {
                        case "materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case "bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            t = t.skeleton.bones;
                            for (var a = 0; a < t.length; a++)
                                if (t[a].name === o) {
                                    o = a;
                                    break
                                }
                            break;
                        default:
                            if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[i]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var s = t[n];
                if (void 0 !== s) {
                    var l = this.Versioning.None;
                    void 0 !== t.needsUpdate ? (l = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                    var h = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (t.geometry.morphAttributes.position[a].name === r) {
                                        r = a;
                                        break
                                    }
                            } else {
                                if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (t.geometry.morphTargets[a].name === r) {
                                        r = a;
                                        break
                                    }
                            }
                        }
                        h = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (h = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][l]
                } else {
                    var c = e.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", t)
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Tl.prototype, {
        _getValue_unbound: Tl.prototype.getValue,
        _setValue_unbound: Tl.prototype.setValue
    }), Object.assign(El.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, l = void 0, h = 0, c = arguments.length; h !== c; ++h) {
                var u = arguments[h],
                    p = u.uuid,
                    d = n[p];
                if (void 0 === d) {
                    d = e++, n[p] = d, t.push(u);
                    for (var f = 0, m = s; f !== m; ++f) a[f].push(new Tl(u, r[f], o[f]))
                } else if (d < i) {
                    l = t[d];
                    var v = --i,
                        g = t[v];
                    for (n[g.uuid] = d, t[d] = g, n[p] = v, t[v] = u, f = 0, m = s; f !== m; ++f) {
                        var y = a[f],
                            _ = y[v],
                            x = y[d];
                        y[d] = _, void 0 === x && (x = new Tl(u, r[f], o[f])), y[v] = x
                    }
                } else t[d] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        },
        remove: function() {
            for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o],
                    l = s.uuid,
                    h = i[l];
                if (void 0 !== h && h >= e) {
                    var c = e++,
                        u = t[c];
                    i[u.uuid] = h, t[h] = u, i[l] = c, t[c] = s;
                    for (var p = 0, d = r; p !== d; ++p) {
                        var f = n[p],
                            m = f[c],
                            v = f[h];
                        f[h] = m, f[c] = v
                    }
                }
            }
            this.nCachedObjects_ = e
        },
        uncache: function() {
            for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                var l = arguments[a].uuid,
                    h = n[l];
                if (void 0 !== h)
                    if (delete n[l], h < i) {
                        var c = --i,
                            u = t[c],
                            p = t[g = --e];
                        n[u.uuid] = h, t[h] = u, n[p.uuid] = c, t[c] = p, t.pop();
                        for (var d = 0, f = o; d !== f; ++d) {
                            var m = (y = r[d])[c],
                                v = y[g];
                            y[h] = m, y[c] = v, y.pop()
                        }
                    } else {
                        var g;
                        for (n[(p = t[g = --e]).uuid] = h, t[h] = p, t.pop(), d = 0, f = o; d !== f; ++d) {
                            var y;
                            (y = r[d])[h] = y[g], y.pop()
                        }
                    }
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(t, e) {
            var i = this._bindingsIndicesByPath,
                n = i[t],
                r = this._bindings;
            if (void 0 !== n) return r[n];
            var o = this._paths,
                a = this._parsedPaths,
                s = this._objects,
                l = s.length,
                h = this.nCachedObjects_,
                c = new Array(l);
            n = r.length, i[t] = n, o.push(t), a.push(e), r.push(c);
            for (var u = h, p = s.length; u !== p; ++u) {
                var d = s[u];
                c[u] = new Tl(d, t, e)
            }
            return c
        },
        unsubscribe_: function(t) {
            var e = this._bindingsIndicesByPath,
                i = e[t];
            if (void 0 !== i) {
                var n = this._paths,
                    r = this._parsedPaths,
                    o = this._bindings,
                    a = o.length - 1,
                    s = o[a];
                e[t[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
            }
        }
    }), Object.assign(Ml.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset()
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t, this
        },
        setLoop: function(t, e) {
            return this.loop = t, this.repetitions = e, this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, i) {
            if (t.fadeOut(e), this.fadeIn(e), i) {
                var n = this._clip.duration,
                    r = t._clip.duration,
                    o = r / n,
                    a = n / r;
                t.warp(1, o, e), this.warp(a, 1, e)
            }
            return this
        },
        crossFadeTo: function(t, e, i) {
            return t.crossFadeFrom(this, e, i)
        },
        stopFading: function() {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t, this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, i) {
            var n = this._mixer,
                r = n.time,
                o = this._timeScaleInterpolant,
                a = this.timeScale;
            null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
            var s = o.parameterPositions,
                l = o.sampleValues;
            return s[0] = r, s[1] = r + i, l[0] = t / a, l[1] = e / a, this
        },
        stopWarping: function() {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    var o = (t - r) * i;
                    if (o < 0 || 0 === i) return;
                    this._startTime = null, e = i * o
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e),
                    s = this._updateWeight(t);
                if (s > 0)
                    for (var l = this._interpolants, h = this._propertyBindings, c = 0, u = l.length; c !== u; ++c) l[c].evaluate(a), h[c].accumulate(n, s)
            } else this._updateWeight(t)
        },
        _updateWeight: function(t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(t)[0];
                    e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e, e
        },
        _updateTimeScale: function(t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var i = this._timeScaleInterpolant;
                null !== i && (e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e))
            }
            return this._effectiveTimeScale = e, e
        },
        _updateTime: function(t) {
            var e = this.time + t;
            if (0 === t) return e;
            var i = this._clip.duration,
                n = this.loop,
                r = this._loopCount;
            if (n === we) {
                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                t: {
                    if (e >= i) e = i;
                    else {
                        if (!(e < 0)) break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                var o = n === Ee;
                if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || e < 0) {
                    var a = Math.floor(e / i);
                    e -= i * a, r += Math.abs(a);
                    var s = this.repetitions - r;
                    if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t > 0 ? 1 : -1
                    });
                    else {
                        if (1 === s) {
                            var l = t < 0;
                            this._setEndings(l, !l, o)
                        } else this._setEndings(!1, !1, o);
                        this._loopCount = r, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: a
                        })
                    }
                }
                if (o && 1 == (1 & r)) return this.time = e, i - e
            }
            return this.time = e, e
        },
        _setEndings: function(t, e, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = Re, n.endingEnd = Re) : (n.endingStart = t ? this.zeroSlopeAtStart ? Re : Ce : Pe, n.endingEnd = e ? this.zeroSlopeAtEnd ? Re : Ce : Pe)
        },
        _scheduleFading: function(t, e, i) {
            var n = this._mixer,
                r = n.time,
                o = this._weightInterpolant;
            null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
            var a = o.parameterPositions,
                s = o.sampleValues;
            return a[0] = r, s[0] = e, a[1] = r + t, s[1] = i, this
        }
    }), Sl.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Sl,
        _bindAction: function(t, e) {
            var i = t._localRoot || this._root,
                n = t._clip.tracks,
                r = n.length,
                o = t._propertyBindings,
                a = t._interpolants,
                s = i.uuid,
                l = this._bindingsByRootAndName,
                h = l[s];
            void 0 === h && (h = {}, l[s] = h);
            for (var c = 0; c !== r; ++c) {
                var u = n[c],
                    p = u.name,
                    d = h[p];
                if (void 0 !== d) o[c] = d;
                else {
                    if (void 0 !== (d = o[c])) {
                        null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
                        continue
                    }
                    var f = e && e._propertyBindings[c].binding.parsedPath;
                    ++(d = new bl(Tl.create(i, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), o[c] = d
                }
                a[c].resultBuffer = d.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid,
                        i = t._clip.uuid,
                        n = this._actionsByClip[i];
                    this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                }
                for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                    var s = r[o];
                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            var e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(t, e, i) {
            var n = this._actions,
                r = this._actionsByClip,
                o = r[e];
            if (void 0 === o) o = {
                knownActions: [t],
                actionByRoot: {}
            }, t._byClipCacheIndex = 0, r[e] = o;
            else {
                var a = o.knownActions;
                t._byClipCacheIndex = a.length, a.push(t)
            }
            t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t
        },
        _removeInactiveAction: function(t) {
            var e = this._actions,
                i = e[e.length - 1],
                n = t._cacheIndex;
            i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
            var r = t._clip.uuid,
                o = this._actionsByClip,
                a = o[r],
                s = a.knownActions,
                l = s[s.length - 1],
                h = t._byClipCacheIndex;
            l._byClipCacheIndex = h, s[h] = l, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                var r = e[i];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        },
        _lendAction: function(t) {
            var e = this._actions,
                i = t._cacheIndex,
                n = this._nActiveActions++,
                r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        },
        _takeBackAction: function(t) {
            var e = this._actions,
                i = t._cacheIndex,
                n = --this._nActiveActions,
                r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        },
        _addInactiveBinding: function(t, e, i) {
            var n = this._bindingsByRootAndName,
                r = n[e],
                o = this._bindings;
            void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings,
                i = t.binding,
                n = i.rootNode.uuid,
                r = i.path,
                o = this._bindingsByRootAndName,
                a = o[n],
                s = e[e.length - 1],
                l = t._cacheIndex;
            s._cacheIndex = l, e[l] = s, e.pop(), delete a[r];
            t: {
                for (var h in a) break t;delete o[n]
            }
        },
        _lendBinding: function(t) {
            var e = this._bindings,
                i = t._cacheIndex,
                n = this._nActiveBindings++,
                r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        },
        _takeBackBinding: function(t) {
            var e = this._bindings,
                i = t._cacheIndex,
                n = --this._nActiveBindings,
                r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants,
                e = this._nActiveControlInterpolants++,
                i = t[e];
            return void 0 === i && ((i = new ys(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants,
                i = t.__cacheIndex,
                n = --this._nActiveControlInterpolants,
                r = e[n];
            t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e) {
            var i = e || this._root,
                n = i.uuid,
                r = "string" == typeof t ? Ts.findByName(i, t) : t,
                o = null !== r ? r.uuid : t,
                a = this._actionsByClip[o],
                s = null;
            if (void 0 !== a) {
                var l = a.actionByRoot[n];
                if (void 0 !== l) return l;
                s = a.knownActions[0], null === r && (r = s._clip)
            }
            if (null === r) return null;
            var h = new Ml(this, r, e);
            return this._bindAction(h, s), this._addInactiveAction(h, o, n), h
        },
        existingAction: function(t, e) {
            var i = e || this._root,
                n = i.uuid,
                r = "string" == typeof t ? Ts.findByName(i, t) : t,
                o = r ? r.uuid : t,
                a = this._actionsByClip[o];
            return void 0 !== a && a.actionByRoot[n] || null
        },
        stopAllAction: function() {
            var t = this._actions,
                e = this._nActiveActions,
                i = this._bindings,
                n = this._nActiveBindings;
            this._nActiveActions = 0, this._nActiveBindings = 0;
            for (var r = 0; r !== e; ++r) t[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) e[a]._update(n, t, r, o);
            var s = this._bindings,
                l = this._nActiveBindings;
            for (a = 0; a !== l; ++a) s[a].apply(o);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            var e = this._actions,
                i = t.uuid,
                n = this._actionsByClip,
                r = n[i];
            if (void 0 !== r) {
                for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                    var l = o[a];
                    this._deactivateAction(l);
                    var h = l._cacheIndex,
                        c = e[e.length - 1];
                    l._cacheIndex = null, l._byClipCacheIndex = null, c._cacheIndex = h, e[h] = c, e.pop(), this._removeInactiveBindingsForAction(l)
                }
                delete n[i]
            }
        },
        uncacheRoot: function(t) {
            var e = t.uuid,
                i = this._actionsByClip;
            for (var n in i) {
                var r = i[n].actionByRoot[e];
                void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
            }
            var o = this._bindingsByRootAndName[e];
            if (void 0 !== o)
                for (var a in o) {
                    var s = o[a];
                    s.restoreOriginalState(), this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(t, e) {
            var i = this.existingAction(t, e);
            null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
        }
    }), Al.prototype.clone = function() {
        return new Al(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Cl.prototype = Object.assign(Object.create(Yi.prototype), {
        constructor: Cl,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return Yi.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }), Object.defineProperties(Rl.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }), Object.assign(Rl.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e, this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e, this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e, this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e, this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, i) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
        },
        setXYZ: function(t, e, i, n) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
        },
        setXYZW: function(t, e, i, n, r) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
        }
    }), Object.defineProperty(Pl.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }), Object.assign(Pl.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t, this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
        },
        copyAt: function(t, e, i) {
            t *= this.stride, i *= e.stride;
            for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t, this
        }
    }), Ll.prototype = Object.assign(Object.create(Pl.prototype), {
        constructor: Ll,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return Pl.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }
    }), Ol.prototype = Object.assign(Object.create(Ni.prototype), {
        constructor: Ol,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return Ni.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }
    }), Object.assign(Bl.prototype, {
        linePrecision: 1,
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(t, e, i) {
            var n = i || [];
            return Nl(t, this, n, e), n.sort(Il), n
        },
        intersectObjects: function(t, e, i) {
            var n = i || [];
            if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
            for (var r = 0, o = t.length; r < o; r++) Nl(t[r], this, n, e);
            return n.sort(Il), n
        }
    }), Object.assign(zl.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var e = ("undefined" == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    }), Object.assign(Fl.prototype, {
        set: function(t, e, i) {
            return this.radius = t, this.phi = e, this.theta = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        },
        setFromVector3: function(t) {
            return this.radius = t.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(je.clamp(t.y / this.radius, -1, 1))), this
        }
    }), Object.assign(Dl.prototype, {
        set: function(t, e, i) {
            return this.radius = t, this.theta = e, this.y = i, this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
        },
        setFromVector3: function(t) {
            return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
        }
    }), Object.assign(Ul.prototype, {
        set: function(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new We;
            return function(e, i) {
                var n = t.copy(i).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new We), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new We), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t), this.max.max(t), this
        },
        expandByVector: function(t) {
            return this.min.sub(t), this.max.add(t), this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new We), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new We), e.copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new We;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min), this.max.min(t.max), this
        },
        union: function(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        },
        translate: function(t) {
            return this.min.add(t), this.max.add(t), this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), kl.prototype = Object.create(Ai.prototype), kl.prototype.constructor = kl, kl.prototype.isImmediateRenderObject = !0, Vl.prototype = Object.create(Wr.prototype), Vl.prototype.constructor = Vl, Vl.prototype.update = function() {
        var t = new Ye,
            e = new Ye,
            i = new Ze;
        return function() {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld,
                o = this.geometry.attributes.position,
                a = this.object.geometry;
            if (a && a.isGeometry)
                for (var s = a.vertices, l = a.faces, h = 0, c = 0, u = l.length; c < u; c++)
                    for (var p = l[c], d = 0, f = p.vertexNormals.length; d < f; d++) {
                        var m = s[p[n[d]]],
                            v = p.vertexNormals[d];
                        t.copy(m).applyMatrix4(r), e.copy(v).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(h, t.x, t.y, t.z), h += 1, o.setXYZ(h, e.x, e.y, e.z), h += 1
                    } else if (a && a.isBufferGeometry) {
                        var g = a.attributes.position,
                            y = a.attributes.normal;
                        for (h = 0, d = 0, f = g.count; d < f; d++) t.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(r), e.set(y.getX(d), y.getY(d), y.getZ(d)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(h, t.x, t.y, t.z), h += 1, o.setXYZ(h, e.x, e.y, e.z), h += 1
                    }
            o.needsUpdate = !0
        }
    }(), Hl.prototype = Object.create(Ai.prototype), Hl.prototype.constructor = Hl, Hl.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Hl.prototype.update = function() {
        var t = new Ye,
            e = new Ye;
        return function() {
            this.light.updateMatrixWorld();
            var i = this.light.distance ? this.light.distance : 1e3,
                n = i * Math.tan(this.light.angle);
            this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(), Gl.prototype = Object.create(Wr.prototype), Gl.prototype.constructor = Gl, Gl.prototype.updateMatrixWorld = function() {
        var t = new Ye,
            e = new qe,
            i = new qe;
        return function(n) {
            var r = this.bones,
                o = this.geometry,
                a = o.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var s = 0, l = 0; s < r.length; s++) {
                var h = r[s];
                h.parent && h.parent.isBone && (e.multiplyMatrices(i, h.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(l, t.x, t.y, t.z), e.multiplyMatrices(i, h.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(l + 1, t.x, t.y, t.z), l += 2)
            }
            o.getAttribute("position").needsUpdate = !0, Ai.prototype.updateMatrixWorld.call(this, n)
        }
    }(), jl.prototype = Object.create(fn.prototype), jl.prototype.constructor = jl, jl.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose()
    }, jl.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, Wl.prototype = Object.create(Ai.prototype), Wl.prototype.constructor = Wl, Wl.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Wl.prototype.update = function() {
        var t = .5 * this.light.width,
            e = .5 * this.light.height,
            i = this.line.geometry.attributes.position,
            n = i.array;
        n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
    }, ql.prototype = Object.create(Ai.prototype), ql.prototype.constructor = ql, ql.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, ql.prototype.update = function() {
        var t = new Ye,
            e = new vi,
            i = new vi;
        return function() {
            var n = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var r = n.geometry.getAttribute("color");
                e.copy(this.light.color), i.copy(this.light.groundColor);
                for (var o = 0, a = r.count; o < a; o++) {
                    var s = o < a / 2 ? e : i;
                    r.setXYZ(o, s.r, s.g, s.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(), Xl.prototype = Object.create(Wr.prototype), Xl.prototype.constructor = Xl, Yl.prototype = Object.create(Wr.prototype), Yl.prototype.constructor = Yl, Zl.prototype = Object.create(Wr.prototype), Zl.prototype.constructor = Zl, Zl.prototype.update = function() {
        var t = new Ye,
            e = new Ye,
            i = new Ze;
        return function() {
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, l = 0, h = 0, c = s.length; h < c; h++) {
                var u = s[h],
                    p = u.normal;
                t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(n), e.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(l, t.x, t.y, t.z), l += 1, r.setXYZ(l, e.x, e.y, e.z), l += 1
            }
            r.needsUpdate = !0
        }
    }(), Jl.prototype = Object.create(Ai.prototype), Jl.prototype.constructor = Jl, Jl.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, Jl.prototype.update = function() {
        var t = new Ye,
            e = new Ye,
            i = new Ye;
        return function() {
            t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(i), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(i), this.targetLine.scale.z = i.length()
        }
    }(), Kl.prototype = Object.create(Wr.prototype), Kl.prototype.constructor = Kl, Kl.prototype.update = function() {
        var t, e, i = new Ye,
            n = new Ci;

        function r(r, o, a, s) {
            i.set(o, a, s).unproject(n);
            var l = e[r];
            if (void 0 !== l)
                for (var h = t.getAttribute("position"), c = 0, u = l.length; c < u; c++) h.setXYZ(l[c], i.x, i.y, i.z)
        }
        return function() {
            t = this.geometry, e = this.pointMap, n.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
        }
    }(), Ql.prototype = Object.create(Wr.prototype), Ql.prototype.constructor = Ql, Ql.prototype.update = function() {
        var t = new li;
        return function(e) {
            if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                var i = t.min,
                    n = t.max,
                    r = this.geometry.attributes.position,
                    o = r.array;
                o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = i.x, o[4] = n.y, o[5] = n.z, o[6] = i.x, o[7] = i.y, o[8] = n.z, o[9] = n.x, o[10] = i.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = i.z, o[15] = i.x, o[16] = n.y, o[17] = i.z, o[18] = i.x, o[19] = i.y, o[20] = i.z, o[21] = n.x, o[22] = i.y, o[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), Ql.prototype.setFromObject = function(t) {
        return this.object = t, this.update(), this
    }, $l.prototype = Object.create(Wr.prototype), $l.prototype.constructor = $l, $l.prototype.updateMatrixWorld = function(t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Ai.prototype.updateMatrixWorld.call(this, t))
    }, th.prototype = Object.create(jr.prototype), th.prototype.constructor = th, th.prototype.updateMatrixWorld = function(t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.lookAt(this.plane.normal), Ai.prototype.updateMatrixWorld.call(this, t)
    }, eh.prototype = Object.create(Ai.prototype), eh.prototype.constructor = eh, eh.prototype.setDirection = (pl = new Ye, function(t) {
        t.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (pl.set(t.z, 0, -t.x).normalize(), ul = Math.acos(t.y), this.quaternion.setFromAxisAngle(pl, ul))
    }), eh.prototype.setLength = function(t, e, i) {
        void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
    }, eh.prototype.setColor = function(t) {
        this.line.material.color.copy(t), this.cone.material.color.copy(t)
    }, ih.prototype = Object.create(Wr.prototype), ih.prototype.constructor = ih;
    var rh = 0,
        oh = 1;

    function ah(t) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
    }

    function sh(t) {
        return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
            return t.slice()
        }, t
    }

    function lh(t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Yr(t, e)
    }

    function hh(t) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Dr(t)
    }

    function ch(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Yr(t, e)
    }

    function uh(t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Xr(t)
    }

    function ph(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Xr(t)
    }

    function dh(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Xr(t)
    }

    function fh(t, e, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Ye(t, e, i)
    }

    function mh(t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new Ni(t, e).setDynamic(!0)
    }

    function vh(t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new zi(t, e)
    }

    function gh(t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Fi(t, e)
    }

    function yh(t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Di(t, e)
    }

    function _h(t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ui(t, e)
    }

    function xh(t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new ki(t, e)
    }

    function bh(t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Vi(t, e)
    }

    function wh(t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Hi(t, e)
    }

    function Th(t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Gi(t, e)
    }

    function Eh(t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ji(t, e)
    }

    function Mh(t) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ua.call(this, t), this.type = "catmullrom", this.closed = !0
    }

    function Sh(t) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Ua.call(this, t), this.type = "catmullrom"
    }

    function Ah(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Ua.call(this, t), this.type = "catmullrom"
    }

    function Ch(t) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ih(t)
    }

    function Rh(t, e) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ql(t, e)
    }

    function Ph(t, e) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Wr(new na(t.geometry), new Gr({
            color: void 0 !== e ? e : 16777215
        }))
    }

    function Lh(t, e) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Wr(new to(t.geometry), new Gr({
            color: void 0 !== e ? e : 16777215
        }))
    }

    function Oh(t) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Ma(t)
    }

    function Bh(t) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Aa(t)
    }
    La.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(La.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, Object.assign(Ka.prototype, {
        createPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new Ii, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.vertices.push(new Ye(r.x, r.y, r.z || 0))
            }
            return e
        }
    }), Object.assign(Qa.prototype, {
        fromPoints: function(t) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }
    }), Mh.prototype = Object.create(Ua.prototype), Sh.prototype = Object.create(Ua.prototype), Ah.prototype = Object.create(Ua.prototype), Object.assign(Ah.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), Xl.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Gl.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(Ls.prototype, {
        extractUrlBase: function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Os.extractUrlBase(t)
        }
    }), Object.assign(Ul.prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(li.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), pn.prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, Object.assign(je, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), je.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), je.ceilPowerOfTwo(t)
        }
    }), Object.assign(Ze.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(qe.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        },
        getPosition: function() {
            var t;
            return function() {
                return void 0 === t && (t = new Ye), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, i, n, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o)
        }
    }), ci.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, Xe.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, Object.assign(un.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }
    }), Object.assign(dn.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        },
        normal: function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        },
        plane: function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }
    }), Object.assign(dn, {
        barycoordFromPoint: function(t, e, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), dn.getBarycoord(t, e, i, n, r)
        },
        normal: function(t, e, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), dn.getNormal(t, e, i, n)
        }
    }), Object.assign($a.prototype, {
        extractAllPoints: function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        },
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new jo(this, t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ta(this, t)
        }
    }), Object.assign(We.prototype, {
        fromAttribute: function(t, e, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Ye.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(ri.prototype, {
        fromAttribute: function(t, e, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Ii.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(Ai.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(Ai.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(Ur.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(kr.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Object.defineProperty(La.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
        }
    }), Pr.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties(ts.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
            }
        }
    }), Object.defineProperties(Ni.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(Yi.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        },
        addDrawCall: function(t, e, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(Yi.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.defineProperties(Al.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(ln.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new vi
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === A
            }
        }
    }), Object.defineProperties(ma.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(cn.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
            }
        }
    }), Object.assign(Br.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }), Object.defineProperties(Br.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(Sr.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(oi.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
            }
        }
    }), Object.defineProperties(Or.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        }
    }), yl.prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var e = this;
        return (new fl).load(t, function(t) {
            e.setBuffer(t)
        }), this
    }, xl.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, vl.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    };
    var Ih = {
            merge: function(t, e, i) {
                var n;
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
            },
            center: function(t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
            }
        },
        Nh = {
            crossOrigin: void 0,
            loadTexture: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Pa;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, i, void 0, n);
                return e && (o.mapping = e), o
            },
            loadTextureCube: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Ra;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, i, void 0, n);
                return e && (o.mapping = e), o
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        };

    function zh() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
        }, this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }

    function Fh() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
    }
    var Dh = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };

    function Uh() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
}, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , function(t, e, i) {
    ! function(t) {
        "use strict";

        function e(t, e) {
            var i = t.__state.conversionName.toString(),
                n = Math.round(t.r),
                r = Math.round(t.g),
                o = Math.round(t.b),
                a = t.a,
                s = Math.round(t.h),
                l = t.s.toFixed(1),
                h = t.v.toFixed(1);
            if (e || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) {
                for (var c = t.hex.toString(16); c.length < 6;) c = "0" + c;
                return "#" + c
            }
            return "CSS_RGB" === i ? "rgb(" + n + "," + r + "," + o + ")" : "CSS_RGBA" === i ? "rgba(" + n + "," + r + "," + o + "," + a + ")" : "HEX" === i ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === i ? "[" + n + "," + r + "," + o + "]" : "RGBA_ARRAY" === i ? "[" + n + "," + r + "," + o + "," + a + "]" : "RGB_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + o + ",a:" + a + "}" : "HSV_OBJ" === i ? "{h:" + s + ",s:" + l + ",v:" + h + "}" : "HSVA_OBJ" === i ? "{h:" + s + ",s:" + l + ",v:" + h + ",a:" + a + "}" : "unknown format"
        }

        function i(t, e, i) {
            Object.defineProperty(t, e, {
                get: function() {
                    return "RGB" === this.__state.space ? this.__state[e] : (B.recalculateRGB(this, e, i), this.__state[e])
                },
                set: function(t) {
                    "RGB" !== this.__state.space && (B.recalculateRGB(this, e, i), this.__state.space = "RGB"), this.__state[e] = t
                }
            })
        }

        function n(t, e) {
            Object.defineProperty(t, e, {
                get: function() {
                    return "HSV" === this.__state.space ? this.__state[e] : (B.recalculateHSV(this), this.__state[e])
                },
                set: function(t) {
                    "HSV" !== this.__state.space && (B.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
                }
            })
        }

        function r(t) {
            if ("0" === t || x.isUndefined(t)) return 0;
            var e = t.match(z);
            return x.isNull(e) ? 0 : parseFloat(e[1])
        }

        function o(t) {
            var e = t.toString();
            return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
        }

        function a(t, e, i, n, r) {
            return n + (t - e) / (i - e) * (r - n)
        }

        function s(t, e, i, n) {
            t.style.background = "", x.each(q, function(r) {
                t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + i + " 0%, " + n + " 100%); "
            })
        }

        function l(t, e, i) {
            var n = document.createElement("li");
            return e && n.appendChild(e), i ? t.__ul.insertBefore(n, i) : t.__ul.appendChild(n), t.onResize(), n
        }

        function h(t) {
            F.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && F.unbind(window, "unload", t.saveToLocalStorageIfPossible)
        }

        function c(t, e) {
            var i = t.__preset_select[t.__preset_select.selectedIndex];
            i.innerHTML = e ? i.value + "*" : i.value
        }

        function u(t, e) {
            var i = t.getRoot(),
                n = i.__rememberedObjects.indexOf(e.object);
            if (-1 !== n) {
                var r = i.__rememberedObjectIndecesToControllers[n];
                if (void 0 === r && (r = {}, i.__rememberedObjectIndecesToControllers[n] = r), r[e.property] = e, i.load && i.load.remembered) {
                    var o = i.load.remembered,
                        a = void 0;
                    if (o[t.preset]) a = o[t.preset];
                    else {
                        if (!o[K]) return;
                        a = o[K]
                    }
                    if (a[n] && void 0 !== a[n][e.property]) {
                        var s = a[n][e.property];
                        e.initialValue = s, e.setValue(s)
                    }
                }
            }
        }

        function p(t, e, i, n) {
            if (void 0 === e[i]) throw new Error('Object "' + e + '" has no property "' + i + '"');
            var r = void 0;
            if (n.color) r = new W(e, i);
            else {
                var o = [e, i].concat(n.factoryArgs);
                r = Y.apply(t, o)
            }
            n.before instanceof I && (n.before = n.before.__li), u(t, r), F.addClass(r.domElement, "c");
            var a = document.createElement("span");
            F.addClass(a, "property-name"), a.innerHTML = r.property;
            var s = document.createElement("div");
            s.appendChild(a), s.appendChild(r.domElement);
            var h = l(t, s, n.before);
            return F.addClass(h, rt.CLASS_CONTROLLER_ROW), r instanceof W ? F.addClass(h, "color") : F.addClass(h, A(r.getValue())),
                function(t, e, i) {
                    if (i.__li = e, i.__gui = t, x.extend(i, {
                            options: function(e) {
                                if (arguments.length > 1) {
                                    var n = i.__li.nextElementSibling;
                                    return i.remove(), p(t, i.object, i.property, {
                                        before: n,
                                        factoryArgs: [x.toArray(arguments)]
                                    })
                                }
                                if (x.isArray(e) || x.isObject(e)) {
                                    var r = i.__li.nextElementSibling;
                                    return i.remove(), p(t, i.object, i.property, {
                                        before: r,
                                        factoryArgs: [e]
                                    })
                                }
                            },
                            name: function(t) {
                                return i.__li.firstElementChild.firstElementChild.innerHTML = t, i
                            },
                            listen: function() {
                                return i.__gui.listen(i), i
                            },
                            remove: function() {
                                return i.__gui.remove(i), i
                            }
                        }), i instanceof G) {
                        var n = new H(i.object, i.property, {
                            min: i.__min,
                            max: i.__max,
                            step: i.__step
                        });
                        x.each(["updateDisplay", "onChange", "onFinishChange", "step"], function(t) {
                            var e = i[t],
                                r = n[t];
                            i[t] = n[t] = function() {
                                var t = Array.prototype.slice.call(arguments);
                                return r.apply(n, t), e.apply(i, t)
                            }
                        }), F.addClass(e, "has-slider"), i.domElement.insertBefore(n.domElement, i.domElement.firstElementChild)
                    } else if (i instanceof H) {
                        var r = function(e) {
                            if (x.isNumber(i.__min) && x.isNumber(i.__max)) {
                                var n = i.__li.firstElementChild.firstElementChild.innerHTML,
                                    r = i.__gui.__listening.indexOf(i) > -1;
                                i.remove();
                                var o = p(t, i.object, i.property, {
                                    before: i.__li.nextElementSibling,
                                    factoryArgs: [i.__min, i.__max, i.__step]
                                });
                                return o.name(n), r && o.listen(), o
                            }
                            return e
                        };
                        i.min = x.compose(r, i.min), i.max = x.compose(r, i.max)
                    } else i instanceof D ? (F.bind(e, "click", function() {
                        F.fakeEvent(i.__checkbox, "click")
                    }), F.bind(i.__checkbox, "click", function(t) {
                        t.stopPropagation()
                    })) : i instanceof j ? (F.bind(e, "click", function() {
                        F.fakeEvent(i.__button, "click")
                    }), F.bind(e, "mouseover", function() {
                        F.addClass(i.__button, "hover")
                    }), F.bind(e, "mouseout", function() {
                        F.removeClass(i.__button, "hover")
                    })) : i instanceof W && (F.addClass(e, "color"), i.updateDisplay = x.compose(function(t) {
                        return e.style.borderLeftColor = i.__color.toString(), t
                    }, i.updateDisplay), i.updateDisplay());
                    i.setValue = x.compose(function(e) {
                        return t.getRoot().__preset_select && i.isModified() && c(t.getRoot(), !0), e
                    }, i.setValue)
                }(t, h, r), t.__controllers.push(r), r
        }

        function d(t, e) {
            return document.location.href + "." + e
        }

        function f(t, e, i) {
            var n = document.createElement("option");
            n.innerHTML = e, n.value = e, t.__preset_select.appendChild(n), i && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
        }

        function m(t, e) {
            e.style.display = t.useLocalStorage ? "block" : "none"
        }

        function v(t, e) {
            t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
        }

        function g(t, e) {
            var i = {};
            return x.each(t.__rememberedObjects, function(n, r) {
                var o = {},
                    a = t.__rememberedObjectIndecesToControllers[r];
                x.each(a, function(t, i) {
                    o[i] = e ? t.initialValue : t.getValue()
                }), i[r] = o
            }), i
        }
        var y = Array.prototype.forEach,
            _ = Array.prototype.slice,
            x = {
                BREAK: {},
                extend: function(t) {
                    return this.each(_.call(arguments, 1), function(e) {
                        (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) {
                            this.isUndefined(e[i]) || (t[i] = e[i])
                        }.bind(this))
                    }, this), t
                },
                defaults: function(t) {
                    return this.each(_.call(arguments, 1), function(e) {
                        (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) {
                            this.isUndefined(t[i]) && (t[i] = e[i])
                        }.bind(this))
                    }, this), t
                },
                compose: function() {
                    var t = _.call(arguments);
                    return function() {
                        for (var e = _.call(arguments), i = t.length - 1; i >= 0; i--) e = [t[i].apply(this, e)];
                        return e[0]
                    }
                },
                each: function(t, e, i) {
                    if (t)
                        if (y && t.forEach && t.forEach === y) t.forEach(e, i);
                        else if (t.length === t.length + 0) {
                        var n, r = void 0;
                        for (r = 0, n = t.length; r < n; r++)
                            if (r in t && e.call(i, t[r], r) === this.BREAK) return
                    } else
                        for (var o in t)
                            if (e.call(i, t[o], o) === this.BREAK) return
                },
                defer: function(t) {
                    setTimeout(t, 0)
                },
                debounce: function(t, e, i) {
                    var n = void 0;
                    return function() {
                        var r = this,
                            o = arguments,
                            a = i || !n;
                        clearTimeout(n), n = setTimeout(function() {
                            n = null, i || t.apply(r, o)
                        }, e), a && t.apply(r, o)
                    }
                },
                toArray: function(t) {
                    return t.toArray ? t.toArray() : _.call(t)
                },
                isUndefined: function(t) {
                    return void 0 === t
                },
                isNull: function(t) {
                    return null === t
                },
                isNaN: function(t) {
                    function e(e) {
                        return t.apply(this, arguments)
                    }
                    return e.toString = function() {
                        return t.toString()
                    }, e
                }(function(t) {
                    return isNaN(t)
                }),
                isArray: Array.isArray || function(t) {
                    return t.constructor === Array
                },
                isObject: function(t) {
                    return t === Object(t)
                },
                isNumber: function(t) {
                    return t === t + 0
                },
                isString: function(t) {
                    return t === t + ""
                },
                isBoolean: function(t) {
                    return !1 === t || !0 === t
                },
                isFunction: function(t) {
                    return "[object Function]" === Object.prototype.toString.call(t)
                }
            },
            b = [{
                litmus: x.isString,
                conversions: {
                    THREE_CHAR_HEX: {
                        read: function(t) {
                            var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                            return null !== e && {
                                space: "HEX",
                                hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                            }
                        },
                        write: e
                    },
                    SIX_CHAR_HEX: {
                        read: function(t) {
                            var e = t.match(/^#([A-F0-9]{6})$/i);
                            return null !== e && {
                                space: "HEX",
                                hex: parseInt("0x" + e[1].toString(), 0)
                            }
                        },
                        write: e
                    },
                    CSS_RGB: {
                        read: function(t) {
                            var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                            return null !== e && {
                                space: "RGB",
                                r: parseFloat(e[1]),
                                g: parseFloat(e[2]),
                                b: parseFloat(e[3])
                            }
                        },
                        write: e
                    },
                    CSS_RGBA: {
                        read: function(t) {
                            var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                            return null !== e && {
                                space: "RGB",
                                r: parseFloat(e[1]),
                                g: parseFloat(e[2]),
                                b: parseFloat(e[3]),
                                a: parseFloat(e[4])
                            }
                        },
                        write: e
                    }
                }
            }, {
                litmus: x.isNumber,
                conversions: {
                    HEX: {
                        read: function(t) {
                            return {
                                space: "HEX",
                                hex: t,
                                conversionName: "HEX"
                            }
                        },
                        write: function(t) {
                            return t.hex
                        }
                    }
                }
            }, {
                litmus: x.isArray,
                conversions: {
                    RGB_ARRAY: {
                        read: function(t) {
                            return 3 === t.length && {
                                space: "RGB",
                                r: t[0],
                                g: t[1],
                                b: t[2]
                            }
                        },
                        write: function(t) {
                            return [t.r, t.g, t.b]
                        }
                    },
                    RGBA_ARRAY: {
                        read: function(t) {
                            return 4 === t.length && {
                                space: "RGB",
                                r: t[0],
                                g: t[1],
                                b: t[2],
                                a: t[3]
                            }
                        },
                        write: function(t) {
                            return [t.r, t.g, t.b, t.a]
                        }
                    }
                }
            }, {
                litmus: x.isObject,
                conversions: {
                    RGBA_OBJ: {
                        read: function(t) {
                            return !!(x.isNumber(t.r) && x.isNumber(t.g) && x.isNumber(t.b) && x.isNumber(t.a)) && {
                                space: "RGB",
                                r: t.r,
                                g: t.g,
                                b: t.b,
                                a: t.a
                            }
                        },
                        write: function(t) {
                            return {
                                r: t.r,
                                g: t.g,
                                b: t.b,
                                a: t.a
                            }
                        }
                    },
                    RGB_OBJ: {
                        read: function(t) {
                            return !!(x.isNumber(t.r) && x.isNumber(t.g) && x.isNumber(t.b)) && {
                                space: "RGB",
                                r: t.r,
                                g: t.g,
                                b: t.b
                            }
                        },
                        write: function(t) {
                            return {
                                r: t.r,
                                g: t.g,
                                b: t.b
                            }
                        }
                    },
                    HSVA_OBJ: {
                        read: function(t) {
                            return !!(x.isNumber(t.h) && x.isNumber(t.s) && x.isNumber(t.v) && x.isNumber(t.a)) && {
                                space: "HSV",
                                h: t.h,
                                s: t.s,
                                v: t.v,
                                a: t.a
                            }
                        },
                        write: function(t) {
                            return {
                                h: t.h,
                                s: t.s,
                                v: t.v,
                                a: t.a
                            }
                        }
                    },
                    HSV_OBJ: {
                        read: function(t) {
                            return !!(x.isNumber(t.h) && x.isNumber(t.s) && x.isNumber(t.v)) && {
                                space: "HSV",
                                h: t.h,
                                s: t.s,
                                v: t.v
                            }
                        },
                        write: function(t) {
                            return {
                                h: t.h,
                                s: t.s,
                                v: t.v
                            }
                        }
                    }
                }
            }],
            w = void 0,
            T = void 0,
            E = function() {
                T = !1;
                var t = arguments.length > 1 ? x.toArray(arguments) : arguments[0];
                return x.each(b, function(e) {
                    if (e.litmus(t)) return x.each(e.conversions, function(e, i) {
                        if (w = e.read(t), !1 === T && !1 !== w) return T = w, w.conversionName = i, w.conversion = e, x.BREAK
                    }), x.BREAK
                }), T
            },
            M = void 0,
            S = {
                hsv_to_rgb: function(t, e, i) {
                    var n = Math.floor(t / 60) % 6,
                        r = t / 60 - Math.floor(t / 60),
                        o = i * (1 - e),
                        a = i * (1 - r * e),
                        s = i * (1 - (1 - r) * e),
                        l = [
                            [i, s, o],
                            [a, i, o],
                            [o, i, s],
                            [o, a, i],
                            [s, o, i],
                            [i, o, a]
                        ][n];
                    return {
                        r: 255 * l[0],
                        g: 255 * l[1],
                        b: 255 * l[2]
                    }
                },
                rgb_to_hsv: function(t, e, i) {
                    var n = Math.min(t, e, i),
                        r = Math.max(t, e, i),
                        o = r - n,
                        a = void 0;
                    return 0 === r ? {
                        h: NaN,
                        s: 0,
                        v: 0
                    } : (a = t === r ? (e - i) / o : e === r ? 2 + (i - t) / o : 4 + (t - e) / o, (a /= 6) < 0 && (a += 1), {
                        h: 360 * a,
                        s: o / r,
                        v: r / 255
                    })
                },
                rgb_to_hex: function(t, e, i) {
                    var n = this.hex_with_component(0, 2, t);
                    return n = this.hex_with_component(n, 1, e), this.hex_with_component(n, 0, i)
                },
                component_from_hex: function(t, e) {
                    return t >> 8 * e & 255
                },
                hex_with_component: function(t, e, i) {
                    return i << (M = 8 * e) | t & ~(255 << M)
                }
            },
            A = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            },
            C = function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            },
            R = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            P = function t(e, i, n) {
                null === e && (e = Function.prototype);
                var r = Object.getOwnPropertyDescriptor(e, i);
                if (void 0 === r) {
                    var o = Object.getPrototypeOf(e);
                    return null === o ? void 0 : t(o, i, n)
                }
                if ("value" in r) return r.value;
                var a = r.get;
                return void 0 !== a ? a.call(n) : void 0
            },
            L = function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            },
            O = function(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            },
            B = function() {
                function t() {
                    if (C(this, t), this.__state = E.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                    this.__state.a = this.__state.a || 1
                }
                return R(t, [{
                    key: "toString",
                    value: function() {
                        return e(this)
                    }
                }, {
                    key: "toHexString",
                    value: function() {
                        return e(this, !0)
                    }
                }, {
                    key: "toOriginal",
                    value: function() {
                        return this.__state.conversion.write(this)
                    }
                }]), t
            }();
        B.recalculateRGB = function(t, e, i) {
            if ("HEX" === t.__state.space) t.__state[e] = S.component_from_hex(t.__state.hex, i);
            else {
                if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
                x.extend(t.__state, S.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
            }
        }, B.recalculateHSV = function(t) {
            var e = S.rgb_to_hsv(t.r, t.g, t.b);
            x.extend(t.__state, {
                s: e.s,
                v: e.v
            }), x.isNaN(e.h) ? x.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
        }, B.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], i(B.prototype, "r", 2), i(B.prototype, "g", 1), i(B.prototype, "b", 0), n(B.prototype, "h"), n(B.prototype, "s"), n(B.prototype, "v"), Object.defineProperty(B.prototype, "a", {
            get: function() {
                return this.__state.a
            },
            set: function(t) {
                this.__state.a = t
            }
        }), Object.defineProperty(B.prototype, "hex", {
            get: function() {
                return "HEX" !== !this.__state.space && (this.__state.hex = S.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
            },
            set: function(t) {
                this.__state.space = "HEX", this.__state.hex = t
            }
        });
        var I = function() {
                function t(e, i) {
                    C(this, t), this.initialValue = e[i], this.domElement = document.createElement("div"), this.object = e, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0
                }
                return R(t, [{
                    key: "onChange",
                    value: function(t) {
                        return this.__onChange = t, this
                    }
                }, {
                    key: "onFinishChange",
                    value: function(t) {
                        return this.__onFinishChange = t, this
                    }
                }, {
                    key: "setValue",
                    value: function(t) {
                        return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                    }
                }, {
                    key: "getValue",
                    value: function() {
                        return this.object[this.property]
                    }
                }, {
                    key: "updateDisplay",
                    value: function() {
                        return this
                    }
                }, {
                    key: "isModified",
                    value: function() {
                        return this.initialValue !== this.getValue()
                    }
                }]), t
            }(),
            N = {};
        x.each({
            HTMLEvents: ["change"],
            MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
            KeyboardEvents: ["keydown"]
        }, function(t, e) {
            x.each(t, function(t) {
                N[t] = e
            })
        });
        var z = /(\d+(\.\d+)?)px/,
            F = {
                makeSelectable: function(t, e) {
                    void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                        return !1
                    } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
                },
                makeFullscreen: function(t, e, i) {
                    var n = i,
                        r = e;
                    x.isUndefined(r) && (r = !0), x.isUndefined(n) && (n = !0), t.style.position = "absolute", r && (t.style.left = 0, t.style.right = 0), n && (t.style.top = 0, t.style.bottom = 0)
                },
                fakeEvent: function(t, e, i, n) {
                    var r = i || {},
                        o = N[e];
                    if (!o) throw new Error("Event type " + e + " not supported.");
                    var a = document.createEvent(o);
                    switch (o) {
                        case "MouseEvents":
                            var s = r.x || r.clientX || 0,
                                l = r.y || r.clientY || 0;
                            a.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, s, l, !1, !1, !1, !1, 0, null);
                            break;
                        case "KeyboardEvents":
                            var h = a.initKeyboardEvent || a.initKeyEvent;
                            x.defaults(r, {
                                cancelable: !0,
                                ctrlKey: !1,
                                altKey: !1,
                                shiftKey: !1,
                                metaKey: !1,
                                keyCode: void 0,
                                charCode: void 0
                            }), h(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                            break;
                        default:
                            a.initEvent(e, r.bubbles || !1, r.cancelable || !0)
                    }
                    x.defaults(a, n), t.dispatchEvent(a)
                },
                bind: function(t, e, i, n) {
                    var r = n || !1;
                    return t.addEventListener ? t.addEventListener(e, i, r) : t.attachEvent && t.attachEvent("on" + e, i), F
                },
                unbind: function(t, e, i, n) {
                    var r = n || !1;
                    return t.removeEventListener ? t.removeEventListener(e, i, r) : t.detachEvent && t.detachEvent("on" + e, i), F
                },
                addClass: function(t, e) {
                    if (void 0 === t.className) t.className = e;
                    else if (t.className !== e) {
                        var i = t.className.split(/ +/); - 1 === i.indexOf(e) && (i.push(e), t.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                    }
                    return F
                },
                removeClass: function(t, e) {
                    if (e)
                        if (t.className === e) t.removeAttribute("class");
                        else {
                            var i = t.className.split(/ +/),
                                n = i.indexOf(e); - 1 !== n && (i.splice(n, 1), t.className = i.join(" "))
                        }
                    else t.className = void 0;
                    return F
                },
                hasClass: function(t, e) {
                    return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
                },
                getWidth: function(t) {
                    var e = getComputedStyle(t);
                    return r(e["border-left-width"]) + r(e["border-right-width"]) + r(e["padding-left"]) + r(e["padding-right"]) + r(e.width)
                },
                getHeight: function(t) {
                    var e = getComputedStyle(t);
                    return r(e["border-top-width"]) + r(e["border-bottom-width"]) + r(e["padding-top"]) + r(e["padding-bottom"]) + r(e.height)
                },
                getOffset: function(t) {
                    var e = t,
                        i = {
                            left: 0,
                            top: 0
                        };
                    if (e.offsetParent)
                        do {
                            i.left += e.offsetLeft, i.top += e.offsetTop, e = e.offsetParent
                        } while (e);
                    return i
                },
                isActive: function(t) {
                    return t === document.activeElement && (t.type || t.href)
                }
            },
            D = function(t) {
                function e(t, i) {
                    C(this, e);
                    var n = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        r = n;
                    return n.__prev = n.getValue(), n.__checkbox = document.createElement("input"), n.__checkbox.setAttribute("type", "checkbox"), F.bind(n.__checkbox, "change", function() {
                        r.setValue(!r.__prev)
                    }, !1), n.domElement.appendChild(n.__checkbox), n.updateDisplay(), n
                }
                return L(e, I), R(e, [{
                    key: "setValue",
                    value: function(t) {
                        var i = P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                        return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i
                    }
                }, {
                    key: "updateDisplay",
                    value: function() {
                        return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]), e
            }(),
            U = function(t) {
                function e(t, i, n) {
                    C(this, e);
                    var r = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        o = n,
                        a = r;
                    if (r.__select = document.createElement("select"), x.isArray(o)) {
                        var s = {};
                        x.each(o, function(t) {
                            s[t] = t
                        }), o = s
                    }
                    return x.each(o, function(t, e) {
                        var i = document.createElement("option");
                        i.innerHTML = e, i.setAttribute("value", t), a.__select.appendChild(i)
                    }), r.updateDisplay(), F.bind(r.__select, "change", function() {
                        var t = this.options[this.selectedIndex].value;
                        a.setValue(t)
                    }), r.domElement.appendChild(r.__select), r
                }
                return L(e, I), R(e, [{
                    key: "setValue",
                    value: function(t) {
                        var i = P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                        return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i
                    }
                }, {
                    key: "updateDisplay",
                    value: function() {
                        return F.isActive(this.__select) ? this : (this.__select.value = this.getValue(), P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                    }
                }]), e
            }(),
            k = function(t) {
                function e(t, i) {
                    function n() {
                        o.setValue(o.__input.value)
                    }
                    C(this, e);
                    var r = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        o = r;
                    return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), F.bind(r.__input, "keyup", n), F.bind(r.__input, "change", n), F.bind(r.__input, "blur", function() {
                        o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
                    }), F.bind(r.__input, "keydown", function(t) {
                        13 === t.keyCode && this.blur()
                    }), r.updateDisplay(), r.domElement.appendChild(r.__input), r
                }
                return L(e, I), R(e, [{
                    key: "updateDisplay",
                    value: function() {
                        return F.isActive(this.__input) || (this.__input.value = this.getValue()), P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]), e
            }(),
            V = function(t) {
                function e(t, i, n) {
                    C(this, e);
                    var r = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        a = n || {};
                    return r.__min = a.min, r.__max = a.max, r.__step = a.step, x.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = o(r.__impliedStep), r
                }
                return L(e, I), R(e, [{
                    key: "setValue",
                    value: function(t) {
                        var i = t;
                        return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, i)
                    }
                }, {
                    key: "min",
                    value: function(t) {
                        return this.__min = t, this
                    }
                }, {
                    key: "max",
                    value: function(t) {
                        return this.__max = t, this
                    }
                }, {
                    key: "step",
                    value: function(t) {
                        return this.__step = t, this.__impliedStep = t, this.__precision = o(t), this
                    }
                }]), e
            }(),
            H = function(t) {
                function e(t, i, n) {
                    function r() {
                        l.__onFinishChange && l.__onFinishChange.call(l, l.getValue())
                    }

                    function o(t) {
                        var e = h - t.clientY;
                        l.setValue(l.getValue() + e * l.__impliedStep), h = t.clientY
                    }

                    function a() {
                        F.unbind(window, "mousemove", o), F.unbind(window, "mouseup", a), r()
                    }
                    C(this, e);
                    var s = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, n));
                    s.__truncationSuspended = !1;
                    var l = s,
                        h = void 0;
                    return s.__input = document.createElement("input"), s.__input.setAttribute("type", "text"), F.bind(s.__input, "change", function() {
                        var t = parseFloat(l.__input.value);
                        x.isNaN(t) || l.setValue(t)
                    }), F.bind(s.__input, "blur", function() {
                        r()
                    }), F.bind(s.__input, "mousedown", function(t) {
                        F.bind(window, "mousemove", o), F.bind(window, "mouseup", a), h = t.clientY
                    }), F.bind(s.__input, "keydown", function(t) {
                        13 === t.keyCode && (l.__truncationSuspended = !0, this.blur(), l.__truncationSuspended = !1, r())
                    }), s.updateDisplay(), s.domElement.appendChild(s.__input), s
                }
                return L(e, V), R(e, [{
                    key: "updateDisplay",
                    value: function() {
                        return this.__input.value = this.__truncationSuspended ? this.getValue() : function(t, e) {
                            var i = Math.pow(10, e);
                            return Math.round(t * i) / i
                        }(this.getValue(), this.__precision), P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]), e
            }(),
            G = function(t) {
                function e(t, i, n, r, o) {
                    function s(t) {
                        t.preventDefault();
                        var e = p.__background.getBoundingClientRect();
                        return p.setValue(a(t.clientX, e.left, e.right, p.__min, p.__max)), !1
                    }

                    function l() {
                        F.unbind(window, "mousemove", s), F.unbind(window, "mouseup", l), p.__onFinishChange && p.__onFinishChange.call(p, p.getValue())
                    }

                    function h(t) {
                        var e = t.touches[0].clientX,
                            i = p.__background.getBoundingClientRect();
                        p.setValue(a(e, i.left, i.right, p.__min, p.__max))
                    }

                    function c() {
                        F.unbind(window, "touchmove", h), F.unbind(window, "touchend", c), p.__onFinishChange && p.__onFinishChange.call(p, p.getValue())
                    }
                    C(this, e);
                    var u = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, {
                            min: n,
                            max: r,
                            step: o
                        })),
                        p = u;
                    return u.__background = document.createElement("div"), u.__foreground = document.createElement("div"), F.bind(u.__background, "mousedown", function(t) {
                        document.activeElement.blur(), F.bind(window, "mousemove", s), F.bind(window, "mouseup", l), s(t)
                    }), F.bind(u.__background, "touchstart", function(t) {
                        1 === t.touches.length && (F.bind(window, "touchmove", h), F.bind(window, "touchend", c), h(t))
                    }), F.addClass(u.__background, "slider"), F.addClass(u.__foreground, "slider-fg"), u.updateDisplay(), u.__background.appendChild(u.__foreground), u.domElement.appendChild(u.__background), u
                }
                return L(e, V), R(e, [{
                    key: "updateDisplay",
                    value: function() {
                        var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                        return this.__foreground.style.width = 100 * t + "%", P(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                    }
                }]), e
            }(),
            j = function(t) {
                function e(t, i, n) {
                    C(this, e);
                    var r = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        o = r;
                    return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === n ? "Fire" : n, F.bind(r.__button, "click", function(t) {
                        return t.preventDefault(), o.fire(), !1
                    }), F.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r
                }
                return L(e, I), R(e, [{
                    key: "fire",
                    value: function() {
                        this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                    }
                }]), e
            }(),
            W = function(t) {
                function e(t, i) {
                    function n(t) {
                        c(t), F.bind(window, "mousemove", c), F.bind(window, "touchmove", c), F.bind(window, "mouseup", o), F.bind(window, "touchend", o)
                    }

                    function r(t) {
                        u(t), F.bind(window, "mousemove", u), F.bind(window, "touchmove", u), F.bind(window, "mouseup", a), F.bind(window, "touchend", a)
                    }

                    function o() {
                        F.unbind(window, "mousemove", c), F.unbind(window, "touchmove", c), F.unbind(window, "mouseup", o), F.unbind(window, "touchend", o), h()
                    }

                    function a() {
                        F.unbind(window, "mousemove", u), F.unbind(window, "touchmove", u), F.unbind(window, "mouseup", a), F.unbind(window, "touchend", a), h()
                    }

                    function l() {
                        var t = E(this.value);
                        !1 !== t ? (d.__color.__state = t, d.setValue(d.__color.toOriginal())) : this.value = d.__color.toString()
                    }

                    function h() {
                        d.__onFinishChange && d.__onFinishChange.call(d, d.__color.toOriginal())
                    }

                    function c(t) {
                        -1 === t.type.indexOf("touch") && t.preventDefault();
                        var e = d.__saturation_field.getBoundingClientRect(),
                            i = t.touches && t.touches[0] || t,
                            n = i.clientX,
                            r = i.clientY,
                            o = (n - e.left) / (e.right - e.left),
                            a = 1 - (r - e.top) / (e.bottom - e.top);
                        return a > 1 ? a = 1 : a < 0 && (a = 0), o > 1 ? o = 1 : o < 0 && (o = 0), d.__color.v = a, d.__color.s = o, d.setValue(d.__color.toOriginal()), !1
                    }

                    function u(t) {
                        -1 === t.type.indexOf("touch") && t.preventDefault();
                        var e = d.__hue_field.getBoundingClientRect(),
                            i = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
                        return i > 1 ? i = 1 : i < 0 && (i = 0), d.__color.h = 360 * i, d.setValue(d.__color.toOriginal()), !1
                    }
                    C(this, e);
                    var p = O(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    p.__color = new B(p.getValue()), p.__temp = new B(0);
                    var d = p;
                    p.domElement = document.createElement("div"), F.makeSelectable(p.domElement, !1), p.__selector = document.createElement("div"), p.__selector.className = "selector", p.__saturation_field = document.createElement("div"), p.__saturation_field.className = "saturation-field", p.__field_knob = document.createElement("div"), p.__field_knob.className = "field-knob", p.__field_knob_border = "2px solid ", p.__hue_knob = document.createElement("div"), p.__hue_knob.className = "hue-knob", p.__hue_field = document.createElement("div"), p.__hue_field.className = "hue-field", p.__input = document.createElement("input"), p.__input.type = "text", p.__input_textShadow = "0 1px 1px ", F.bind(p.__input, "keydown", function(t) {
                        13 === t.keyCode && l.call(this)
                    }), F.bind(p.__input, "blur", l), F.bind(p.__selector, "mousedown", function() {
                        F.addClass(this, "drag").bind(window, "mouseup", function() {
                            F.removeClass(d.__selector, "drag")
                        })
                    }), F.bind(p.__selector, "touchstart", function() {
                        F.addClass(this, "drag").bind(window, "touchend", function() {
                            F.removeClass(d.__selector, "drag")
                        })
                    });
                    var f = document.createElement("div");
                    return x.extend(p.__selector.style, {
                            width: "122px",
                            height: "102px",
                            padding: "3px",
                            backgroundColor: "#222",
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                        }), x.extend(p.__field_knob.style, {
                            position: "absolute",
                            width: "12px",
                            height: "12px",
                            border: p.__field_knob_border + (p.__color.v < .5 ? "#fff" : "#000"),
                            boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                            borderRadius: "12px",
                            zIndex: 1
                        }), x.extend(p.__hue_knob.style, {
                            position: "absolute",
                            width: "15px",
                            height: "2px",
                            borderRight: "4px solid #fff",
                            zIndex: 1
                        }), x.extend(p.__saturation_field.style, {
                            width: "100px",
                            height: "100px",
                            border: "1px solid #555",
                            marginRight: "3px",
                            display: "inline-block",
                            cursor: "pointer"
                        }), x.extend(f.style, {
                            width: "100%",
                            height: "100%",
                            background: "none"
                        }), s(f, "top", "rgba(0,0,0,0)", "#000"), x.extend(p.__hue_field.style, {
                            width: "15px",
                            height: "100px",
                            border: "1px solid #555",
                            cursor: "ns-resize",
                            position: "absolute",
                            top: "3px",
                            right: "3px"
                        }),
                        function(t) {
                            t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
                        }(p.__hue_field), x.extend(p.__input.style, {
                            outline: "none",
                            textAlign: "center",
                            color: "#fff",
                            border: 0,
                            fontWeight: "bold",
                            textShadow: p.__input_textShadow + "rgba(0,0,0,0.7)"
                        }), F.bind(p.__saturation_field, "mousedown", n), F.bind(p.__saturation_field, "touchstart", n), F.bind(p.__field_knob, "mousedown", n), F.bind(p.__field_knob, "touchstart", n), F.bind(p.__hue_field, "mousedown", r), F.bind(p.__hue_field, "touchstart", r), p.__saturation_field.appendChild(f), p.__selector.appendChild(p.__field_knob), p.__selector.appendChild(p.__saturation_field), p.__selector.appendChild(p.__hue_field), p.__hue_field.appendChild(p.__hue_knob), p.domElement.appendChild(p.__input), p.domElement.appendChild(p.__selector), p.updateDisplay(), p
                }
                return L(e, I), R(e, [{
                    key: "updateDisplay",
                    value: function() {
                        var t = E(this.getValue());
                        if (!1 !== t) {
                            var e = !1;
                            x.each(B.COMPONENTS, function(i) {
                                if (!x.isUndefined(t[i]) && !x.isUndefined(this.__color.__state[i]) && t[i] !== this.__color.__state[i]) return e = !0, {}
                            }, this), e && x.extend(this.__color.__state, t)
                        }
                        x.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                        var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                            n = 255 - i;
                        x.extend(this.__field_knob.style, {
                            marginLeft: 100 * this.__color.s - 7 + "px",
                            marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                            backgroundColor: this.__temp.toHexString(),
                            border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")"
                        }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, s(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), x.extend(this.__input.style, {
                            backgroundColor: this.__color.toHexString(),
                            color: "rgb(" + i + "," + i + "," + i + ")",
                            textShadow: this.__input_textShadow + "rgba(" + n + "," + n + "," + n + ",.7)"
                        })
                    }
                }]), e
            }(),
            q = ["-moz-", "-o-", "-webkit-", "-ms-", ""],
            X = function(t, e) {
                var i = e || document,
                    n = document.createElement("style");
                n.type = "text/css", n.innerHTML = t;
                var r = i.getElementsByTagName("head")[0];
                try {
                    r.appendChild(n)
                } catch (t) {}
            },
            Y = function(t, e) {
                var i = t[e];
                return x.isArray(arguments[2]) || x.isObject(arguments[2]) ? new U(t, e, arguments[2]) : x.isNumber(i) ? x.isNumber(arguments[2]) && x.isNumber(arguments[3]) ? x.isNumber(arguments[4]) ? new G(t, e, arguments[2], arguments[3], arguments[4]) : new G(t, e, arguments[2], arguments[3]) : x.isNumber(arguments[4]) ? new H(t, e, {
                    min: arguments[2],
                    max: arguments[3],
                    step: arguments[4]
                }) : new H(t, e, {
                    min: arguments[2],
                    max: arguments[3]
                }) : x.isString(i) ? new k(t, e) : x.isFunction(i) ? new j(t, e, "") : x.isBoolean(i) ? new D(t, e) : null
            },
            Z = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
                setTimeout(t, 1e3 / 60)
            },
            J = function() {
                function t() {
                    C(this, t), this.backgroundElement = document.createElement("div"), x.extend(this.backgroundElement.style, {
                        backgroundColor: "rgba(0,0,0,0.8)",
                        top: 0,
                        left: 0,
                        display: "none",
                        zIndex: "1000",
                        opacity: 0,
                        WebkitTransition: "opacity 0.2s linear",
                        transition: "opacity 0.2s linear"
                    }), F.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), x.extend(this.domElement.style, {
                        position: "fixed",
                        display: "none",
                        zIndex: "1001",
                        opacity: 0,
                        WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                        transition: "transform 0.2s ease-out, opacity 0.2s linear"
                    }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                    var e = this;
                    F.bind(this.backgroundElement, "click", function() {
                        e.hide()
                    })
                }
                return R(t, [{
                    key: "show",
                    value: function() {
                        var t = this;
                        this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), x.defer(function() {
                            t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                        })
                    }
                }, {
                    key: "hide",
                    value: function() {
                        var t = this,
                            e = function e() {
                                t.domElement.style.display = "none", t.backgroundElement.style.display = "none", F.unbind(t.domElement, "webkitTransitionEnd", e), F.unbind(t.domElement, "transitionend", e), F.unbind(t.domElement, "oTransitionEnd", e)
                            };
                        F.bind(this.domElement, "webkitTransitionEnd", e), F.bind(this.domElement, "transitionend", e), F.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                    }
                }, {
                    key: "layout",
                    value: function() {
                        this.domElement.style.left = window.innerWidth / 2 - F.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - F.getHeight(this.domElement) / 2 + "px"
                    }
                }]), t
            }();
        X(function(t) {
            if ("undefined" != typeof window) {
                var e = document.createElement("style");
                return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t
            }
        }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
        var K = "Default",
            Q = function() {
                try {
                    return !!window.localStorage
                } catch (t) {
                    return !1
                }
            }(),
            $ = void 0,
            tt = !0,
            et = void 0,
            it = !1,
            nt = [],
            rt = function t(e) {
                var i = this,
                    n = e || {};
                this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), F.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = x.defaults(n, {
                    closeOnTop: !1,
                    autoPlace: !0,
                    width: t.DEFAULT_WIDTH
                }), n = x.defaults(n, {
                    resizable: n.autoPlace,
                    hideable: n.autoPlace
                }), x.isUndefined(n.load) ? n.load = {
                    preset: K
                } : n.preset && (n.load.preset = n.preset), x.isUndefined(n.parent) && n.hideable && nt.push(this), n.resizable = x.isUndefined(n.parent) && n.resizable, n.autoPlace && x.isUndefined(n.scrollable) && (n.scrollable = !0);
                var r = Q && "true" === localStorage.getItem(d(0, "isLocal")),
                    o = void 0;
                if (Object.defineProperties(this, {
                        parent: {
                            get: function() {
                                return n.parent
                            }
                        },
                        scrollable: {
                            get: function() {
                                return n.scrollable
                            }
                        },
                        autoPlace: {
                            get: function() {
                                return n.autoPlace
                            }
                        },
                        closeOnTop: {
                            get: function() {
                                return n.closeOnTop
                            }
                        },
                        preset: {
                            get: function() {
                                return i.parent ? i.getRoot().preset : n.load.preset
                            },
                            set: function(t) {
                                i.parent ? i.getRoot().preset = t : n.load.preset = t,
                                    function(t) {
                                        for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
                                    }(this), i.revert()
                            }
                        },
                        width: {
                            get: function() {
                                return n.width
                            },
                            set: function(t) {
                                n.width = t, v(i, t)
                            }
                        },
                        name: {
                            get: function() {
                                return n.name
                            },
                            set: function(t) {
                                n.name = t, titleRowName && (titleRowName.innerHTML = n.name)
                            }
                        },
                        closed: {
                            get: function() {
                                return n.closed
                            },
                            set: function(e) {
                                n.closed = e, n.closed ? F.addClass(i.__ul, t.CLASS_CLOSED) : F.removeClass(i.__ul, t.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                            }
                        },
                        load: {
                            get: function() {
                                return n.load
                            }
                        },
                        useLocalStorage: {
                            get: function() {
                                return r
                            },
                            set: function(t) {
                                Q && (r = t, t ? F.bind(window, "unload", o) : F.unbind(window, "unload", o), localStorage.setItem(d(0, "isLocal"), t))
                            }
                        }
                    }), x.isUndefined(n.parent)) {
                    if (n.closed = !1, F.addClass(this.domElement, t.CLASS_MAIN), F.makeSelectable(this.domElement, !1), Q && r) {
                        i.useLocalStorage = !0;
                        var a = localStorage.getItem(d(0, "gui"));
                        a && (n.load = JSON.parse(a))
                    }
                    this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, F.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), n.closeOnTop ? (F.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (F.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), F.bind(this.__closeButton, "click", function() {
                        i.closed = !i.closed
                    })
                } else {
                    void 0 === n.closed && (n.closed = !0);
                    var s = document.createTextNode(n.name);
                    F.addClass(s, "controller-name");
                    var h = l(i, s);
                    F.addClass(this.__ul, t.CLASS_CLOSED), F.addClass(h, "title"), F.bind(h, "click", function(t) {
                        return t.preventDefault(), i.closed = !i.closed, !1
                    }), n.closed || (this.closed = !1)
                }
                n.autoPlace && (x.isUndefined(n.parent) && (tt && (et = document.createElement("div"), F.addClass(et, "dg"), F.addClass(et, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(et), tt = !1), et.appendChild(this.domElement), F.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || v(i, n.width)), this.__resizeHandler = function() {
                    i.onResizeDebounced()
                }, F.bind(window, "resize", this.__resizeHandler), F.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), F.bind(this.__ul, "transitionend", this.__resizeHandler), F.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && function(t) {
                    function e(e) {
                        return e.preventDefault(), t.width += r - e.clientX, t.onResize(), r = e.clientX, !1
                    }

                    function i() {
                        F.removeClass(t.__closeButton, rt.CLASS_DRAG), F.unbind(window, "mousemove", e), F.unbind(window, "mouseup", i)
                    }

                    function n(n) {
                        return n.preventDefault(), r = n.clientX, F.addClass(t.__closeButton, rt.CLASS_DRAG), F.bind(window, "mousemove", e), F.bind(window, "mouseup", i), !1
                    }
                    var r = void 0;
                    t.__resize_handle = document.createElement("div"), x.extend(t.__resize_handle.style, {
                        width: "6px",
                        marginLeft: "-3px",
                        height: "200px",
                        cursor: "ew-resize",
                        position: "absolute"
                    }), F.bind(t.__resize_handle, "mousedown", n), F.bind(t.__closeButton, "mousedown", n), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
                }(this), o = function() {
                    Q && "true" === localStorage.getItem(d(0, "isLocal")) && localStorage.setItem(d(0, "gui"), JSON.stringify(i.getSaveObject()))
                }, this.saveToLocalStorageIfPossible = o, n.parent || function() {
                    var t = i.getRoot();
                    t.width += 1, x.defer(function() {
                        t.width -= 1
                    })
                }()
            };
        rt.toggleHide = function() {
            it = !it, x.each(nt, function(t) {
                t.domElement.style.display = it ? "none" : ""
            })
        }, rt.CLASS_AUTO_PLACE = "a", rt.CLASS_AUTO_PLACE_CONTAINER = "ac", rt.CLASS_MAIN = "main", rt.CLASS_CONTROLLER_ROW = "cr", rt.CLASS_TOO_TALL = "taller-than-window", rt.CLASS_CLOSED = "closed", rt.CLASS_CLOSE_BUTTON = "close-button", rt.CLASS_CLOSE_TOP = "close-top", rt.CLASS_CLOSE_BOTTOM = "close-bottom", rt.CLASS_DRAG = "drag", rt.DEFAULT_WIDTH = 245, rt.TEXT_CLOSED = "Close Controls", rt.TEXT_OPEN = "Open Controls", rt._keydownHandler = function(t) {
            "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || rt.toggleHide()
        }, F.bind(window, "keydown", rt._keydownHandler, !1), x.extend(rt.prototype, {
            add: function(t, e) {
                return p(this, t, e, {
                    factoryArgs: Array.prototype.slice.call(arguments, 2)
                })
            },
            addColor: function(t, e) {
                return p(this, t, e, {
                    color: !0
                })
            },
            remove: function(t) {
                this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
                var e = this;
                x.defer(function() {
                    e.onResize()
                })
            },
            destroy: function() {
                if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                this.autoPlace && et.removeChild(this.domElement);
                var t = this;
                x.each(this.__folders, function(e) {
                    t.removeFolder(e)
                }), F.unbind(window, "keydown", rt._keydownHandler, !1), h(this)
            },
            addFolder: function(t) {
                if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
                var e = {
                    name: t,
                    parent: this
                };
                e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
                var i = new rt(e);
                this.__folders[t] = i;
                var n = l(this, i.domElement);
                return F.addClass(n, "folder"), i
            },
            removeFolder: function(t) {
                this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], h(t);
                var e = this;
                x.each(t.__folders, function(e) {
                    t.removeFolder(e)
                }), x.defer(function() {
                    e.onResize()
                })
            },
            open: function() {
                this.closed = !1
            },
            close: function() {
                this.closed = !0
            },
            onResize: function() {
                var t = this.getRoot();
                if (t.scrollable) {
                    var e = F.getOffset(t.__ul).top,
                        i = 0;
                    x.each(t.__ul.childNodes, function(e) {
                        t.autoPlace && e === t.__save_row || (i += F.getHeight(e))
                    }), window.innerHeight - e - 20 < i ? (F.addClass(t.domElement, rt.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (F.removeClass(t.domElement, rt.CLASS_TOO_TALL), t.__ul.style.height = "auto")
                }
                t.__resize_handle && x.defer(function() {
                    t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
                }), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
            },
            onResizeDebounced: x.debounce(function() {
                this.onResize()
            }, 50),
            remember: function() {
                if (x.isUndefined($) && (($ = new J).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'), this.parent) throw new Error("You can only call remember on a top level GUI.");
                var t = this;
                x.each(Array.prototype.slice.call(arguments), function(e) {
                    0 === t.__rememberedObjects.length && function(t) {
                        var e = t.__save_row = document.createElement("li");
                        F.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), F.addClass(e, "save-row");
                        var i = document.createElement("span");
                        i.innerHTML = "&nbsp;", F.addClass(i, "button gears");
                        var n = document.createElement("span");
                        n.innerHTML = "Save", F.addClass(n, "button"), F.addClass(n, "save");
                        var r = document.createElement("span");
                        r.innerHTML = "New", F.addClass(r, "button"), F.addClass(r, "save-as");
                        var o = document.createElement("span");
                        o.innerHTML = "Revert", F.addClass(o, "button"), F.addClass(o, "revert");
                        var a = t.__preset_select = document.createElement("select");
                        if (t.load && t.load.remembered ? x.each(t.load.remembered, function(e, i) {
                                f(t, i, i === t.preset)
                            }) : f(t, K, !1), F.bind(a, "change", function() {
                                for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                                t.preset = this.value
                            }), e.appendChild(a), e.appendChild(i), e.appendChild(n), e.appendChild(r), e.appendChild(o), Q) {
                            var s = document.getElementById("dg-local-explain"),
                                l = document.getElementById("dg-local-storage");
                            document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(d(0, "isLocal")) && l.setAttribute("checked", "checked"), m(t, s), F.bind(l, "change", function() {
                                t.useLocalStorage = !t.useLocalStorage, m(t, s)
                            })
                        }
                        var h = document.getElementById("dg-new-constructor");
                        F.bind(h, "keydown", function(t) {
                            !t.metaKey || 67 !== t.which && 67 !== t.keyCode || $.hide()
                        }), F.bind(i, "click", function() {
                            h.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), $.show(), h.focus(), h.select()
                        }), F.bind(n, "click", function() {
                            t.save()
                        }), F.bind(r, "click", function() {
                            var e = prompt("Enter a new preset name.");
                            e && t.saveAs(e)
                        }), F.bind(o, "click", function() {
                            t.revert()
                        })
                    }(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
                }), this.autoPlace && v(this, this.width)
            },
            getRoot: function() {
                for (var t = this; t.parent;) t = t.parent;
                return t
            },
            getSaveObject: function() {
                var t = this.load;
                return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = g(this)), t.folders = {}, x.each(this.__folders, function(e, i) {
                    t.folders[i] = e.getSaveObject()
                }), t
            },
            save: function() {
                this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = g(this), c(this, !1), this.saveToLocalStorageIfPossible()
            },
            saveAs: function(t) {
                this.load.remembered || (this.load.remembered = {}, this.load.remembered[K] = g(this, !0)), this.load.remembered[t] = g(this), this.preset = t, f(this, t, !0), this.saveToLocalStorageIfPossible()
            },
            revert: function(t) {
                x.each(this.__controllers, function(e) {
                    this.getRoot().load.remembered ? u(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
                }, this), x.each(this.__folders, function(t) {
                    t.revert(t)
                }), t || c(this.getRoot(), !1)
            },
            listen: function(t) {
                var e = 0 === this.__listening.length;
                this.__listening.push(t), e && function t(e) {
                    0 !== e.length && Z.call(window, function() {
                        t(e)
                    }), x.each(e, function(t) {
                        t.updateDisplay()
                    })
                }(this.__listening)
            },
            updateDisplay: function() {
                x.each(this.__controllers, function(t) {
                    t.updateDisplay()
                }), x.each(this.__folders, function(t) {
                    t.updateDisplay()
                })
            }
        });
        var ot = {
                Color: B,
                math: S,
                interpret: E
            },
            at = {
                Controller: I,
                BooleanController: D,
                OptionController: U,
                StringController: k,
                NumberController: V,
                NumberControllerBox: H,
                NumberControllerSlider: G,
                FunctionController: j,
                ColorController: W
            },
            st = {
                dom: F
            },
            lt = {
                GUI: rt
            },
            ht = rt,
            ct = {
                color: ot,
                controllers: at,
                dom: st,
                gui: lt,
                GUI: ht
            };
        t.color = ot, t.controllers = at, t.dom = st, t.gui = lt, t.GUI = ht, t.default = ct, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }(e)
}, function(t, e) {
    function i() {
        this.data = {
            keys: []
        }
    }
    t.exports = i, i.prototype.get = function(t, e) {
        if (t > e) {
            var i = e;
            e = t, t = i
        }
        return this.data[t + "-" + e]
    }, i.prototype.set = function(t, e, i) {
        if (t > e) {
            var n = e;
            e = t, t = n
        }
        var r = t + "-" + e;
        this.get(t, e) || this.data.keys.push(r), this.data[r] = i
    }, i.prototype.reset = function() {
        for (var t = this.data, e = t.keys; e.length > 0;) delete t[e.pop()]
    }
}, function(t, e, i) {
    t.exports = g, i(8);
    var n = i(1),
        r = i(13),
        o = i(128),
        a = (i(24), i(89), i(132)),
        s = i(90),
        l = i(134),
        h = i(55),
        c = i(129),
        u = i(30),
        p = i(203),
        d = i(54),
        f = i(26),
        m = i(73),
        v = i(126);

    function g(t) {
        t = t || {}, s.apply(this), this.dt = -1, this.allowSleep = !!t.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = void 0 !== t.quatNormalizeSkip ? t.quatNormalizeSkip : 0, this.quatNormalizeFast = void 0 !== t.quatNormalizeFast && t.quatNormalizeFast, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new n, t.gravity && this.gravity.copy(t.gravity), this.broadphase = void 0 !== t.broadphase ? t.broadphase : new v, this.bodies = [], this.solver = void 0 !== t.solver ? t.solver : new o, this.constraints = [], this.narrowphase = new a(this), this.collisionMatrix = new l, this.collisionMatrixPrevious = new l, this.materials = [], this.contactmaterials = [], this.contactMaterialTable = new p, this.defaultMaterial = new h("default"), this.defaultContactMaterial = new c(this.defaultMaterial, this.defaultMaterial, {
            friction: .3,
            restitution: 0
        }), this.doProfiling = !1, this.profile = {
            solve: 0,
            makeContactConstraints: 0,
            broadphase: 0,
            integrate: 0,
            narrowphase: 0
        }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
            type: "addBody",
            body: null
        }, this.removeBodyEvent = {
            type: "removeBody",
            body: null
        }, this.broadphase.setWorld(this)
    }
    g.prototype = new s, new f;
    var y = new m;
    if (g.prototype.getContactMaterial = function(t, e) {
            return this.contactMaterialTable.get(t.id, e.id)
        }, g.prototype.numObjects = function() {
            return this.bodies.length
        }, g.prototype.collisionMatrixTick = function() {
            var t = this.collisionMatrixPrevious;
            this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = t, this.collisionMatrix.reset()
        }, g.prototype.add = g.prototype.addBody = function(t) {
            -1 === this.bodies.indexOf(t) && (t.index = this.bodies.length, this.bodies.push(t), t.world = this, t.initPosition.copy(t.position), t.initVelocity.copy(t.velocity), t.timeLastSleepy = this.time, t instanceof u && (t.initAngularVelocity.copy(t.angularVelocity), t.initQuaternion.copy(t.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = t, this.dispatchEvent(this.addBodyEvent))
        }, g.prototype.addConstraint = function(t) {
            this.constraints.push(t)
        }, g.prototype.removeConstraint = function(t) {
            var e = this.constraints.indexOf(t); - 1 !== e && this.constraints.splice(e, 1)
        }, g.prototype.rayTest = function(t, e, i) {
            i instanceof d ? this.raycastClosest(t, e, {
                skipBackfaces: !0
            }, i) : this.raycastAll(t, e, {
                skipBackfaces: !0
            }, i)
        }, g.prototype.raycastAll = function(t, e, i, n) {
            return i.mode = m.ALL, i.from = t, i.to = e, i.callback = n, y.intersectWorld(this, i)
        }, g.prototype.raycastAny = function(t, e, i, n) {
            return i.mode = m.ANY, i.from = t, i.to = e, i.result = n, y.intersectWorld(this, i)
        }, g.prototype.raycastClosest = function(t, e, i, n) {
            return i.mode = m.CLOSEST, i.from = t, i.to = e, i.result = n, y.intersectWorld(this, i)
        }, g.prototype.remove = function(t) {
            t.world = null;
            var e = this.bodies.length - 1,
                i = this.bodies,
                n = i.indexOf(t);
            if (-1 !== n) {
                i.splice(n, 1);
                for (var r = 0; r !== i.length; r++) i[r].index = r;
                this.collisionMatrix.setNumObjects(e), this.removeBodyEvent.body = t, this.dispatchEvent(this.removeBodyEvent)
            }
        }, g.prototype.removeBody = g.prototype.remove, g.prototype.addMaterial = function(t) {
            this.materials.push(t)
        }, g.prototype.addContactMaterial = function(t) {
            this.contactmaterials.push(t), this.contactMaterialTable.set(t.materials[0].id, t.materials[1].id, t)
        }, "undefined" == typeof performance && (performance = {}), !performance.now) {
        var _ = Date.now();
        performance.timing && performance.timing.navigationStart && (_ = performance.timing.navigationStart), performance.now = function() {
            return Date.now() - _
        }
    }
    new n, g.prototype.step = function(t, e, i) {
        if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
        else {
            this.accumulator += e;
            for (var n = 0; this.accumulator >= t && n < i;) this.internalStep(t), this.accumulator -= t, n++;
            for (var r = this.accumulator % t / t, o = 0; o !== this.bodies.length; o++) {
                var a = this.bodies[o];
                a.previousPosition.lerp(a.position, r, a.interpolatedPosition), a.previousQuaternion.slerp(a.quaternion, r, a.interpolatedQuaternion), a.previousQuaternion.normalize()
            }
            this.time += e
        }
    };
    var x = {
            type: "postStep"
        },
        b = {
            type: "preStep"
        },
        w = {
            type: u.COLLIDE_EVENT_NAME,
            body: null,
            contact: null
        },
        T = [],
        E = [],
        M = [],
        S = [];
    new n, new n, new n, new n, new n, new n, new n, new n, new n, new r, new r, new r, new n, g.prototype.internalStep = function(t) {
        this.dt = t;
        var e, i = this.contacts,
            n = M,
            r = S,
            o = this.numObjects(),
            a = this.bodies,
            s = this.solver,
            l = this.gravity,
            h = this.doProfiling,
            c = this.profile,
            p = u.DYNAMIC,
            d = this.constraints,
            f = E,
            m = (l.norm(), l.x),
            v = l.y,
            g = l.z,
            y = 0;
        for (h && (e = performance.now()), y = 0; y !== o; y++)
            if ((z = a[y]).type === p) {
                var _ = z.force,
                    A = z.mass;
                _.x += A * m, _.y += A * v, _.z += A * g
            }
        y = 0;
        for (var C = this.subsystems.length; y !== C; y++) this.subsystems[y].update();
        h && (e = performance.now()), n.length = 0, r.length = 0, this.broadphase.collisionPairs(this, n, r), h && (c.broadphase = performance.now() - e);
        var R = d.length;
        for (y = 0; y !== R; y++)
            if (!(D = d[y]).collideConnected)
                for (var P = n.length - 1; P >= 0; P -= 1)(D.bodyA === n[P] && D.bodyB === r[P] || D.bodyB === n[P] && D.bodyA === r[P]) && (n.splice(P, 1), r.splice(P, 1));
        this.collisionMatrixTick(), h && (e = performance.now());
        var L = T,
            O = i.length;
        for (y = 0; y !== O; y++) L.push(i[y]);
        i.length = 0;
        var B = this.frictionEquations.length;
        for (y = 0; y !== B; y++) f.push(this.frictionEquations[y]);
        for (this.frictionEquations.length = 0, this.narrowphase.getContacts(n, r, this, i, L, this.frictionEquations, f), h && (c.narrowphase = performance.now() - e), h && (e = performance.now()), y = 0; y < this.frictionEquations.length; y++) s.addEquation(this.frictionEquations[y]);
        for (var I = i.length, N = 0; N !== I; N++) {
            var z = (D = i[N]).bi,
                F = D.bj;
            D.si, D.sj, (z.material && F.material && this.getContactMaterial(z.material, F.material) || this.defaultContactMaterial).friction, z.material && F.material && (z.material.friction >= 0 && F.material.friction >= 0 && (z.material.friction, F.material.friction), z.material.restitution >= 0 && F.material.restitution >= 0 && (D.restitution = z.material.restitution * F.material.restitution)), s.addEquation(D), z.allowSleep && z.type === u.DYNAMIC && z.sleepState === u.SLEEPING && F.sleepState === u.AWAKE && F.type !== u.STATIC && F.velocity.norm2() + F.angularVelocity.norm2() >= 2 * Math.pow(F.sleepSpeedLimit, 2) && (z._wakeUpAfterNarrowphase = !0), F.allowSleep && F.type === u.DYNAMIC && F.sleepState === u.SLEEPING && z.sleepState === u.AWAKE && z.type !== u.STATIC && z.velocity.norm2() + z.angularVelocity.norm2() >= 2 * Math.pow(z.sleepSpeedLimit, 2) && (F._wakeUpAfterNarrowphase = !0), this.collisionMatrix.set(z, F, !0), this.collisionMatrixPrevious.get(z, F) || (w.body = F, w.contact = D, z.dispatchEvent(w), w.body = z, F.dispatchEvent(w))
        }
        for (h && (c.makeContactConstraints = performance.now() - e, e = performance.now()), y = 0; y !== o; y++)(z = a[y])._wakeUpAfterNarrowphase && (z.wakeUp(), z._wakeUpAfterNarrowphase = !1);
        for (R = d.length, y = 0; y !== R; y++) {
            var D;
            (D = d[y]).update(), P = 0;
            for (var U = D.equations.length; P !== U; P++) {
                var k = D.equations[P];
                s.addEquation(k)
            }
        }
        s.solve(t, this), h && (c.solve = performance.now() - e), s.removeAllEquations();
        var V = Math.pow;
        for (y = 0; y !== o; y++)
            if ((z = a[y]).type & p) {
                var H = V(1 - z.linearDamping, t),
                    G = z.velocity;
                G.mult(H, G);
                var j = z.angularVelocity;
                if (j) {
                    var W = V(1 - z.angularDamping, t);
                    j.mult(W, j)
                }
            }
        for (this.dispatchEvent(b), y = 0; y !== o; y++)(z = a[y]).preStep && z.preStep.call(z);
        h && (e = performance.now());
        var q = this.stepnumber % (this.quatNormalizeSkip + 1) == 0,
            X = this.quatNormalizeFast;
        for (y = 0; y !== o; y++) a[y].integrate(t, q, X);
        for (this.clearForces(), this.broadphase.dirty = !0, h && (c.integrate = performance.now() - e), this.time += t, this.stepnumber += 1, this.dispatchEvent(x), y = 0; y !== o; y++) {
            var Y = (z = a[y]).postStep;
            Y && Y.call(z)
        }
        if (this.allowSleep)
            for (y = 0; y !== o; y++) a[y].sleepTick(this.time)
    }, g.prototype.clearForces = function() {
        for (var t = this.bodies, e = t.length, i = 0; i !== e; i++) {
            var n = t[i];
            n.force, n.torque, n.force.set(0, 0, 0), n.torque.set(0, 0, 0)
        }
    }
}, function(t, e, i) {
    var n = i(26),
        r = i(1);

    function o(t) {
        t = t || {}, this.root = t.root || null, this.aabb = t.aabb ? t.aabb.clone() : new n, this.data = [], this.children = []
    }

    function a(t, e) {
        (e = e || {}).root = null, e.aabb = t, o.call(this, e), this.maxDepth = void 0 !== e.maxDepth ? e.maxDepth : 8
    }
    t.exports = a, a.prototype = new o, o.prototype.reset = function(t, e) {
        this.children.length = this.data.length = 0
    }, o.prototype.insert = function(t, e, i) {
        var n = this.data;
        if (i = i || 0, !this.aabb.contains(t)) return !1;
        var r = this.children;
        if (i < (this.maxDepth || this.root.maxDepth)) {
            var o = !1;
            r.length || (this.subdivide(), o = !0);
            for (var a = 0; 8 !== a; a++)
                if (r[a].insert(t, e, i + 1)) return !0;
            o && (r.length = 0)
        }
        return n.push(e), !0
    };
    var s = new r;
    o.prototype.subdivide = function() {
        var t = this.aabb,
            e = t.lowerBound,
            i = t.upperBound,
            a = this.children;
        a.push(new o({
            aabb: new n({
                lowerBound: new r(0, 0, 0)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(1, 0, 0)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(1, 1, 0)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(1, 1, 1)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(0, 1, 1)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(0, 0, 1)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(1, 0, 1)
            })
        }), new o({
            aabb: new n({
                lowerBound: new r(0, 1, 0)
            })
        })), i.vsub(e, s), s.scale(.5, s);
        for (var l = this.root || this, h = 0; 8 !== h; h++) {
            var c = a[h];
            c.root = l;
            var u = c.aabb.lowerBound;
            u.x *= s.x, u.y *= s.y, u.z *= s.z, u.vadd(e, u), u.vadd(s, c.aabb.upperBound)
        }
    }, o.prototype.aabbQuery = function(t, e) {
        this.data, this.children;
        for (var i = [this]; i.length;) {
            var n = i.pop();
            n.aabb.overlaps(t) && Array.prototype.push.apply(e, n.data), Array.prototype.push.apply(i, n.children)
        }
        return e
    };
    var l = new n;
    o.prototype.rayQuery = function(t, e, i) {
        return t.getAABB(l), l.toLocalFrame(e, l), this.aabbQuery(l, i), i
    }, o.prototype.removeEmptyNodes = function() {
        for (var t = [this]; t.length;) {
            for (var e = t.pop(), i = e.children.length - 1; i >= 0; i--) e.children[i].data.length || e.children.splice(i, 1);
            Array.prototype.push.apply(t, e.children)
        }
    }
}, function(t, e, i) {
    t.exports = l;
    var n = i(8),
        r = i(1),
        o = (i(13), i(41)),
        a = i(26),
        s = i(205);

    function l(t, e) {
        n.call(this, {
            type: n.types.TRIMESH
        }), this.vertices = new Float32Array(t), this.indices = new Int16Array(e), this.normals = new Float32Array(e.length), this.aabb = new a, this.edges = null, this.scale = new r(1, 1, 1), this.tree = new s, this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), this.updateTree()
    }
    l.prototype = new n, l.prototype.constructor = l;
    var h = new r;
    l.prototype.updateTree = function() {
        var t = this.tree;
        t.reset(), t.aabb.copy(this.aabb);
        var e = this.scale;
        t.aabb.lowerBound.x *= 1 / e.x, t.aabb.lowerBound.y *= 1 / e.y, t.aabb.lowerBound.z *= 1 / e.z, t.aabb.upperBound.x *= 1 / e.x, t.aabb.upperBound.y *= 1 / e.y, t.aabb.upperBound.z *= 1 / e.z;
        for (var i = new a, n = new r, o = new r, s = new r, l = [n, o, s], h = 0; h < this.indices.length / 3; h++) {
            var c = 3 * h;
            this._getUnscaledVertex(this.indices[c], n), this._getUnscaledVertex(this.indices[c + 1], o), this._getUnscaledVertex(this.indices[c + 2], s), i.setFromPoints(l), t.insert(i, h)
        }
        t.removeEmptyNodes()
    };
    var c = new a;
    l.prototype.getTrianglesInAABB = function(t, e) {
        c.copy(t);
        var i = this.scale,
            n = i.x,
            r = i.y,
            o = i.z,
            a = c.lowerBound,
            s = c.upperBound;
        return a.x /= n, a.y /= r, a.z /= o, s.x /= n, s.y /= r, s.z /= o, this.tree.aabbQuery(c, e)
    }, l.prototype.setScale = function(t) {
        var e = this.scale.x === this.scale.y === this.scale.z,
            i = t.x === t.y === t.z;
        e && i || this.updateNormals(), this.scale.copy(t), this.updateAABB(), this.updateBoundingSphereRadius()
    }, l.prototype.updateNormals = function() {
        for (var t = h, e = this.normals, i = 0; i < this.indices.length / 3; i++) {
            var n = 3 * i,
                r = this.indices[n],
                o = this.indices[n + 1],
                a = this.indices[n + 2];
            this.getVertex(r, m), this.getVertex(o, v), this.getVertex(a, g), l.computeNormal(v, m, g, t), e[n] = t.x, e[n + 1] = t.y, e[n + 2] = t.z
        }
    }, l.prototype.updateEdges = function() {
        for (var t = {}, e = function(e, i) {
                t[r < o ? r + "_" + o : o + "_" + r] = !0
            }, i = 0; i < this.indices.length / 3; i++) {
            var n = 3 * i,
                r = this.indices[n],
                o = this.indices[n + 1];
            this.indices[n + 2], e(), e(), e()
        }
        var a = Object.keys(t);
        for (this.edges = new Int16Array(2 * a.length), i = 0; i < a.length; i++) {
            var s = a[i].split("_");
            this.edges[2 * i] = parseInt(s[0], 10), this.edges[2 * i + 1] = parseInt(s[1], 10)
        }
    }, l.prototype.getEdgeVertex = function(t, e, i) {
        var n = this.edges[2 * t + (e ? 1 : 0)];
        this.getVertex(n, i)
    };
    var u = new r,
        p = new r;
    l.prototype.getEdgeVector = function(t, e) {
        var i = u,
            n = p;
        this.getEdgeVertex(t, 0, i), this.getEdgeVertex(t, 1, n), n.vsub(i, e)
    };
    var d = new r,
        f = new r;
    l.computeNormal = function(t, e, i, n) {
        e.vsub(t, f), i.vsub(e, d), d.cross(f, n), n.isZero() || n.normalize()
    };
    var m = new r,
        v = new r,
        g = new r;
    l.prototype.getVertex = function(t, e) {
        var i = this.scale;
        return this._getUnscaledVertex(t, e), e.x *= i.x, e.y *= i.y, e.z *= i.z, e
    }, l.prototype._getUnscaledVertex = function(t, e) {
        var i = 3 * t,
            n = this.vertices;
        return e.set(n[i], n[i + 1], n[i + 2])
    }, l.prototype.getWorldVertex = function(t, e, i, n) {
        return this.getVertex(t, n), o.pointToWorldFrame(e, i, n, n), n
    }, l.prototype.getTriangleVertices = function(t, e, i, n) {
        var r = 3 * t;
        this.getVertex(this.indices[r], e), this.getVertex(this.indices[r + 1], i), this.getVertex(this.indices[r + 2], n)
    }, l.prototype.getNormal = function(t, e) {
        var i = 3 * t;
        return e.set(this.normals[i], this.normals[i + 1], this.normals[i + 2])
    };
    var y = new a;
    l.prototype.calculateLocalInertia = function(t, e) {
        this.computeLocalAABB(y);
        var i = y.upperBound.x - y.lowerBound.x,
            n = y.upperBound.y - y.lowerBound.y,
            r = y.upperBound.z - y.lowerBound.z;
        return e.set(1 / 12 * t * (2 * n * 2 * n + 2 * r * 2 * r), 1 / 12 * t * (2 * i * 2 * i + 2 * r * 2 * r), 1 / 12 * t * (2 * n * 2 * n + 2 * i * 2 * i))
    };
    var _ = new r;
    l.prototype.computeLocalAABB = function(t) {
        var e = t.lowerBound,
            i = t.upperBound,
            n = this.vertices.length,
            r = (this.vertices, _);
        this.getVertex(0, r), e.copy(r), i.copy(r);
        for (var o = 0; o !== n; o++) this.getVertex(o, r), r.x < e.x ? e.x = r.x : r.x > i.x && (i.x = r.x), r.y < e.y ? e.y = r.y : r.y > i.y && (i.y = r.y), r.z < e.z ? e.z = r.z : r.z > i.z && (i.z = r.z)
    }, l.prototype.updateAABB = function() {
        this.computeLocalAABB(this.aabb)
    }, l.prototype.updateBoundingSphereRadius = function() {
        for (var t = 0, e = this.vertices, i = new r, n = 0, o = e.length / 3; n !== o; n++) {
            this.getVertex(n, i);
            var a = i.norm2();
            a > t && (t = a)
        }
        this.boundingSphereRadius = Math.sqrt(t)
    }, new r;
    var x = new o,
        b = new a;
    l.prototype.calculateWorldAABB = function(t, e, i, n) {
        var r = x,
            o = b;
        r.position = t, r.quaternion = e, this.aabb.toWorldFrame(r, o), i.copy(o.lowerBound), n.copy(o.upperBound)
    }, l.prototype.volume = function() {
        return 4 * Math.PI * this.boundingSphereRadius / 3
    }, l.createTorus = function(t, e, i, n, r) {
        t = t || 1, e = e || .5, i = i || 8, n = n || 6, r = r || 2 * Math.PI;
        for (var o = [], a = [], s = 0; s <= i; s++)
            for (var h = 0; h <= n; h++) {
                var c = h / n * r,
                    u = s / i * Math.PI * 2,
                    p = (t + e * Math.cos(u)) * Math.cos(c),
                    d = (t + e * Math.cos(u)) * Math.sin(c),
                    f = e * Math.sin(u);
                o.push(p, d, f)
            }
        for (s = 1; s <= i; s++)
            for (h = 1; h <= n; h++) {
                var m = (n + 1) * s + h - 1,
                    v = (n + 1) * (s - 1) + h - 1,
                    g = (n + 1) * (s - 1) + h,
                    y = (n + 1) * s + h;
                a.push(m, v, y), a.push(v, g, y)
            }
        return new l(o, a)
    }
}, function(t, e, i) {
    var n = i(1);

    function r(t, e, i) {
        i = i || {}, this.restLength = "number" == typeof i.restLength ? i.restLength : 1, this.stiffness = i.stiffness || 100, this.damping = i.damping || 1, this.bodyA = t, this.bodyB = e, this.localAnchorA = new n, this.localAnchorB = new n, i.localAnchorA && this.localAnchorA.copy(i.localAnchorA), i.localAnchorB && this.localAnchorB.copy(i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB)
    }
    t.exports = r, r.prototype.setWorldAnchorA = function(t) {
        this.bodyA.pointToLocalFrame(t, this.localAnchorA)
    }, r.prototype.setWorldAnchorB = function(t) {
        this.bodyB.pointToLocalFrame(t, this.localAnchorB)
    }, r.prototype.getWorldAnchorA = function(t) {
        this.bodyA.pointToWorldFrame(this.localAnchorA, t)
    }, r.prototype.getWorldAnchorB = function(t) {
        this.bodyB.pointToWorldFrame(this.localAnchorB, t)
    };
    var o = new n,
        a = new n,
        s = new n,
        l = new n,
        h = new n,
        c = new n,
        u = new n,
        p = new n,
        d = new n,
        f = new n,
        m = new n;
    r.prototype.applyForce = function() {
        var t = this.stiffness,
            e = this.damping,
            i = this.restLength,
            n = this.bodyA,
            r = this.bodyB,
            v = o,
            g = a,
            y = s,
            _ = l,
            x = m,
            b = h,
            w = c,
            T = u,
            E = p,
            M = d,
            S = f;
        this.getWorldAnchorA(b), this.getWorldAnchorB(w), b.vsub(n.position, T), w.vsub(r.position, E), w.vsub(b, v);
        var A = v.norm();
        g.copy(v), g.normalize(), r.velocity.vsub(n.velocity, y), r.angularVelocity.cross(E, x), y.vadd(x, y), n.angularVelocity.cross(T, x), y.vsub(x, y), g.mult(-t * (A - i) - e * y.dot(g), _), n.force.vsub(_, n.force), r.force.vadd(_, r.force), T.cross(_, M), E.cross(_, S), n.torque.vsub(M, n.torque), r.torque.vadd(S, r.torque)
    }
}, function(t, e, i) {
    t.exports = o, i(1), i(13);
    var n = i(72),
        r = i(30);

    function o(t) {
        for (n.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = t, this.nodes = [], this.nodePool = []; this.nodePool.length < 128;) this.nodePool.push(this.createNode())
    }
    o.prototype = new n;
    var a = [],
        s = [],
        l = {
            bodies: []
        },
        h = r.STATIC;

    function c(t) {
        for (var e = t.length, i = 0; i !== e; i++) {
            var n = t[i];
            if (!(n.visited || n.body.type & h)) return n
        }
        return !1
    }
    var u = [];

    function p(t, e, i, n) {
        for (u.push(t), t.visited = !0, e(t, i, n); u.length;)
            for (var r, o = u.pop(); r = c(o.children);) r.visited = !0, e(r, i, n), u.push(r)
    }

    function d(t, e, i) {
        e.push(t.body);
        for (var n = t.eqs.length, r = 0; r !== n; r++) {
            var o = t.eqs[r]; - 1 === i.indexOf(o) && i.push(o)
        }
    }

    function f(t, e) {
        return e.id - t.id
    }
    o.prototype.createNode = function() {
        return {
            body: null,
            children: [],
            eqs: [],
            visited: !1
        }
    }, o.prototype.solve = function(t, e) {
        for (var i = a, n = this.nodePool, r = e.bodies, o = this.equations, h = o.length, u = r.length, m = this.subsolver; n.length < u;) n.push(this.createNode());
        i.length = u;
        for (var v = 0; v < u; v++) i[v] = n[v];
        for (v = 0; v !== u; v++) {
            var g = i[v];
            g.body = r[v], g.children.length = 0, g.eqs.length = 0, g.visited = !1
        }
        for (var y = 0; y !== h; y++) {
            var _ = o[y],
                x = (v = r.indexOf(_.bi), r.indexOf(_.bj)),
                b = i[v],
                w = i[x];
            b.children.push(w), b.eqs.push(_), w.children.push(b), w.eqs.push(_)
        }
        var T, E = 0,
            M = s;
        m.tolerance = this.tolerance, m.iterations = this.iterations;
        for (var S = l; T = c(i);) {
            M.length = 0, S.bodies.length = 0, p(T, d, S.bodies, M);
            var A = M.length;
            for (M = M.sort(f), v = 0; v !== A; v++) m.addEquation(M[v]);
            m.solve(t, S), m.removeAllEquations(), E++
        }
        return E
    }
}, function(t, e, i) {
    t.exports = r, i(8);
    var n = i(1);

    function r() {
        this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], this.neighbors = []
    }
    i(13), i(125), i(30), i(55), r.prototype.add = function(t) {
        this.particles.push(t), this.neighbors.length < this.particles.length && this.neighbors.push([])
    }, r.prototype.remove = function(t) {
        var e = this.particles.indexOf(t); - 1 !== e && (this.particles.splice(e, 1), this.neighbors.length > this.particles.length && this.neighbors.pop())
    };
    var o = new n;
    r.prototype.getNeighbors = function(t, e) {
        for (var i = this.particles.length, n = t.id, r = this.smoothingRadius * this.smoothingRadius, a = o, s = 0; s !== i; s++) {
            var l = this.particles[s];
            l.position.vsub(t.position, a), n !== l.id && a.norm2() < r && e.push(l)
        }
    };
    var a = new n,
        s = new n,
        l = new n,
        h = new n,
        c = new n,
        u = new n;
    r.prototype.update = function() {
        for (var t = this.particles.length, e = a, i = this.speedOfSound, n = this.eps, r = 0; r !== t; r++) {
            var o = this.particles[r];
            (E = this.neighbors[r]).length = 0, this.getNeighbors(o, E), E.push(this.particles[r]);
            for (var p = E.length, d = 0, f = 0; f !== p; f++) {
                o.position.vsub(E[f].position, e);
                var m = e.norm(),
                    v = this.w(m);
                d += E[f].mass * v
            }
            this.densities[r] = d, this.pressures[r] = i * i * (this.densities[r] - this.density)
        }
        var g = s,
            y = l,
            _ = h,
            x = c,
            b = u;
        for (r = 0; r !== t; r++) {
            var w, T, E, M = this.particles[r];
            for (g.set(0, 0, 0), y.set(0, 0, 0), p = (E = this.neighbors[r]).length, f = 0; f !== p; f++) {
                var S = E[f];
                M.position.vsub(S.position, x);
                var A = x.norm();
                w = -S.mass * (this.pressures[r] / (this.densities[r] * this.densities[r] + n) + this.pressures[f] / (this.densities[f] * this.densities[f] + n)), this.gradw(x, _), _.mult(w, _), g.vadd(_, g), S.velocity.vsub(M.velocity, b), b.mult(1 / (1e-4 + this.densities[r] * this.densities[f]) * this.viscosity * S.mass, b), T = this.nablaw(A), b.mult(T, b), y.vadd(b, y)
            }
            y.mult(M.mass, y), g.mult(M.mass, g), M.force.vadd(y, M.force), M.force.vadd(g, M.force)
        }
    }, r.prototype.w = function(t) {
        var e = this.smoothingRadius;
        return 315 / (64 * Math.PI * Math.pow(e, 9)) * Math.pow(e * e - t * t, 3)
    }, r.prototype.gradw = function(t, e) {
        var i = t.norm(),
            n = this.smoothingRadius;
        t.mult(945 / (32 * Math.PI * Math.pow(n, 9)) * Math.pow(n * n - i * i, 2), e)
    }, r.prototype.nablaw = function(t) {
        var e = this.smoothingRadius;
        return 945 / (32 * Math.PI * Math.pow(e, 9)) * (e * e - t * t) * (7 * t * t - 3 * e * e)
    }
}, function(t, e, i) {
    i(8);
    var n = i(74);

    function r(t) {
        n.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0;
        var e = this.axisList;
        this._addBodyHandler = function(t) {
            e.push(t.body)
        }, this._removeBodyHandler = function(t) {
            var i = e.indexOf(t.body); - 1 !== i && e.splice(i, 1)
        }, t && this.setWorld(t)
    }
    t.exports = r, r.prototype = new n, r.prototype.setWorld = function(t) {
        this.axisList.length = 0;
        for (var e = 0; e < t.bodies.length; e++) this.axisList.push(t.bodies[e]);
        t.removeEventListener("addBody", this._addBodyHandler), t.removeEventListener("removeBody", this._removeBodyHandler), t.addEventListener("addBody", this._addBodyHandler), t.addEventListener("removeBody", this._removeBodyHandler), this.world = t, this.dirty = !0
    }, r.insertionSortX = function(t) {
        for (var e = 1, i = t.length; e < i; e++) {
            for (var n = t[e], r = e - 1; r >= 0 && !(t[r].aabb.lowerBound.x <= n.aabb.lowerBound.x); r--) t[r + 1] = t[r];
            t[r + 1] = n
        }
        return t
    }, r.insertionSortY = function(t) {
        for (var e = 1, i = t.length; e < i; e++) {
            for (var n = t[e], r = e - 1; r >= 0 && !(t[r].aabb.lowerBound.y <= n.aabb.lowerBound.y); r--) t[r + 1] = t[r];
            t[r + 1] = n
        }
        return t
    }, r.insertionSortZ = function(t) {
        for (var e = 1, i = t.length; e < i; e++) {
            for (var n = t[e], r = e - 1; r >= 0 && !(t[r].aabb.lowerBound.z <= n.aabb.lowerBound.z); r--) t[r + 1] = t[r];
            t[r + 1] = n
        }
        return t
    }, r.prototype.collisionPairs = function(t, e, i) {
        var n, o, a = this.axisList,
            s = a.length,
            l = this.axisIndex;
        for (this.dirty && (this.sortList(), this.dirty = !1), n = 0; n !== s; n++) {
            var h = a[n];
            for (o = n + 1; o < s; o++) {
                var c = a[o];
                if (this.needBroadphaseCollision(h, c)) {
                    if (!r.checkBounds(h, c, l)) break;
                    this.intersectionTest(h, c, e, i)
                }
            }
        }
    }, r.prototype.sortList = function() {
        for (var t = this.axisList, e = this.axisIndex, i = t.length, n = 0; n !== i; n++) {
            var o = t[n];
            o.aabbNeedsUpdate && o.computeAABB()
        }
        0 === e ? r.insertionSortX(t) : 1 === e ? r.insertionSortY(t) : 2 === e && r.insertionSortZ(t)
    }, r.checkBounds = function(t, e, i) {
        var n, r;
        0 === i ? (n = t.position.x, r = e.position.x) : 1 === i ? (n = t.position.y, r = e.position.y) : 2 === i && (n = t.position.z, r = e.position.z);
        var o = t.boundingRadius;
        return r - e.boundingRadius < n + o
    }, r.prototype.autoDetectAxis = function() {
        for (var t = 0, e = 0, i = 0, n = 0, r = 0, o = 0, a = this.axisList, s = a.length, l = 1 / s, h = 0; h !== s; h++) {
            var c = a[h],
                u = c.position.x;
            t += u, e += u * u;
            var p = c.position.y;
            i += p, n += p * p;
            var d = c.position.z;
            r += d, o += d * d
        }
        var f = e - t * t * l,
            m = n - i * i * l,
            v = o - r * r * l;
        this.axisIndex = f > m ? f > v ? 0 : 2 : m > v ? 1 : 2
    }, r.prototype.aabbQuery = function(t, e, i) {
        i = i || [], this.dirty && (this.sortList(), this.dirty = !1);
        var n = this.axisIndex,
            r = "x";
        1 === n && (r = "y"), 2 === n && (r = "z");
        for (var o = this.axisList, a = (e.lowerBound[r], e.upperBound[r], 0); a < o.length; a++) {
            var s = o[a];
            s.aabbNeedsUpdate && s.computeAABB(), s.aabb.overlaps(e) && i.push(s)
        }
        return i
    }
}, function(t, e, i) {
    var n = i(30),
        r = i(124),
        o = i(75),
        a = i(1),
        s = i(127);

    function l(t) {
        if (this.wheelBodies = [], this.coordinateSystem = void 0 === t.coordinateSystem ? new a(1, 2, 3) : t.coordinateSystem.clone(), this.chassisBody = t.chassisBody, !this.chassisBody) {
            var e = new o(new a(5, 2, .5));
            this.chassisBody = new n(1, e)
        }
        this.constraints = [], this.wheelAxes = [], this.wheelForces = []
    }
    t.exports = l, l.prototype.addWheel = function(t) {
        var e = (t = t || {}).body;
        e || (e = new n(1, new r(1.2))), this.wheelBodies.push(e), this.wheelForces.push(0), new a;
        var i = void 0 !== t.position ? t.position.clone() : new a,
            o = new a;
        this.chassisBody.pointToWorldFrame(i, o), e.position.set(o.x, o.y, o.z);
        var l = void 0 !== t.axis ? t.axis.clone() : new a(0, 1, 0);
        this.wheelAxes.push(l);
        var h = new s(this.chassisBody, e, {
            pivotA: i,
            axisA: l,
            pivotB: a.ZERO,
            axisB: l,
            collideConnected: !1
        });
        return this.constraints.push(h), this.wheelBodies.length - 1
    }, l.prototype.setSteeringValue = function(t, e) {
        var i = this.wheelAxes[e],
            n = Math.cos(t),
            r = Math.sin(t),
            o = i.x,
            a = i.y;
        this.constraints[e].axisA.set(n * o - r * a, r * o + n * a, 0)
    }, l.prototype.setMotorSpeed = function(t, e) {
        var i = this.constraints[e];
        i.enableMotor(), i.motorTargetVelocity = t
    }, l.prototype.disableMotor = function(t) {
        this.constraints[t].disableMotor()
    };
    var h = new a;
    l.prototype.setWheelForce = function(t, e) {
        this.wheelForces[e] = t
    }, l.prototype.applyWheelForce = function(t, e) {
        var i = this.wheelAxes[e],
            n = this.wheelBodies[e],
            r = n.torque;
        i.scale(t, h), n.vectorToWorldFrame(h, h), r.vadd(h, r)
    }, l.prototype.addToWorld = function(t) {
        for (var e = this.constraints, i = this.wheelBodies.concat([this.chassisBody]), n = 0; n < i.length; n++) t.addBody(i[n]);
        for (n = 0; n < e.length; n++) t.addConstraint(e[n]);
        t.addEventListener("preStep", this._update.bind(this))
    }, l.prototype._update = function() {
        for (var t = this.wheelForces, e = 0; e < t.length; e++) this.applyWheelForce(t[e], e)
    }, l.prototype.removeFromWorld = function(t) {
        for (var e = this.constraints, i = this.wheelBodies.concat([this.chassisBody]), n = 0; n < i.length; n++) t.remove(i[n]);
        for (n = 0; n < e.length; n++) t.removeConstraint(e[n])
    };
    var c = new a;
    l.prototype.getWheelSpeed = function(t) {
        var e = this.wheelAxes[t],
            i = this.wheelBodies[t].angularVelocity;
        return this.chassisBody.vectorToWorldFrame(e, c), i.dot(c)
    }
}, function(t, e, i) {
    var n = i(1),
        r = i(41),
        o = i(54),
        a = i(56);

    function s(t) {
        t = a.defaults(t, {
            chassisConnectionPointLocal: new n,
            chassisConnectionPointWorld: new n,
            directionLocal: new n,
            directionWorld: new n,
            axleLocal: new n,
            axleWorld: new n,
            suspensionRestLength: 1,
            suspensionMaxLength: 2,
            radius: 1,
            suspensionStiffness: 100,
            dampingCompression: 10,
            dampingRelaxation: 10,
            frictionSlip: 1e4,
            steering: 0,
            rotation: 0,
            deltaRotation: 0,
            rollInfluence: .01,
            maxSuspensionForce: Number.MAX_VALUE,
            isFrontWheel: !0,
            clippedInvContactDotSuspension: 1,
            suspensionRelativeVelocity: 0,
            suspensionForce: 0,
            skidInfo: 0,
            suspensionLength: 0,
            maxSuspensionTravel: 1,
            useCustomSlidingRotationalSpeed: !1,
            customSlidingRotationalSpeed: -.1
        }), this.maxSuspensionTravel = t.maxSuspensionTravel, this.customSlidingRotationalSpeed = t.customSlidingRotationalSpeed, this.useCustomSlidingRotationalSpeed = t.useCustomSlidingRotationalSpeed, this.sliding = !1, this.chassisConnectionPointLocal = t.chassisConnectionPointLocal.clone(), this.chassisConnectionPointWorld = t.chassisConnectionPointWorld.clone(), this.directionLocal = t.directionLocal.clone(), this.directionWorld = t.directionWorld.clone(), this.axleLocal = t.axleLocal.clone(), this.axleWorld = t.axleWorld.clone(), this.suspensionRestLength = t.suspensionRestLength, this.suspensionMaxLength = t.suspensionMaxLength, this.radius = t.radius, this.suspensionStiffness = t.suspensionStiffness, this.dampingCompression = t.dampingCompression, this.dampingRelaxation = t.dampingRelaxation, this.frictionSlip = t.frictionSlip, this.steering = 0, this.rotation = 0, this.deltaRotation = 0, this.rollInfluence = t.rollInfluence, this.maxSuspensionForce = t.maxSuspensionForce, this.engineForce = 0, this.brake = 0, this.isFrontWheel = t.isFrontWheel, this.clippedInvContactDotSuspension = 1, this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, this.skidInfo = 0, this.suspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, this.raycastResult = new o, this.worldTransform = new r, this.isInContact = !1
    }
    t.exports = s;
    var l = new n,
        h = new n;
    l = new n, s.prototype.updateWheel = function(t) {
        var e = this.raycastResult;
        if (this.isInContact) {
            var i = e.hitNormalWorld.dot(e.directionWorld);
            e.hitPointWorld.vsub(t.position, h), t.getVelocityAtWorldPoint(h, l);
            var n = e.hitNormalWorld.dot(l);
            if (i >= -.1) this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10;
            else {
                var r = -1 / i;
                this.suspensionRelativeVelocity = n * r, this.clippedInvContactDotSuspension = r
            }
        } else e.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, e.directionWorld.scale(-1, e.hitNormalWorld), this.clippedInvContactDotSuspension = 1
    }
}, function(t, e, i) {
    i(30);
    var n = i(1),
        r = i(13),
        o = (i(54), i(73)),
        a = i(212);

    function s(t) {
        this.chassisBody = t.chassisBody, this.wheelInfos = [], this.sliding = !1, this.world = null, this.indexRightAxis = void 0 !== t.indexRightAxis ? t.indexRightAxis : 1, this.indexForwardAxis = void 0 !== t.indexForwardAxis ? t.indexForwardAxis : 0, this.indexUpAxis = void 0 !== t.indexUpAxis ? t.indexUpAxis : 2
    }
    t.exports = s, new n, new n, new n;
    var l = new n,
        h = new n,
        c = new n;
    new o, s.prototype.addWheel = function(t) {
        var e = new a(t = t || {}),
            i = this.wheelInfos.length;
        return this.wheelInfos.push(e), i
    }, s.prototype.setSteeringValue = function(t, e) {
        this.wheelInfos[e].steering = t
    }, new n, s.prototype.applyEngineForce = function(t, e) {
        this.wheelInfos[e].engineForce = t
    }, s.prototype.setBrake = function(t, e) {
        this.wheelInfos[e].brake = t
    }, s.prototype.addToWorld = function(t) {
        this.constraints, t.addBody(this.chassisBody);
        var e = this;
        this.preStepCallback = function() {
            e.updateVehicle(t.dt)
        }, t.addEventListener("preStep", this.preStepCallback), this.world = t
    }, s.prototype.getVehicleAxisWorld = function(t, e) {
        e.set(0 === t ? 1 : 0, 1 === t ? 1 : 0, 2 === t ? 1 : 0), this.chassisBody.vectorToWorldFrame(e, e)
    }, s.prototype.updateVehicle = function(t) {
        for (var e = this.wheelInfos, i = e.length, r = this.chassisBody, o = 0; o < i; o++) this.updateWheelTransform(o);
        this.currentVehicleSpeedKmHour = 3.6 * r.velocity.norm();
        var a = new n;
        for (this.getVehicleAxisWorld(this.indexForwardAxis, a), a.dot(r.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1), o = 0; o < i; o++) this.castRay(e[o]);
        this.updateSuspension(t);
        var s = new n,
            l = new n;
        for (o = 0; o < i; o++) {
            var h = (d = e[o]).suspensionForce;
            h > d.maxSuspensionForce && (h = d.maxSuspensionForce), d.raycastResult.hitNormalWorld.scale(h * t, s), d.raycastResult.hitPointWorld.vsub(r.position, l), r.applyImpulse(s, l)
        }
        this.updateFriction(t);
        var c = new n,
            u = new n,
            p = new n;
        for (o = 0; o < i; o++) {
            var d = e[o];
            r.getVelocityAtWorldPoint(d.chassisConnectionPointWorld, p);
            var f = 1;
            switch (this.indexUpAxis) {
                case 1:
                    f = -1
            }
            if (d.isInContact) {
                this.getVehicleAxisWorld(this.indexForwardAxis, u);
                var m = u.dot(d.raycastResult.hitNormalWorld);
                d.raycastResult.hitNormalWorld.scale(m, c), u.vsub(c, u);
                var v = u.dot(p);
                d.deltaRotation = f * v * t / d.radius
            }!d.sliding && d.isInContact || 0 === d.engineForce || !d.useCustomSlidingRotationalSpeed || (d.deltaRotation = (d.engineForce > 0 ? 1 : -1) * d.customSlidingRotationalSpeed * t), Math.abs(d.brake) > Math.abs(d.engineForce) && (d.deltaRotation = 0), d.rotation += d.deltaRotation, d.deltaRotation *= .99
        }
    }, s.prototype.updateSuspension = function(t) {
        for (var e = this.chassisBody.mass, i = this.wheelInfos, n = i.length, r = 0; r < n; r++) {
            var o = i[r];
            if (o.isInContact) {
                var a, s = o.suspensionRestLength - o.suspensionLength;
                a = o.suspensionStiffness * s * o.clippedInvContactDotSuspension;
                var l = o.suspensionRelativeVelocity;
                a -= (l < 0 ? o.dampingCompression : o.dampingRelaxation) * l, o.suspensionForce = a * e, o.suspensionForce < 0 && (o.suspensionForce = 0)
            } else o.suspensionForce = 0
        }
    }, s.prototype.removeFromWorld = function(t) {
        this.constraints, t.remove(this.chassisBody), t.removeEventListener("preStep", this.preStepCallback), this.world = null
    };
    var u = new n,
        p = new n;
    s.prototype.castRay = function(t) {
        var e = u,
            i = p;
        this.updateWheelTransformWorld(t);
        var r = this.chassisBody,
            o = -1,
            a = t.suspensionRestLength + t.radius;
        t.directionWorld.scale(a, e);
        var s = t.chassisConnectionPointWorld;
        s.vadd(e, i);
        var l = t.raycastResult;
        l.reset();
        var h = r.collisionResponse;
        r.collisionResponse = !1, this.world.rayTest(s, i, l), r.collisionResponse = h;
        var c = l.body;
        if (t.raycastResult.groundObject = 0, c) {
            o = l.distance, t.raycastResult.hitNormalWorld = l.hitNormalWorld, t.isInContact = !0;
            var d = l.distance;
            t.suspensionLength = d - t.radius;
            var f = t.suspensionRestLength - t.maxSuspensionTravel,
                m = t.suspensionRestLength + t.maxSuspensionTravel;
            t.suspensionLength < f && (t.suspensionLength = f), t.suspensionLength > m && (t.suspensionLength = m, t.raycastResult.reset());
            var v = t.raycastResult.hitNormalWorld.dot(t.directionWorld),
                g = new n;
            r.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld, g);
            var y = t.raycastResult.hitNormalWorld.dot(g);
            if (v >= -.1) t.suspensionRelativeVelocity = 0, t.clippedInvContactDotSuspension = 10;
            else {
                var _ = -1 / v;
                t.suspensionRelativeVelocity = y * _, t.clippedInvContactDotSuspension = _
            }
        } else t.suspensionLength = t.suspensionRestLength + 0 * t.maxSuspensionTravel, t.suspensionRelativeVelocity = 0, t.directionWorld.scale(-1, t.raycastResult.hitNormalWorld), t.clippedInvContactDotSuspension = 1;
        return o
    }, s.prototype.updateWheelTransformWorld = function(t) {
        t.isInContact = !1;
        var e = this.chassisBody;
        e.pointToWorldFrame(t.chassisConnectionPointLocal, t.chassisConnectionPointWorld), e.vectorToWorldFrame(t.directionLocal, t.directionWorld), e.vectorToWorldFrame(t.axleLocal, t.axleWorld)
    }, s.prototype.updateWheelTransform = function(t) {
        var e = l,
            i = h,
            n = c,
            o = this.wheelInfos[t];
        this.updateWheelTransformWorld(o), o.directionLocal.scale(-1, e), i.copy(o.axleLocal), e.cross(i, n), n.normalize(), i.normalize();
        var a = o.steering,
            s = new r;
        s.setFromAxisAngle(e, a);
        var u = new r;
        u.setFromAxisAngle(i, o.rotation);
        var p = o.worldTransform.quaternion;
        this.chassisBody.quaternion.mult(s, p), p.mult(u, p), p.normalize();
        var d = o.worldTransform.position;
        d.copy(o.directionWorld), d.scale(o.suspensionLength, d), d.vadd(o.chassisConnectionPointWorld, d)
    };
    var d = [new n(1, 0, 0), new n(0, 1, 0), new n(0, 0, 1)];
    s.prototype.getWheelTransformWorld = function(t) {
        return this.wheelInfos[t].worldTransform
    };
    var f = new n,
        m = [],
        v = [];
    s.prototype.updateFriction = function(t) {
        for (var e = f, i = this.wheelInfos, r = i.length, o = this.chassisBody, a = v, s = m, l = 0; l < r; l++) p = (S = i[l]).raycastResult.body, S.sideImpulse = 0, S.forwardImpulse = 0, a[l] || (a[l] = new n), s[l] || (s[l] = new n);
        for (l = 0; l < r; l++)
            if (p = (S = i[l]).raycastResult.body) {
                var h = s[l];
                this.getWheelTransformWorld(l).vectorToWorldFrame(d[this.indexRightAxis], h);
                var c = S.raycastResult.hitNormalWorld,
                    u = h.dot(c);
                c.scale(u, e), h.vsub(e, h), h.normalize(), c.cross(h, a[l]), a[l].normalize(), S.sideImpulse = R(o, S.raycastResult.hitPointWorld, p, S.raycastResult.hitPointWorld, h), S.sideImpulse *= 1
            }
        for (this.sliding = !1, l = 0; l < r; l++) {
            var p = (S = i[l]).raycastResult.body,
                g = 0;
            if (S.slipInfo = 1, p) {
                var y = S.brake ? S.brake : 0;
                g = x(o, p, S.raycastResult.hitPointWorld, a[l], y);
                var _ = y / (g += S.engineForce * t);
                S.slipInfo *= _
            }
            if (S.forwardImpulse = 0, S.skidInfo = 1, p) {
                S.skidInfo = 1;
                var b = S.suspensionForce * t * S.frictionSlip,
                    w = b * b;
                S.forwardImpulse = g;
                var T = .5 * S.forwardImpulse,
                    E = 1 * S.sideImpulse,
                    M = T * T + E * E;
                S.sliding = !1, M > w && (this.sliding = !0, S.sliding = !0, _ = b / Math.sqrt(M), S.skidInfo *= _)
            }
        }
        if (this.sliding)
            for (l = 0; l < r; l++) 0 !== (S = i[l]).sideImpulse && S.skidInfo < 1 && (S.forwardImpulse *= S.skidInfo, S.sideImpulse *= S.skidInfo);
        for (l = 0; l < r; l++) {
            var S = i[l],
                A = new n;
            if (S.raycastResult.hitPointWorld.vsub(o.position, A), 0 !== S.forwardImpulse) {
                var C = new n;
                a[l].scale(S.forwardImpulse, C), o.applyImpulse(C, A)
            }
            if (0 !== S.sideImpulse) {
                p = S.raycastResult.body;
                var P = new n;
                S.raycastResult.hitPointWorld.vsub(p.position, P);
                var L = new n;
                s[l].scale(S.sideImpulse, L), o.vectorToLocalFrame(A, A), A["xyz" [this.indexUpAxis]] *= S.rollInfluence, o.vectorToWorldFrame(A, A), o.applyImpulse(L, A), L.scale(-1, L), p.applyImpulse(L, P)
            }
        }
    };
    var g = new n,
        y = new n,
        _ = new n;

    function x(t, e, i, n, r) {
        var o = 0,
            a = i,
            s = g,
            l = y,
            h = _;
        return t.getVelocityAtWorldPoint(a, s), e.getVelocityAtWorldPoint(a, l), s.vsub(l, h), r < (o = -n.dot(h) * (1 / (M(t, i, n) + M(e, i, n)))) && (o = r), o < -r && (o = -r), o
    }
    var b = new n,
        w = new n,
        T = new n,
        E = new n;

    function M(t, e, i) {
        var n = b,
            r = w,
            o = T,
            a = E;
        return e.vsub(t.position, n), n.cross(i, r), t.invInertiaWorld.vmult(r, a), a.cross(n, o), t.invMass + i.dot(o)
    }
    var S = new n,
        A = new n,
        C = new n;

    function R(t, e, i, n, r, o) {
        if (r.norm2() > 1.1) return 0;
        var a = S,
            s = A,
            l = C;
        return t.getVelocityAtWorldPoint(e, a), i.getVelocityAtWorldPoint(n, s), a.vsub(s, l), -.2 * r.dot(l) * (1 / (t.invMass + i.invMass))
    }
}, function(t, e) {
    function i() {
        this.matrix = {}
    }
    t.exports = i, i.prototype.get = function(t, e) {
        if (t = t.id, (e = e.id) > t) {
            var i = e;
            e = t, t = i
        }
        return t + "-" + e in this.matrix
    }, i.prototype.set = function(t, e, i) {
        if (t = t.id, (e = e.id) > t) {
            var n = e;
            e = t, t = n
        }
        i ? this.matrix[t + "-" + e] = !0 : delete this.matrix[t + "-" + e]
    }, i.prototype.reset = function() {
        this.matrix = {}
    }, i.prototype.setNumObjects = function(t) {}
}, function(t, e, i) {
    t.exports = a, i(40);
    var n = i(71),
        r = i(70),
        o = (i(88), i(24), i(1));

    function a(t, e, i) {
        var a = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6,
            s = new o,
            l = new o,
            h = new o;
        t.position.vadd(e.position, h), h.scale(.5, h), e.pointToLocalFrame(h, l), t.pointToLocalFrame(h, s), n.call(this, t, s, e, l, a), this.xA = t.vectorToLocalFrame(o.UNIT_X), this.xB = e.vectorToLocalFrame(o.UNIT_X), this.yA = t.vectorToLocalFrame(o.UNIT_Y), this.yB = e.vectorToLocalFrame(o.UNIT_Y), this.zA = t.vectorToLocalFrame(o.UNIT_Z), this.zB = e.vectorToLocalFrame(o.UNIT_Z);
        var c = this.rotationalEquation1 = new r(t, e, i),
            u = this.rotationalEquation2 = new r(t, e, i),
            p = this.rotationalEquation3 = new r(t, e, i);
        this.equations.push(c, u, p)
    }
    a.prototype = new n, a.constructor = a, new o, new o, a.prototype.update = function() {
        var t = this.bodyA,
            e = this.bodyB,
            i = (this.motorEquation, this.rotationalEquation1),
            r = this.rotationalEquation2,
            o = this.rotationalEquation3;
        n.prototype.update.call(this), t.vectorToWorldFrame(this.xA, i.axisA), e.vectorToWorldFrame(this.yB, i.axisB), t.vectorToWorldFrame(this.yA, r.axisA), e.vectorToWorldFrame(this.zB, r.axisB), t.vectorToWorldFrame(this.zA, o.axisA), e.vectorToWorldFrame(this.xB, o.axisB)
    }
}, function(t, e, i) {
    var n = i(8),
        r = i(42),
        o = i(1),
        a = i(56);

    function s(t, e) {
        e = a.defaults(e, {
            maxValue: null,
            minValue: null,
            elementSize: 1
        }), this.data = t, this.maxValue = e.maxValue, this.minValue = e.minValue, this.elementSize = e.elementSize, null === e.minValue && this.updateMinValue(), null === e.maxValue && this.updateMaxValue(), this.cacheEnabled = !0, n.call(this, {
            type: n.types.HEIGHTFIELD
        }), this.pillarConvex = new r, this.pillarOffset = new o, this.updateBoundingSphereRadius(), this._cachedPillars = {}
    }
    t.exports = s, s.prototype = new n, s.prototype.update = function() {
        this._cachedPillars = {}
    }, s.prototype.updateMinValue = function() {
        for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++)
            for (var n = 0; n !== t[i].length; n++) {
                var r = t[i][n];
                r < e && (e = r)
            }
        this.minValue = e
    }, s.prototype.updateMaxValue = function() {
        for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++)
            for (var n = 0; n !== t[i].length; n++) {
                var r = t[i][n];
                r > e && (e = r)
            }
        this.maxValue = e
    }, s.prototype.setHeightValueAtIndex = function(t, e, i) {
        this.data[t][e] = i, this.clearCachedConvexTrianglePillar(t, e, !1), t > 0 && (this.clearCachedConvexTrianglePillar(t - 1, e, !0), this.clearCachedConvexTrianglePillar(t - 1, e, !1)), e > 0 && (this.clearCachedConvexTrianglePillar(t, e - 1, !0), this.clearCachedConvexTrianglePillar(t, e - 1, !1)), e > 0 && t > 0 && this.clearCachedConvexTrianglePillar(t - 1, e - 1, !0)
    }, s.prototype.getRectMinMax = function(t, e, i, n, r) {
        r = r || [];
        for (var o = this.data, a = this.minValue, s = t; s <= i; s++)
            for (var l = e; l <= n; l++) {
                var h = o[s][l];
                h > a && (a = h)
            }
        r[0] = this.minValue, r[1] = a
    }, s.prototype.getIndexOfPosition = function(t, e, i, n) {
        var r = this.elementSize,
            o = this.data,
            a = Math.floor(t / r),
            s = Math.floor(e / r);
        return i[0] = a, i[1] = s, n && (a < 0 && (a = 0), s < 0 && (s = 0), a >= o.length - 1 && (a = o.length - 1), s >= o[0].length - 1 && (s = o[0].length - 1)), !(a < 0 || s < 0 || a >= o.length - 1 || s >= o[0].length - 1)
    };
    var l = [],
        h = new o,
        c = new o,
        u = new o,
        p = new o;
    s.prototype.getTriangleAt = function(t, e, i, n, r, o) {
        var a = l;
        this.getIndexOfPosition(t, e, a, i);
        var s = a[0],
            h = a[1],
            c = this.data;
        i && (s = Math.min(c.length - 2, Math.max(0, s)), h = Math.min(c[0].length - 2, Math.max(0, h)));
        var u = this.elementSize,
            p = Math.pow(t / u - s, 2) + Math.pow(e / u - h, 2) > Math.pow(t / u - (s + 1), 2) + Math.pow(e / u - (h + 1), 2);
        return this.getTriangle(s, h, p, n, r, o), p
    };
    var d = new o,
        f = new o,
        m = new o,
        v = new o,
        g = new o;
    s.prototype.getNormalAt = function(t, e, i, n) {
        var r = d,
            o = f,
            a = m,
            s = v,
            l = g;
        this.getTriangleAt(t, e, i, r, o, a), o.vsub(r, s), a.vsub(r, l), s.cross(l, n), n.normalize()
    }, s.prototype.getAabbAtIndex = function(t, e, i) {
        var n = this.data,
            r = this.elementSize;
        i.lowerBound.set(t * r, e * r, n[t][e]), i.upperBound.set((t + 1) * r, (e + 1) * r, n[t + 1][e + 1])
    }, s.prototype.getHeightAt = function(t, e, i) {
        var n = this.data,
            r = c,
            o = u,
            a = p,
            s = l;
        this.getIndexOfPosition(t, e, s, i);
        var d = s[0],
            f = s[1];
        i && (d = Math.min(n.length - 2, Math.max(0, d)), f = Math.min(n[0].length - 2, Math.max(0, f)));
        var m = this.getTriangleAt(t, e, i, r, o, a);
        ! function(t, e, i, n, r, o, a, s, l) {
            l.x = ((o - s) * (t - a) + (a - r) * (e - s)) / ((o - s) * (i - a) + (a - r) * (n - s)), l.y = ((s - n) * (t - a) + (i - a) * (e - s)) / ((o - s) * (i - a) + (a - r) * (n - s)), l.z = 1 - l.x - l.y
        }(t, e, r.x, r.y, o.x, o.y, a.x, a.y, h);
        var v = h;
        return m ? n[d + 1][f + 1] * v.x + n[d][f + 1] * v.y + n[d + 1][f] * v.z : n[d][f] * v.x + n[d + 1][f] * v.y + n[d][f + 1] * v.z
    }, s.prototype.getCacheConvexTrianglePillarKey = function(t, e, i) {
        return t + "_" + e + "_" + (i ? 1 : 0)
    }, s.prototype.getCachedConvexTrianglePillar = function(t, e, i) {
        return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)]
    }, s.prototype.setCachedConvexTrianglePillar = function(t, e, i, n, r) {
        this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)] = {
            convex: n,
            offset: r
        }
    }, s.prototype.clearCachedConvexTrianglePillar = function(t, e, i) {
        delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)]
    }, s.prototype.getTriangle = function(t, e, i, n, r, o) {
        var a = this.data,
            s = this.elementSize;
        i ? (n.set((t + 1) * s, (e + 1) * s, a[t + 1][e + 1]), r.set(t * s, (e + 1) * s, a[t][e + 1]), o.set((t + 1) * s, e * s, a[t + 1][e])) : (n.set(t * s, e * s, a[t][e]), r.set((t + 1) * s, e * s, a[t + 1][e]), o.set(t * s, (e + 1) * s, a[t][e + 1]))
    }, s.prototype.getConvexTrianglePillar = function(t, e, i) {
        var n = this.pillarConvex,
            a = this.pillarOffset;
        if (this.cacheEnabled) {
            if (s = this.getCachedConvexTrianglePillar(t, e, i)) return this.pillarConvex = s.convex, void(this.pillarOffset = s.offset);
            n = new r, a = new o, this.pillarConvex = n, this.pillarOffset = a
        }
        var s = this.data,
            l = this.elementSize,
            h = n.faces;
        n.vertices.length = 6;
        for (var c = 0; c < 6; c++) n.vertices[c] || (n.vertices[c] = new o);
        for (h.length = 5, c = 0; c < 5; c++) h[c] || (h[c] = []);
        var u = n.vertices,
            p = (Math.min(s[t][e], s[t + 1][e], s[t][e + 1], s[t + 1][e + 1]) - this.minValue) / 2 + this.minValue;
        i ? (a.set((t + .75) * l, (e + .75) * l, p), u[0].set(.25 * l, .25 * l, s[t + 1][e + 1] - p), u[1].set(-.75 * l, .25 * l, s[t][e + 1] - p), u[2].set(.25 * l, -.75 * l, s[t + 1][e] - p), u[3].set(.25 * l, .25 * l, -p - 1), u[4].set(-.75 * l, .25 * l, -p - 1), u[5].set(.25 * l, -.75 * l, -p - 1), h[0][0] = 0, h[0][1] = 1, h[0][2] = 2, h[1][0] = 5, h[1][1] = 4, h[1][2] = 3, h[2][0] = 2, h[2][1] = 5, h[2][2] = 3, h[2][3] = 0, h[3][0] = 3, h[3][1] = 4, h[3][2] = 1, h[3][3] = 0, h[4][0] = 1, h[4][1] = 4, h[4][2] = 5, h[4][3] = 2) : (a.set((t + .25) * l, (e + .25) * l, p), u[0].set(-.25 * l, -.25 * l, s[t][e] - p), u[1].set(.75 * l, -.25 * l, s[t + 1][e] - p), u[2].set(-.25 * l, .75 * l, s[t][e + 1] - p), u[3].set(-.25 * l, -.25 * l, -p - 1), u[4].set(.75 * l, -.25 * l, -p - 1), u[5].set(-.25 * l, .75 * l, -p - 1), h[0][0] = 0, h[0][1] = 1, h[0][2] = 2, h[1][0] = 5, h[1][1] = 4, h[1][2] = 3, h[2][0] = 0, h[2][1] = 2, h[2][2] = 5, h[2][3] = 3, h[3][0] = 1, h[3][1] = 0, h[3][2] = 3, h[3][3] = 4, h[4][0] = 4, h[4][1] = 5, h[4][2] = 2, h[4][3] = 1), n.computeNormals(), n.computeEdges(), n.updateBoundingSphereRadius(), this.setCachedConvexTrianglePillar(t, e, i, n, a)
    }, s.prototype.calculateLocalInertia = function(t, e) {
        return (e = e || new o).set(0, 0, 0), e
    }, s.prototype.volume = function() {
        return Number.MAX_VALUE
    }, s.prototype.calculateWorldAABB = function(t, e, i, n) {
        i.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), n.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
    }, s.prototype.updateBoundingSphereRadius = function() {
        var t = this.data,
            e = this.elementSize;
        this.boundingSphereRadius = new o(t.length * e, t[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm()
    }, s.prototype.setHeightsFromImage = function(t, e) {
        var i = document.createElement("canvas");
        i.width = t.width, i.height = t.height;
        var n = i.getContext("2d");
        n.drawImage(t, 0, 0);
        var r = n.getImageData(0, 0, t.width, t.height),
            o = this.data;
        o.length = 0, this.elementSize = Math.abs(e.x) / r.width;
        for (var a = 0; a < r.height; a++) {
            for (var s = [], l = 0; l < r.width; l++) {
                var h = (r.data[4 * (a * r.height + l)] + r.data[4 * (a * r.height + l) + 1] + r.data[4 * (a * r.height + l) + 2]) / 4 / 255 * e.z;
                e.x < 0 ? s.push(h) : s.unshift(h)
            }
            e.y < 0 ? o.unshift(s) : o.push(s)
        }
        this.updateMaxValue(), this.updateMinValue(), this.update()
    }
}, function(t, e, i) {
    t.exports = a;
    var n = i(74),
        r = i(1),
        o = i(8);

    function a(t, e, i, o, a) {
        n.apply(this), this.nx = i || 10, this.ny = o || 10, this.nz = a || 10, this.aabbMin = t || new r(100, 100, 100), this.aabbMax = e || new r(-100, -100, -100);
        var s = this.nx * this.ny * this.nz;
        if (s <= 0) throw "GridBroadphase: Each dimension's n must be >0";
        this.bins = [], this.binLengths = [], this.bins.length = s, this.binLengths.length = s;
        for (var l = 0; l < s; l++) this.bins[l] = [], this.binLengths[l] = 0
    }
    a.prototype = new n, a.prototype.constructor = a;
    var s = new r;
    new r, a.prototype.collisionPairs = function(t, e, i) {
        for (var n = t.numObjects(), r = t.bodies, a = this.aabbMax, l = this.aabbMin, h = this.nx, c = this.ny, u = this.nz, p = c * u, d = u, f = 1, m = a.x, v = a.y, g = a.z, y = l.x, _ = l.y, x = l.z, b = h / (m - y), w = c / (v - _), T = u / (g - x), E = (m - y) / h, M = (v - _) / c, S = (g - x) / u, A = .5 * Math.sqrt(E * E + M * M + S * S), C = o.types, R = C.SPHERE, P = C.PLANE, L = (C.BOX, C.COMPOUND, C.CONVEXPOLYHEDRON, this.bins), O = this.binLengths, B = this.bins.length, I = 0; I !== B; I++) O[I] = 0;
        var N = Math.ceil;

        function z(t, e, i, n, r, o, a) {
            var s = (t - y) * b | 0,
                l = (e - _) * w | 0,
                m = (i - x) * T | 0,
                v = N((n - y) * b),
                g = N((r - _) * w),
                E = N((o - x) * T);
            s < 0 ? s = 0 : s >= h && (s = h - 1), l < 0 ? l = 0 : l >= c && (l = c - 1), m < 0 ? m = 0 : m >= u && (m = u - 1), v < 0 ? v = 0 : v >= h && (v = h - 1), g < 0 ? g = 0 : g >= c && (g = c - 1), E < 0 ? E = 0 : E >= u && (E = u - 1), l *= d, m *= f, v *= p, g *= d, E *= f;
            for (var M = s *= p; M <= v; M += p)
                for (var S = l; S <= g; S += d)
                    for (var A = m; A <= E; A += f) {
                        var C = M + S + A;
                        L[C][O[C]++] = a
                    }
        }
        for (l = Math.min, a = Math.max, I = 0; I !== n; I++) {
            var F = (it = r[I]).shape;
            switch (F.type) {
                case R:
                    var D = it.position.x,
                        U = it.position.y,
                        k = it.position.z,
                        V = F.radius;
                    z(D - V, U - V, k - V, D + V, U + V, k + V, it);
                    break;
                case P:
                    F.worldNormalNeedsUpdate && F.computeWorldNormal(it.quaternion);
                    var H = F.worldNormal,
                        G = y + .5 * E - it.position.x,
                        j = _ + .5 * M - it.position.y,
                        W = x + .5 * S - it.position.z,
                        q = s;
                    q.set(G, j, W);
                    for (var X = 0, Y = 0; X !== h; X++, Y += p, q.y = j, q.x += E)
                        for (var Z = 0, J = 0; Z !== c; Z++, J += d, q.z = W, q.y += M)
                            for (var K = 0, Q = 0; K !== u; K++, Q += f, q.z += S)
                                if (q.dot(H) < A) {
                                    var $ = Y + J + Q;
                                    L[$][O[$]++] = it
                                }
                    break;
                default:
                    it.aabbNeedsUpdate && it.computeAABB(), z(it.aabb.lowerBound.x, it.aabb.lowerBound.y, it.aabb.lowerBound.z, it.aabb.upperBound.x, it.aabb.upperBound.y, it.aabb.upperBound.z, it)
            }
        }
        for (I = 0; I !== B; I++) {
            var tt = O[I];
            if (tt > 1) {
                var et = L[I];
                for (X = 0; X !== tt; X++) {
                    var it = et[X];
                    for (Z = 0; Z !== X; Z++) {
                        var nt = et[Z];
                        this.needBroadphaseCollision(it, nt) && this.intersectionTest(it, nt, e, i)
                    }
                }
            }
        }
        this.makePairsUnique(e, i)
    }
}, function(t, e, i) {
    t.exports = o;
    var n = i(40),
        r = i(24);

    function o(t, e, i, o) {
        n.call(this, t, e), void 0 === i && (i = t.position.distanceTo(e.position)), void 0 === o && (o = 1e6), this.distance = i;
        var a = this.distanceEquation = new r(t, e);
        this.equations.push(a), a.minForce = -o, a.maxForce = o
    }
    o.prototype = new n, o.prototype.update = function() {
        var t = this.bodyA,
            e = this.bodyB,
            i = this.distanceEquation,
            n = .5 * this.distance,
            r = i.ni;
        e.position.vsub(t.position, r), r.normalize(), r.mult(n, i.ri), r.mult(-n, i.rj)
    }
}, function(t, e, i) {
    t.exports = o, i(8);
    var n = i(1),
        r = (i(13), i(42));

    function o(t, e, i, o) {
        var a = o,
            s = [],
            l = [],
            h = [],
            c = [],
            u = [],
            p = Math.cos,
            d = Math.sin;
        s.push(new n(e * p(0), e * d(0), .5 * -i)), c.push(0), s.push(new n(t * p(0), t * d(0), .5 * i)), u.push(1);
        for (var f = 0; f < a; f++) {
            var m = 2 * Math.PI / a * (f + 1),
                v = 2 * Math.PI / a * (f + .5);
            f < a - 1 ? (s.push(new n(e * p(m), e * d(m), .5 * -i)), c.push(2 * f + 2), s.push(new n(t * p(m), t * d(m), .5 * i)), u.push(2 * f + 3), h.push([2 * f + 2, 2 * f + 3, 2 * f + 1, 2 * f])) : h.push([0, 1, 2 * f + 1, 2 * f]), (a % 2 == 1 || f < a / 2) && l.push(new n(p(v), d(v), 0))
        }
        h.push(u), l.push(new n(0, 0, 1));
        var g = [];
        for (f = 0; f < c.length; f++) g.push(c[c.length - f - 1]);
        h.push(g), r.call(this, s, h, l)
    }
    o.prototype = new r
}, function(t, e, i) {
    t.exports = o;
    var n = i(1),
        r = (i(25), i(39));

    function o(t, e, i) {
        var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
        r.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.angle = void 0 !== i.angle ? i.angle : 0
    }
    o.prototype = new r, o.prototype.constructor = o;
    var a = new n,
        s = new n;
    o.prototype.computeB = function(t) {
        var e = this.a,
            i = this.b,
            n = this.axisA,
            r = this.axisB,
            o = a,
            l = s,
            h = this.jacobianElementA,
            c = this.jacobianElementB;
        return n.cross(r, o), r.cross(n, l), h.rotational.copy(l), c.rotational.copy(o), -(Math.cos(this.angle) - n.dot(r)) * e - this.computeGW() * i - t * this.computeGiMf()
    }
}, function(t, e, i) {
    t.exports = s, i(40);
    var n = i(71),
        r = i(220),
        o = i(70),
        a = (i(24), i(1));

    function s(t, e, i) {
        var s = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6,
            l = i.pivotA ? i.pivotA.clone() : new a,
            h = i.pivotB ? i.pivotB.clone() : new a;
        this.axisA = i.axisA ? i.axisA.clone() : new a, this.axisB = i.axisB ? i.axisB.clone() : new a, n.call(this, t, l, e, h, s), this.collideConnected = !!i.collideConnected, this.angle = void 0 !== i.angle ? i.angle : 0;
        var c = this.coneEquation = new r(t, e, i),
            u = this.twistEquation = new o(t, e, i);
        this.twistAngle = void 0 !== i.twistAngle ? i.twistAngle : 0, c.maxForce = 0, c.minForce = -s, u.maxForce = 0, u.minForce = -s, this.equations.push(c, u)
    }
    s.prototype = new n, s.constructor = s, new a, new a, s.prototype.update = function() {
        var t = this.bodyA,
            e = this.bodyB,
            i = this.coneEquation,
            r = this.twistEquation;
        n.prototype.update.call(this), t.vectorToWorldFrame(this.axisA, i.axisA), e.vectorToWorldFrame(this.axisB, i.axisB), this.axisA.tangents(r.axisA, r.axisA), t.vectorToWorldFrame(r.axisA, r.axisA), this.axisB.tangents(r.axisB, r.axisB), e.vectorToWorldFrame(r.axisB, r.axisB), i.angle = this.angle, r.maxAngle = this.twistAngle
    }
}, function(t, e, i) {
    t.exports = r;
    var n = i(1);

    function r() {
        this.spatial = new n, this.rotational = new n
    }
    r.prototype.multiplyElement = function(t) {
        return t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational)
    }, r.prototype.multiplyVectors = function(t, e) {
        return t.dot(this.spatial) + e.dot(this.rotational)
    }
}, function(t) {
    t.exports = {
        _from: "github:FabienMotte/cannon.js",
        _id: "cannon@0.6.2",
        _inBundle: !1,
        _integrity: "",
        _location: "/cannon",
        _phantomChildren: {},
        _requested: {
            type: "git",
            raw: "github:FabienMotte/cannon.js",
            rawSpec: "github:FabienMotte/cannon.js",
            saveSpec: "github:FabienMotte/cannon.js",
            fetchSpec: null,
            gitCommittish: null
        },
        _requiredBy: ["/"],
        _resolved: "github:FabienMotte/cannon.js#245b42d71ed2f6eec00936b511edbda62a9ef042",
        _spec: "github:FabienMotte/cannon.js",
        _where: "/Users/totomac/Projects/Gobelins/dino-2000/game",
        author: {
            name: "Stefan Hedman",
            email: "schteppe@gmail.com",
            url: "http://steffe.se"
        },
        bugs: {
            url: "https://github.com/schteppe/cannon.js/issues"
        },
        bundleDependencies: !1,
        dependencies: {},
        deprecated: !1,
        description: "A lightweight 3D physics engine written in JavaScript.",
        devDependencies: {
            browserify: "*",
            grunt: "~0.4.0",
            "grunt-browserify": "^2.1.4",
            "grunt-contrib-concat": "~0.1.3",
            "grunt-contrib-jshint": "~0.1.1",
            "grunt-contrib-nodeunit": "^0.4.1",
            "grunt-contrib-uglify": "^0.5.1",
            "grunt-contrib-yuidoc": "^0.5.2",
            jshint: "latest",
            nodeunit: "^0.9.0",
            "uglify-js": "latest"
        },
        engines: {
            node: "*"
        },
        homepage: "https://github.com/schteppe/cannon.js",
        keywords: ["cannon.js", "cannon", "physics", "engine", "3d"],
        licenses: [{
            type: "MIT"
        }],
        main: "./src/Cannon.js",
        name: "cannon",
        repository: {
            type: "git",
            url: "git+https://github.com/schteppe/cannon.js.git"
        },
        version: "0.6.2"
    }
}, function(t, e, i) {
    t.exports = {
        version: i(223).version,
        AABB: i(26),
        ArrayCollisionMatrix: i(134),
        Body: i(30),
        Box: i(75),
        Broadphase: i(74),
        Constraint: i(40),
        ContactEquation: i(24),
        Narrowphase: i(132),
        ConeTwistConstraint: i(221),
        ContactMaterial: i(129),
        ConvexPolyhedron: i(42),
        Cylinder: i(219),
        DistanceConstraint: i(218),
        Equation: i(39),
        EventTarget: i(90),
        FrictionEquation: i(89),
        GSSolver: i(128),
        GridBroadphase: i(217),
        Heightfield: i(216),
        HingeConstraint: i(127),
        LockConstraint: i(215),
        Mat3: i(25),
        Material: i(55),
        NaiveBroadphase: i(126),
        ObjectCollisionMatrix: i(214),
        Pool: i(130),
        Particle: i(125),
        Plane: i(133),
        PointToPointConstraint: i(71),
        Quaternion: i(13),
        Ray: i(73),
        RaycastVehicle: i(213),
        RaycastResult: i(54),
        RigidVehicle: i(211),
        RotationalEquation: i(70),
        RotationalMotorEquation: i(88),
        SAPBroadphase: i(210),
        SPHSystem: i(209),
        Shape: i(8),
        Solver: i(72),
        Sphere: i(124),
        SplitSolver: i(208),
        Spring: i(207),
        Transform: i(41),
        Trimesh: i(206),
        Vec3: i(1),
        Vec3Pool: i(131),
        World: i(204)
    }
}, function(t, e, i) {
    "use strict";
    var n, r, o = function(t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (null != t)
            for (var i in t)
                if (Object.prototype.hasOwnProperty.call(t, i)) {
                    var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, i) : {};
                    n.get || n.set ? Object.defineProperty(e, i, n) : e[i] = t[i]
                }
        return e.default = t, e
    }(i(135));

    function a(t) {
        return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }
    var s, l, h = {
        distributions: {
            BOX: 1,
            SPHERE: 2,
            DISC: 3
        },
        valueOverLifetimeLength: 4
    };
    void 0 === (r = "function" == typeof(n = h) ? n.call(e, i, e, t) : n) || (t.exports = r), h.TypedArrayHelper = function(t, e, i, n) {
        this.componentSize = i || 1, this.size = e || 1, this.TypedArrayConstructor = t || Float32Array, this.array = new t(e * this.componentSize), this.indexOffset = n || 0
    }, h.TypedArrayHelper.constructor = h.TypedArrayHelper, h.TypedArrayHelper.prototype.setSize = function(t, e) {
        var i = this.array.length;
        return e || (t *= this.componentSize), t < i ? this.shrink(t) : t > i ? this.grow(t) : void console.info("TypedArray is already of size:", t + ".", "Will not resize.")
    }, h.TypedArrayHelper.prototype.shrink = function(t) {
        return this.array = this.array.subarray(0, t), this.size = t, this
    }, h.TypedArrayHelper.prototype.grow = function(t) {
        var e = this.array,
            i = new this.TypedArrayConstructor(t);
        return i.set(e), this.array = i, this.size = t, this
    }, h.TypedArrayHelper.prototype.splice = function(t, e) {
        t *= this.componentSize, e *= this.componentSize;
        for (var i = [], n = this.array, r = n.length, o = 0; o < r; ++o)(o < t || o >= e) && i.push(n[o]);
        return this.setFromArray(0, i), this
    }, h.TypedArrayHelper.prototype.setFromArray = function(t, e) {
        var i = t + e.length;
        return i > this.array.length ? this.grow(i) : i < this.array.length && this.shrink(i), this.array.set(e, this.indexOffset + t), this
    }, h.TypedArrayHelper.prototype.setVec2 = function(t, e) {
        return this.setVec2Components(t, e.x, e.y)
    }, h.TypedArrayHelper.prototype.setVec2Components = function(t, e, i) {
        var n = this.array,
            r = this.indexOffset + t * this.componentSize;
        return n[r] = e, n[r + 1] = i, this
    }, h.TypedArrayHelper.prototype.setVec3 = function(t, e) {
        return this.setVec3Components(t, e.x, e.y, e.z)
    }, h.TypedArrayHelper.prototype.setVec3Components = function(t, e, i, n) {
        var r = this.array,
            o = this.indexOffset + t * this.componentSize;
        return r[o] = e, r[o + 1] = i, r[o + 2] = n, this
    }, h.TypedArrayHelper.prototype.setVec4 = function(t, e) {
        return this.setVec4Components(t, e.x, e.y, e.z, e.w)
    }, h.TypedArrayHelper.prototype.setVec4Components = function(t, e, i, n, r) {
        var o = this.array,
            a = this.indexOffset + t * this.componentSize;
        return o[a] = e, o[a + 1] = i, o[a + 2] = n, o[a + 3] = r, this
    }, h.TypedArrayHelper.prototype.setMat3 = function(t, e) {
        return this.setFromArray(this.indexOffset + t * this.componentSize, e.elements)
    }, h.TypedArrayHelper.prototype.setMat4 = function(t, e) {
        return this.setFromArray(this.indexOffset + t * this.componentSize, e.elements)
    }, h.TypedArrayHelper.prototype.setColor = function(t, e) {
        return this.setVec3Components(t, e.r, e.g, e.b)
    }, h.TypedArrayHelper.prototype.setNumber = function(t, e) {
        return this.array[this.indexOffset + t * this.componentSize] = e, this
    }, h.TypedArrayHelper.prototype.getValueAtIndex = function(t) {
        return this.array[this.indexOffset + t]
    }, h.TypedArrayHelper.prototype.getComponentValueAtIndex = function(t) {
        return this.array.subarray(this.indexOffset + t * this.componentSize)
    }, h.ShaderAttribute = function(t, e, i) {
        var n = h.ShaderAttribute.typeSizeMap;
        this.type = "string" == typeof t && n.hasOwnProperty(t) ? t : "f", this.componentSize = n[this.type], this.arrayType = i || Float32Array, this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!e, this.updateMin = 0, this.updateMax = 0
    }, h.ShaderAttribute.constructor = h.ShaderAttribute, h.ShaderAttribute.typeSizeMap = {
        f: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        c: 3,
        m3: 9,
        m4: 16
    }, h.ShaderAttribute.prototype.setUpdateRange = function(t, e) {
        this.updateMin = Math.min(t * this.componentSize, this.updateMin * this.componentSize), this.updateMax = Math.max(e * this.componentSize, this.updateMax * this.componentSize)
    }, h.ShaderAttribute.prototype.flagUpdate = function() {
        var t = this.bufferAttribute,
            e = t.updateRange;
        e.offset = this.updateMin, e.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), t.needsUpdate = !0
    }, h.ShaderAttribute.prototype.resetUpdateRange = function() {
        this.updateMin = 0, this.updateMax = 0
    }, h.ShaderAttribute.prototype.resetDynamic = function() {
        this.bufferAttribute.dynamic = this.dynamicBuffer
    }, h.ShaderAttribute.prototype.splice = function(t, e) {
        this.typedArray.splice(t, e), this.forceUpdateAll()
    }, h.ShaderAttribute.prototype.forceUpdateAll = function() {
        this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.dynamic = !1, this.bufferAttribute.needsUpdate = !0
    }, h.ShaderAttribute.prototype._ensureTypedArray = function(t) {
        null !== this.typedArray && this.typedArray.size === t * this.componentSize || (null !== this.typedArray && this.typedArray.size !== t ? this.typedArray.setSize(t) : null === this.typedArray && (this.typedArray = new h.TypedArrayHelper(this.arrayType, t, this.componentSize)))
    }, h.ShaderAttribute.prototype._createBufferAttribute = function(t) {
        if (this._ensureTypedArray(t), null !== this.bufferAttribute) return this.bufferAttribute.array = this.typedArray.array, parseFloat(o.REVISION) >= 81 && (this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize), void(this.bufferAttribute.needsUpdate = !0);
        this.bufferAttribute = new o.BufferAttribute(this.typedArray.array, this.componentSize), this.bufferAttribute.dynamic = this.dynamicBuffer
    }, h.ShaderAttribute.prototype.getLength = function() {
        return null === this.typedArray ? 0 : this.typedArray.array.length
    }, h.shaderChunks = {
        defines: ["#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0"].join("\n"),
        uniforms: ["uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D texture;", "uniform vec4 textureAnimation;", "uniform float scale;"].join("\n"),
        attributes: ["attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;"].join("\n"),
        varyings: ["varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif"].join("\n"),
        branchAvoidanceFunctions: ["float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}"].join("\n"),
        unpackColor: ["vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}"].join("\n"),
        unpackRotationAxis: ["vec3 unpackRotationAxis( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   c *= vec3( 2.0 );", "   c -= vec3( 1.0 );", "   return c;", "}"].join("\n"),
        floatOverLifetime: ["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}"].join("\n"),
        colorOverLifetime: ["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}"].join("\n"),
        paramFetchingFunctions: ["float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}"].join("\n"),
        forceFetchingFunctions: ["vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}"].join("\n"),
        rotationFunctions: ["#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      if( rotation.y == 0.0 ) {", "           return pos;", "      }", "", "      vec3 axis = unpackRotationAxis( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = rotationCenter - pos;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );", "   }", "#endif"].join("\n"),
        rotateTexture: ["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( texture, vUv );"].join("\n")
    }, h.shaders = {
        vertex: [h.shaderChunks.defines, h.shaderChunks.uniforms, h.shaderChunks.attributes, h.shaderChunks.varyings, o.ShaderChunk.common, o.ShaderChunk.logdepthbuf_pars_vertex, o.ShaderChunk.fog_pars_vertex, h.shaderChunks.branchAvoidanceFunctions, h.shaderChunks.unpackColor, h.shaderChunks.unpackRotationAxis, h.shaderChunks.floatOverLifetime, h.shaderChunks.colorOverLifetime, h.shaderChunks.paramFetchingFunctions, h.shaderChunks.forceFetchingFunctions, h.shaderChunks.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPosition.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPosition;", o.ShaderChunk.logdepthbuf_vertex, o.ShaderChunk.fog_vertex, "}"].join("\n"),
        fragment: [h.shaderChunks.uniforms, o.ShaderChunk.common, o.ShaderChunk.fog_pars_fragment, o.ShaderChunk.logdepthbuf_pars_fragment, h.shaderChunks.varyings, h.shaderChunks.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", h.shaderChunks.rotateTexture, o.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", o.ShaderChunk.fog_fragment, "}"].join("\n")
    }, h.utils = {
        types: {
            BOOLEAN: "boolean",
            STRING: "string",
            NUMBER: "number",
            OBJECT: "object"
        },
        ensureTypedArg: function(t, e, i) {
            return a(t) === e ? t : i
        },
        ensureArrayTypedArg: function(t, e, i) {
            if (Array.isArray(t)) {
                for (var n = t.length - 1; n >= 0; --n)
                    if (a(t[n]) !== e) return i;
                return t
            }
            return this.ensureTypedArg(t, e, i)
        },
        ensureInstanceOf: function(t, e, i) {
            return void 0 !== e && t instanceof e ? t : i
        },
        ensureArrayInstanceOf: function(t, e, i) {
            if (Array.isArray(t)) {
                for (var n = t.length - 1; n >= 0; --n)
                    if (void 0 !== e && t[n] instanceof e == 0) return i;
                return t
            }
            return this.ensureInstanceOf(t, e, i)
        },
        ensureValueOverLifetimeCompliance: function(t, e, i) {
            e = e || 3, i = i || 3, !1 === Array.isArray(t._value) && (t._value = [t._value]), !1 === Array.isArray(t._spread) && (t._spread = [t._spread]);
            var n = this.clamp(t._value.length, e, i),
                r = this.clamp(t._spread.length, e, i),
                o = Math.max(n, r);
            t._value.length !== o && (t._value = this.interpolateArray(t._value, o)), t._spread.length !== o && (t._spread = this.interpolateArray(t._spread, o))
        },
        interpolateArray: function(t, e) {
            for (var i = t.length, n = ["function" == typeof t[0].clone ? t[0].clone() : t[0]], r = (i - 1) / (e - 1), o = 1; o < e - 1; ++o) {
                var a = o * r,
                    s = Math.floor(a),
                    l = Math.ceil(a),
                    h = a - s;
                n[o] = this.lerpTypeAgnostic(t[s], t[l], h)
            }
            return n.push("function" == typeof t[i - 1].clone ? t[i - 1].clone() : t[i - 1]), n
        },
        clamp: function(t, e, i) {
            return Math.max(e, Math.min(t, i))
        },
        zeroToEpsilon: function(t, e) {
            var i = t;
            return i = e ? 1e-5 * Math.random() * 10 : 1e-5, t < 0 && t > -1e-5 && (i = -i), i
        },
        lerpTypeAgnostic: function(t, e, i) {
            var n, r = this.types;
            return a(t) === r.NUMBER && a(e) === r.NUMBER ? t + (e - t) * i : t instanceof o.Vector2 && e instanceof o.Vector2 ? ((n = t.clone()).x = this.lerp(t.x, e.x, i), n.y = this.lerp(t.y, e.y, i), n) : t instanceof o.Vector3 && e instanceof o.Vector3 ? ((n = t.clone()).x = this.lerp(t.x, e.x, i), n.y = this.lerp(t.y, e.y, i), n.z = this.lerp(t.z, e.z, i), n) : t instanceof o.Vector4 && e instanceof o.Vector4 ? ((n = t.clone()).x = this.lerp(t.x, e.x, i), n.y = this.lerp(t.y, e.y, i), n.z = this.lerp(t.z, e.z, i), n.w = this.lerp(t.w, e.w, i), n) : t instanceof o.Color && e instanceof o.Color ? ((n = t.clone()).r = this.lerp(t.r, e.r, i), n.g = this.lerp(t.g, e.g, i), n.b = this.lerp(t.b, e.b, i), n) : void console.warn("Invalid argument types, or argument types do not match:", t, e)
        },
        lerp: function(t, e, i) {
            return t + (e - t) * i
        },
        roundToNearestMultiple: function(t, e) {
            var i;
            return 0 === e ? t : 0 == (i = Math.abs(t) % e) ? t : t < 0 ? -(Math.abs(t) - i) : t + e - i
        },
        arrayValuesAreEqual: function(t) {
            for (var e = 0; e < t.length - 1; ++e)
                if (t[e] !== t[e + 1]) return !1;
            return !0
        },
        randomFloat: function(t, e) {
            return t + e * (Math.random() - .5)
        },
        randomVector3: function(t, e, i, n, r) {
            var o = i.x + (Math.random() * n.x - .5 * n.x),
                a = i.y + (Math.random() * n.y - .5 * n.y),
                s = i.z + (Math.random() * n.z - .5 * n.z);
            r && (o = .5 * -r.x + this.roundToNearestMultiple(o, r.x), a = .5 * -r.y + this.roundToNearestMultiple(a, r.y), s = .5 * -r.z + this.roundToNearestMultiple(s, r.z)), t.typedArray.setVec3Components(e, o, a, s)
        },
        randomColor: function(t, e, i, n) {
            var r = i.r + Math.random() * n.x,
                o = i.g + Math.random() * n.y,
                a = i.b + Math.random() * n.z;
            r = this.clamp(r, 0, 1), o = this.clamp(o, 0, 1), a = this.clamp(a, 0, 1), t.typedArray.setVec3Components(e, r, o, a)
        },
        randomColorAsHex: (l = new o.Color, function(t, e, i, n) {
            for (var r = i.length, o = [], a = 0; a < r; ++a) {
                var s = n[a];
                l.copy(i[a]), l.r += Math.random() * s.x - .5 * s.x, l.g += Math.random() * s.y - .5 * s.y, l.b += Math.random() * s.z - .5 * s.z, l.r = this.clamp(l.r, 0, 1), l.g = this.clamp(l.g, 0, 1), l.b = this.clamp(l.b, 0, 1), o.push(l.getHex())
            }
            t.typedArray.setVec4Components(e, o[0], o[1], o[2], o[3])
        }),
        randomVector3OnSphere: function(t, e, i, n, r, o, a, s) {
            var l = 2 * Math.random() - 1,
                h = 6.2832 * Math.random(),
                c = Math.sqrt(1 - l * l),
                u = this.randomFloat(n, r),
                p = 0,
                d = 0,
                f = 0;
            a && (u = Math.round(u / a) * a), p = c * Math.cos(h) * u, d = c * Math.sin(h) * u, f = l * u, p *= o.x, d *= o.y, f *= o.z, p += i.x, d += i.y, f += i.z, t.typedArray.setVec3Components(e, p, d, f)
        },
        seededRandom: function(t) {
            var e = 1e4 * Math.sin(t);
            return e - (0 | e)
        },
        randomVector3OnDisc: function(t, e, i, n, r, o, a) {
            var s = 6.2832 * Math.random(),
                l = Math.abs(this.randomFloat(n, r)),
                h = 0,
                c = 0,
                u = 0;
            a && (l = Math.round(l / a) * a), h = Math.cos(s) * l, c = Math.sin(s) * l, h *= o.x, c *= o.y, h += i.x, c += i.y, u += i.z, t.typedArray.setVec3Components(e, h, c, u)
        },
        randomDirectionVector3OnSphere: (s = new o.Vector3, function(t, e, i, n, r, o, a, l) {
            s.copy(o), s.x -= i, s.y -= n, s.z -= r, s.normalize().multiplyScalar(-this.randomFloat(a, l)), t.typedArray.setVec3Components(e, s.x, s.y, s.z)
        }),
        randomDirectionVector3OnDisc: function() {
            var t = new o.Vector3;
            return function(e, i, n, r, o, a, s, l) {
                t.copy(a), t.x -= n, t.y -= r, t.z -= o, t.normalize().multiplyScalar(-this.randomFloat(s, l)), e.typedArray.setVec3Components(i, t.x, t.y, 0)
            }
        }(),
        getPackedRotationAxis: function() {
            var t = new o.Vector3,
                e = new o.Vector3,
                i = new o.Color,
                n = new o.Vector3(1, 1, 1);
            return function(r, o) {
                return t.copy(r).normalize(), e.copy(o).normalize(), t.x += .5 * -o.x + Math.random() * o.x, t.y += .5 * -o.y + Math.random() * o.y, t.z += .5 * -o.z + Math.random() * o.z, t.normalize().add(n).multiplyScalar(.5), i.setRGB(t.x, t.y, t.z), i.getHex()
            }
        }()
    }, h.Group = function(t) {
        var e = h.utils,
            i = e.types;
        (t = e.ensureTypedArg(t, i.OBJECT, {})).texture = e.ensureTypedArg(t.texture, i.OBJECT, {}), this.uuid = o.Math.generateUUID(), this.fixedTimeStep = e.ensureTypedArg(t.fixedTimeStep, i.NUMBER, .016), this.texture = e.ensureInstanceOf(t.texture.value, o.Texture, null), this.textureFrames = e.ensureInstanceOf(t.texture.frames, o.Vector2, new o.Vector2(1, 1)), this.textureFrameCount = e.ensureTypedArg(t.texture.frameCount, i.NUMBER, this.textureFrames.x * this.textureFrames.y), this.textureLoop = e.ensureTypedArg(t.texture.loop, i.NUMBER, 1), this.textureFrames.max(new o.Vector2(1, 1)), this.hasPerspective = e.ensureTypedArg(t.hasPerspective, i.BOOLEAN, !0), this.colorize = e.ensureTypedArg(t.colorize, i.BOOLEAN, !0), this.maxParticleCount = e.ensureTypedArg(t.maxParticleCount, i.NUMBER, null), this.blending = e.ensureTypedArg(t.blending, i.NUMBER, o.AdditiveBlending), this.transparent = e.ensureTypedArg(t.transparent, i.BOOLEAN, !0), this.alphaTest = parseFloat(e.ensureTypedArg(t.alphaTest, i.NUMBER, 0)), this.depthWrite = e.ensureTypedArg(t.depthWrite, i.BOOLEAN, !1), this.depthTest = e.ensureTypedArg(t.depthTest, i.BOOLEAN, !0), this.fog = e.ensureTypedArg(t.fog, i.BOOLEAN, !0), this.scale = e.ensureTypedArg(t.scale, i.NUMBER, 300), this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1, this.particleCount = 0, this.uniforms = {
            texture: {
                type: "t",
                value: this.texture
            },
            textureAnimation: {
                type: "v4",
                value: new o.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))
            },
            fogColor: {
                type: "c",
                value: null
            },
            fogNear: {
                type: "f",
                value: 10
            },
            fogFar: {
                type: "f",
                value: 200
            },
            fogDensity: {
                type: "f",
                value: .5
            },
            deltaTime: {
                type: "f",
                value: 0
            },
            runTime: {
                type: "f",
                value: 0
            },
            scale: {
                type: "f",
                value: this.scale
            }
        }, this.defines = {
            HAS_PERSPECTIVE: this.hasPerspective,
            COLORIZE: this.colorize,
            VALUE_OVER_LIFETIME_LENGTH: h.valueOverLifetimeLength,
            SHOULD_ROTATE_TEXTURE: !1,
            SHOULD_ROTATE_PARTICLES: !1,
            SHOULD_WIGGLE_PARTICLES: !1,
            SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
        }, this.attributes = {
            position: new h.ShaderAttribute("v3", !0),
            acceleration: new h.ShaderAttribute("v4", !0),
            velocity: new h.ShaderAttribute("v3", !0),
            rotation: new h.ShaderAttribute("v4", !0),
            rotationCenter: new h.ShaderAttribute("v3", !0),
            params: new h.ShaderAttribute("v4", !0),
            size: new h.ShaderAttribute("v4", !0),
            angle: new h.ShaderAttribute("v4", !0),
            color: new h.ShaderAttribute("v4", !0),
            opacity: new h.ShaderAttribute("v4", !0)
        }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, this.material = new o.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: h.shaders.vertex,
            fragmentShader: h.shaders.fragment,
            blending: this.blending,
            transparent: this.transparent,
            alphaTest: this.alphaTest,
            depthWrite: this.depthWrite,
            depthTest: this.depthTest,
            defines: this.defines,
            fog: this.fog
        }), this.geometry = new o.BufferGeometry, this.mesh = new o.Points(this.geometry, this.material), null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.")
    }, h.Group.constructor = h.Group, h.Group.prototype._updateDefines = function() {
        for (var t, e = this.emitters, i = e.length - 1, n = this.defines; i >= 0; --i) t = e[i], n.SHOULD_CALCULATE_SPRITE || (n.SHOULD_ROTATE_TEXTURE = n.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, t.angle.value), Math.max.apply(null, t.angle.spread))), n.SHOULD_ROTATE_PARTICLES = n.SHOULD_ROTATE_PARTICLES || !!Math.max(t.rotation.angle, t.rotation.angleSpread), n.SHOULD_WIGGLE_PARTICLES = n.SHOULD_WIGGLE_PARTICLES || !!Math.max(t.wiggle.value, t.wiggle.spread);
        this.material.needsUpdate = !0
    }, h.Group.prototype._applyAttributesToGeometry = function() {
        var t, e, i = this.attributes,
            n = this.geometry,
            r = n.attributes;
        for (var o in i) i.hasOwnProperty(o) && (t = i[o], (e = r[o]) ? e.array = t.typedArray.array : n.addAttribute(o, t.bufferAttribute), t.bufferAttribute.needsUpdate = !0);
        this.geometry.setDrawRange(0, this.particleCount)
    }, h.Group.prototype.addEmitter = function(t) {
        if (t instanceof h.Emitter != 0)
            if (this.emitterIDs.indexOf(t.uuid) > -1) console.error("Emitter already exists in this group. Will not add again.");
            else {
                if (null === t.group) {
                    var e = this.attributes,
                        i = this.particleCount,
                        n = i + t.particleCount;
                    for (var r in this.particleCount = n, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), t._calculatePPSValue(t.maxAge._value + t.maxAge._spread), t._setBufferUpdateRanges(this.attributeKeys), t._setAttributeOffset(i), t.group = this, t.attributes = this.attributes, e) e.hasOwnProperty(r) && e[r]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
                    for (var o = i; o < n; ++o) t._assignPositionValue(o), t._assignForceValue(o, "velocity"), t._assignForceValue(o, "acceleration"), t._assignAbsLifetimeValue(o, "opacity"), t._assignAbsLifetimeValue(o, "size"), t._assignAngleValue(o), t._assignRotationValue(o), t._assignParamsValue(o), t._assignColorValue(o);
                    return this._applyAttributesToGeometry(), this.emitters.push(t), this.emitterIDs.push(t.uuid), this._updateDefines(t), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0, this
                }
                console.error("Emitter already belongs to another group. Will not add to requested group.")
            }
        else console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", t)
    }, h.Group.prototype.removeEmitter = function(t) {
        var e = this.emitterIDs.indexOf(t.uuid);
        if (t instanceof h.Emitter != 0)
            if (-1 !== e) {
                for (var i = t.attributeOffset, n = i + t.particleCount, r = this.attributes.params.typedArray, o = i; o < n; ++o) r.array[4 * o] = 0, r.array[4 * o + 1] = 0;
                for (var a in this.emitters.splice(e, 1), this.emitterIDs.splice(e, 1), this.attributes) this.attributes.hasOwnProperty(a) && this.attributes[a].splice(i, n);
                this.particleCount -= t.particleCount, t._onRemove(), this._attributesNeedRefresh = !0
            } else console.error("Emitter does not exist in this group. Will not remove.");
        else console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", t)
    }, h.Group.prototype.getFromPool = function() {
        var t = this._pool,
            e = this._createNewWhenPoolEmpty;
        if (t.length) return t.pop();
        if (e) {
            var i = new h.Emitter(this._poolCreationSettings);
            return this.addEmitter(i), i
        }
        return null
    }, h.Group.prototype.releaseIntoPool = function(t) {
        if (t instanceof h.Emitter != 0) return t.reset(), this._pool.unshift(t), this;
        console.error("Argument is not instanceof SPE.Emitter:", t)
    }, h.Group.prototype.getPool = function() {
        return this._pool
    }, h.Group.prototype.addPool = function(t, e, i) {
        var n;
        this._poolCreationSettings = e, this._createNewWhenPoolEmpty = !!i;
        for (var r = 0; r < t; ++r) n = Array.isArray(e) ? new h.Emitter(e[r]) : new h.Emitter(e), this.addEmitter(n), this.releaseIntoPool(n);
        return this
    }, h.Group.prototype._triggerSingleEmitter = function(t) {
        var e = this.getFromPool(),
            i = this;
        if (null !== e) return t instanceof o.Vector3 && (e.position.value.copy(t), e.position.value = e.position.value), e.enable(), setTimeout(function() {
            e.disable(), i.releaseIntoPool(e)
        }, 1e3 * Math.max(e.duration, e.maxAge.value + e.maxAge.spread)), this;
        console.log("SPE.Group pool ran out.")
    }, h.Group.prototype.triggerPoolEmitter = function(t, e) {
        if ("number" == typeof t && t > 1)
            for (var i = 0; i < t; ++i) this._triggerSingleEmitter(e);
        else this._triggerSingleEmitter(e);
        return this
    }, h.Group.prototype._updateUniforms = function(t) {
        this.uniforms.runTime.value += t, this.uniforms.deltaTime.value = t
    }, h.Group.prototype._resetBufferRanges = function() {
        for (var t = this.attributeKeys, e = this.attributeCount - 1, i = this.attributes; e >= 0; --e) i[t[e]].resetUpdateRange()
    }, h.Group.prototype._updateBuffers = function(t) {
        for (var e, i, n, r = this.attributeKeys, o = this.attributeCount - 1, a = this.attributes, s = t.bufferUpdateRanges; o >= 0; --o) i = s[e = r[o]], (n = a[e]).setUpdateRange(i.min, i.max), n.flagUpdate()
    }, h.Group.prototype.tick = function(t) {
        var e = this.emitters,
            i = e.length,
            n = t || this.fixedTimeStep,
            r = this.attributeKeys,
            o = this.attributes;
        if (this._updateUniforms(n), this._resetBufferRanges(), 0 !== i || !1 !== this._attributesNeedRefresh || !1 !== this._attributesNeedDynamicReset) {
            for (var a, s = 0; s < i; ++s)(a = e[s]).tick(n), this._updateBuffers(a);
            if (!0 === this._attributesNeedDynamicReset) {
                for (s = this.attributeCount - 1; s >= 0; --s) o[r[s]].resetDynamic();
                this._attributesNeedDynamicReset = !1
            }
            if (!0 === this._attributesNeedRefresh) {
                for (s = this.attributeCount - 1; s >= 0; --s) o[r[s]].forceUpdateAll();
                this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0
            }
        }
    }, h.Group.prototype.dispose = function() {
        return this.geometry.dispose(), this.material.dispose(), this
    }, h.Emitter = function(t) {
        var e = h.utils,
            i = e.types,
            n = h.valueOverLifetimeLength;
        for (var r in (t = e.ensureTypedArg(t, i.OBJECT, {})).position = e.ensureTypedArg(t.position, i.OBJECT, {}), t.velocity = e.ensureTypedArg(t.velocity, i.OBJECT, {}), t.acceleration = e.ensureTypedArg(t.acceleration, i.OBJECT, {}), t.radius = e.ensureTypedArg(t.radius, i.OBJECT, {}), t.drag = e.ensureTypedArg(t.drag, i.OBJECT, {}), t.rotation = e.ensureTypedArg(t.rotation, i.OBJECT, {}), t.color = e.ensureTypedArg(t.color, i.OBJECT, {}), t.opacity = e.ensureTypedArg(t.opacity, i.OBJECT, {}), t.size = e.ensureTypedArg(t.size, i.OBJECT, {}), t.angle = e.ensureTypedArg(t.angle, i.OBJECT, {}), t.wiggle = e.ensureTypedArg(t.wiggle, i.OBJECT, {}), t.maxAge = e.ensureTypedArg(t.maxAge, i.OBJECT, {}), t.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."), this.uuid = o.Math.generateUUID(), this.type = e.ensureTypedArg(t.type, i.NUMBER, h.distributions.BOX), this.position = {
                _value: e.ensureInstanceOf(t.position.value, o.Vector3, new o.Vector3),
                _spread: e.ensureInstanceOf(t.position.spread, o.Vector3, new o.Vector3),
                _spreadClamp: e.ensureInstanceOf(t.position.spreadClamp, o.Vector3, new o.Vector3),
                _distribution: e.ensureTypedArg(t.position.distribution, i.NUMBER, this.type),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1),
                _radius: e.ensureTypedArg(t.position.radius, i.NUMBER, 10),
                _radiusScale: e.ensureInstanceOf(t.position.radiusScale, o.Vector3, new o.Vector3(1, 1, 1)),
                _distributionClamp: e.ensureTypedArg(t.position.distributionClamp, i.NUMBER, 0)
            }, this.velocity = {
                _value: e.ensureInstanceOf(t.velocity.value, o.Vector3, new o.Vector3),
                _spread: e.ensureInstanceOf(t.velocity.spread, o.Vector3, new o.Vector3),
                _distribution: e.ensureTypedArg(t.velocity.distribution, i.NUMBER, this.type),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.acceleration = {
                _value: e.ensureInstanceOf(t.acceleration.value, o.Vector3, new o.Vector3),
                _spread: e.ensureInstanceOf(t.acceleration.spread, o.Vector3, new o.Vector3),
                _distribution: e.ensureTypedArg(t.acceleration.distribution, i.NUMBER, this.type),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.drag = {
                _value: e.ensureTypedArg(t.drag.value, i.NUMBER, 0),
                _spread: e.ensureTypedArg(t.drag.spread, i.NUMBER, 0),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.wiggle = {
                _value: e.ensureTypedArg(t.wiggle.value, i.NUMBER, 0),
                _spread: e.ensureTypedArg(t.wiggle.spread, i.NUMBER, 0)
            }, this.rotation = {
                _axis: e.ensureInstanceOf(t.rotation.axis, o.Vector3, new o.Vector3(0, 1, 0)),
                _axisSpread: e.ensureInstanceOf(t.rotation.axisSpread, o.Vector3, new o.Vector3),
                _angle: e.ensureTypedArg(t.rotation.angle, i.NUMBER, 0),
                _angleSpread: e.ensureTypedArg(t.rotation.angleSpread, i.NUMBER, 0),
                _static: e.ensureTypedArg(t.rotation.static, i.BOOLEAN, !1),
                _center: e.ensureInstanceOf(t.rotation.center, o.Vector3, this.position._value.clone()),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.maxAge = {
                _value: e.ensureTypedArg(t.maxAge.value, i.NUMBER, 2),
                _spread: e.ensureTypedArg(t.maxAge.spread, i.NUMBER, 0)
            }, this.color = {
                _value: e.ensureArrayInstanceOf(t.color.value, o.Color, new o.Color),
                _spread: e.ensureArrayInstanceOf(t.color.spread, o.Vector3, new o.Vector3),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.opacity = {
                _value: e.ensureArrayTypedArg(t.opacity.value, i.NUMBER, 1),
                _spread: e.ensureArrayTypedArg(t.opacity.spread, i.NUMBER, 0),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.size = {
                _value: e.ensureArrayTypedArg(t.size.value, i.NUMBER, 1),
                _spread: e.ensureArrayTypedArg(t.size.spread, i.NUMBER, 0),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.angle = {
                _value: e.ensureArrayTypedArg(t.angle.value, i.NUMBER, 0),
                _spread: e.ensureArrayTypedArg(t.angle.spread, i.NUMBER, 0),
                _randomise: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1)
            }, this.particleCount = e.ensureTypedArg(t.particleCount, i.NUMBER, 100), this.duration = e.ensureTypedArg(t.duration, i.NUMBER, null), this.isStatic = e.ensureTypedArg(t.isStatic, i.BOOLEAN, !1), this.activeMultiplier = e.ensureTypedArg(t.activeMultiplier, i.NUMBER, 1), this.direction = e.ensureTypedArg(t.direction, i.NUMBER, 1), this.alive = e.ensureTypedArg(t.alive, i.BOOLEAN, !0), this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.resetFlags = {
                position: e.ensureTypedArg(t.position.randomise, i.BOOLEAN, !1) || e.ensureTypedArg(t.radius.randomise, i.BOOLEAN, !1),
                velocity: e.ensureTypedArg(t.velocity.randomise, i.BOOLEAN, !1),
                acceleration: e.ensureTypedArg(t.acceleration.randomise, i.BOOLEAN, !1) || e.ensureTypedArg(t.drag.randomise, i.BOOLEAN, !1),
                rotation: e.ensureTypedArg(t.rotation.randomise, i.BOOLEAN, !1),
                rotationCenter: e.ensureTypedArg(t.rotation.randomise, i.BOOLEAN, !1),
                size: e.ensureTypedArg(t.size.randomise, i.BOOLEAN, !1),
                color: e.ensureTypedArg(t.color.randomise, i.BOOLEAN, !1),
                opacity: e.ensureTypedArg(t.opacity.randomise, i.BOOLEAN, !1),
                angle: e.ensureTypedArg(t.angle.randomise, i.BOOLEAN, !1)
            }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = {
                maxAge: "params",
                position: "position",
                velocity: "velocity",
                acceleration: "acceleration",
                drag: "acceleration",
                wiggle: "params",
                rotation: "rotation",
                size: "size",
                color: "color",
                opacity: "opacity",
                angle: "angle"
            }, this.updateMap) this.updateMap.hasOwnProperty(r) && (this.updateCounts[this.updateMap[r]] = 0, this.updateFlags[this.updateMap[r]] = !1, this._createGetterSetters(this[r], r));
        this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, e.ensureValueOverLifetimeCompliance(this.color, n, n), e.ensureValueOverLifetimeCompliance(this.opacity, n, n), e.ensureValueOverLifetimeCompliance(this.size, n, n), e.ensureValueOverLifetimeCompliance(this.angle, n, n)
    }, h.Emitter.constructor = h.Emitter, h.Emitter.prototype._createGetterSetters = function(t, e) {
        var i = this;
        for (var n in t)
            if (t.hasOwnProperty(n)) {
                var r = n.replace("_", "");
                Object.defineProperty(t, r, {
                    get: function(t) {
                        return function() {
                            return this[t]
                        }
                    }(n),
                    set: function(t) {
                        return function(n) {
                            var r = i.updateMap[e],
                                o = this[t],
                                a = h.valueOverLifetimeLength;
                            "_rotationCenter" === t ? (i.updateFlags.rotationCenter = !0, i.updateCounts.rotationCenter = 0) : "_randomise" === t ? i.resetFlags[r] = n : (i.updateFlags[r] = !0, i.updateCounts[r] = 0), i.group._updateDefines(), this[t] = n, Array.isArray(o) && h.utils.ensureValueOverLifetimeCompliance(i[e], a, a)
                        }
                    }(n)
                })
            }
    }, h.Emitter.prototype._setBufferUpdateRanges = function(t) {
        this.attributeKeys = t, this.attributeCount = t.length;
        for (var e = this.attributeCount - 1; e >= 0; --e) this.bufferUpdateRanges[t[e]] = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        }
    }, h.Emitter.prototype._calculatePPSValue = function(t) {
        var e = this.particleCount;
        this.duration ? this.particlesPerSecond = e / (t < this.duration ? t : this.duration) : this.particlesPerSecond = e / t
    }, h.Emitter.prototype._setAttributeOffset = function(t) {
        this.attributeOffset = t, this.activationIndex = t, this.activationEnd = t + this.particleCount
    }, h.Emitter.prototype._assignValue = function(t, e) {
        switch (t) {
            case "position":
                this._assignPositionValue(e);
                break;
            case "velocity":
            case "acceleration":
                this._assignForceValue(e, t);
                break;
            case "size":
            case "opacity":
                this._assignAbsLifetimeValue(e, t);
                break;
            case "angle":
                this._assignAngleValue(e);
                break;
            case "params":
                this._assignParamsValue(e);
                break;
            case "rotation":
                this._assignRotationValue(e);
                break;
            case "color":
                this._assignColorValue(e)
        }
    }, h.Emitter.prototype._assignPositionValue = function(t) {
        var e = h.distributions,
            i = h.utils,
            n = this.position,
            r = this.attributes.position,
            o = n._value,
            a = n._spread;
        switch (n._distribution) {
            case e.BOX:
                i.randomVector3(r, t, o, a, n._spreadClamp);
                break;
            case e.SPHERE:
                i.randomVector3OnSphere(r, t, o, n._radius, n._spread.x, n._radiusScale, n._spreadClamp.x, n._distributionClamp || this.particleCount);
                break;
            case e.DISC:
                i.randomVector3OnDisc(r, t, o, n._radius, n._spread.x, n._radiusScale, n._spreadClamp.x)
        }
    }, h.Emitter.prototype._assignForceValue = function(t, e) {
        var i, n, r, o, a, s = h.distributions,
            l = h.utils,
            c = this[e],
            u = c._value,
            p = c._spread;
        switch (c._distribution) {
            case s.BOX:
                l.randomVector3(this.attributes[e], t, u, p);
                break;
            case s.SPHERE:
                n = (i = this.attributes.position.typedArray.array)[a = 3 * t], r = i[a + 1], o = i[a + 2], l.randomDirectionVector3OnSphere(this.attributes[e], t, n, r, o, this.position._value, c._value.x, c._spread.x);
                break;
            case s.DISC:
                n = (i = this.attributes.position.typedArray.array)[a = 3 * t], r = i[a + 1], o = i[a + 2], l.randomDirectionVector3OnDisc(this.attributes[e], t, n, r, o, this.position._value, c._value.x, c._spread.x)
        }
        if ("acceleration" === e) {
            var d = l.clamp(l.randomFloat(this.drag._value, this.drag._spread), 0, 1);
            this.attributes.acceleration.typedArray.array[4 * t + 3] = d
        }
    }, h.Emitter.prototype._assignAbsLifetimeValue = function(t, e) {
        var i, n = this.attributes[e].typedArray,
            r = this[e],
            o = h.utils;
        o.arrayValuesAreEqual(r._value) && o.arrayValuesAreEqual(r._spread) ? (i = Math.abs(o.randomFloat(r._value[0], r._spread[0])), n.setVec4Components(t, i, i, i, i)) : n.setVec4Components(t, Math.abs(o.randomFloat(r._value[0], r._spread[0])), Math.abs(o.randomFloat(r._value[1], r._spread[1])), Math.abs(o.randomFloat(r._value[2], r._spread[2])), Math.abs(o.randomFloat(r._value[3], r._spread[3])))
    }, h.Emitter.prototype._assignAngleValue = function(t) {
        var e, i = this.attributes.angle.typedArray,
            n = this.angle,
            r = h.utils;
        r.arrayValuesAreEqual(n._value) && r.arrayValuesAreEqual(n._spread) ? (e = r.randomFloat(n._value[0], n._spread[0]), i.setVec4Components(t, e, e, e, e)) : i.setVec4Components(t, r.randomFloat(n._value[0], n._spread[0]), r.randomFloat(n._value[1], n._spread[1]), r.randomFloat(n._value[2], n._spread[2]), r.randomFloat(n._value[3], n._spread[3]))
    }, h.Emitter.prototype._assignParamsValue = function(t) {
        this.attributes.params.typedArray.setVec4Components(t, this.isStatic ? 1 : 0, 0, Math.abs(h.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), h.utils.randomFloat(this.wiggle._value, this.wiggle._spread))
    }, h.Emitter.prototype._assignRotationValue = function(t) {
        this.attributes.rotation.typedArray.setVec3Components(t, h.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), h.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1), this.attributes.rotationCenter.typedArray.setVec3(t, this.rotation._center)
    }, h.Emitter.prototype._assignColorValue = function(t) {
        h.utils.randomColorAsHex(this.attributes.color, t, this.color._value, this.color._spread)
    }, h.Emitter.prototype._resetParticle = function(t) {
        for (var e, i, n = this.resetFlags, r = this.updateFlags, o = this.updateCounts, a = this.attributeKeys, s = this.attributeCount - 1; s >= 0; --s) i = r[e = a[s]], !0 !== n[e] && !0 !== i || (this._assignValue(e, t), this._updateAttributeUpdateRange(e, t), !0 === i && o[e] === this.particleCount ? (r[e] = !1, o[e] = 0) : 1 == i && ++o[e])
    }, h.Emitter.prototype._updateAttributeUpdateRange = function(t, e) {
        var i = this.bufferUpdateRanges[t];
        i.min = Math.min(e, i.min), i.max = Math.max(e, i.max)
    }, h.Emitter.prototype._resetBufferRanges = function() {
        for (var t, e = this.bufferUpdateRanges, i = this.bufferUpdateKeys, n = this.bufferUpdateCount - 1; n >= 0; --n) e[t = i[n]].min = Number.POSITIVE_INFINITY, e[t].max = Number.NEGATIVE_INFINITY
    }, h.Emitter.prototype._onRemove = function() {
        this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.age = 0
    }, h.Emitter.prototype._decrementParticleCount = function() {
        --this.activeParticleCount
    }, h.Emitter.prototype._incrementParticleCount = function() {
        ++this.activeParticleCount
    }, h.Emitter.prototype._checkParticleAges = function(t, e, i, n) {
        for (var r, o, a, s, l = e - 1; l >= t; --l) 0 !== (s = i[r = 4 * l]) && (a = i[r + 1], o = i[r + 2], 1 === this.direction ? (a += n) >= o && (a = 0, s = 0, this._decrementParticleCount()) : (a -= n) <= 0 && (a = o, s = 0, this._decrementParticleCount()), i[r] = s, i[r + 1] = a, this._updateAttributeUpdateRange("params", l))
    }, h.Emitter.prototype._activateParticles = function(t, e, i, n) {
        for (var r, o, a = this.direction, s = t; s < e; ++s) 0 != i[r = 4 * s] && 1 !== this.particleCount || (this._incrementParticleCount(), i[r] = 1, this._resetParticle(s), o = n * (s - t), i[r + 1] = -1 === a ? i[r + 2] - o : o, this._updateAttributeUpdateRange("params", s))
    }, h.Emitter.prototype.tick = function(t) {
        if (!this.isStatic) {
            null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
            var e = this.attributeOffset,
                i = e + this.particleCount,
                n = this.paramsArray,
                r = this.particlesPerSecond * this.activeMultiplier * t,
                o = this.activationIndex;
            if (this._resetBufferRanges(), this._checkParticleAges(e, i, n, t), !1 !== this.alive) {
                if (null !== this.duration && this.age > this.duration) return this.alive = !1, void(this.age = 0);
                var a = 1 === this.particleCount ? o : 0 | o,
                    s = Math.min(a + r, this.activationEnd),
                    l = s - this.activationIndex | 0,
                    h = l > 0 ? t / l : 0;
                this._activateParticles(a, s, n, h), this.activationIndex += r, this.activationIndex > i && (this.activationIndex = e), this.age += t
            } else this.age = 0
        }
    }, h.Emitter.prototype.reset = function(t) {
        if (this.age = 0, this.alive = !1, !0 === t) {
            for (var e, i = this.attributeOffset, n = i + this.particleCount, r = this.paramsArray, o = this.attributes.params.bufferAttribute, a = n - 1; a >= i; --a) r[e = 4 * a] = 0, r[e + 1] = 0;
            o.updateRange.offset = 0, o.updateRange.count = -1, o.needsUpdate = !0
        }
        return this
    }, h.Emitter.prototype.enable = function() {
        return this.alive = !0, this
    }, h.Emitter.prototype.disable = function() {
        return this.alive = !1, this
    }, h.Emitter.prototype.remove = function() {
        return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this
    }
}, function(t, e, i) {
    (function(e) {
        ! function(t) {
            "use strict";
            var e = t.GreenSockGlobals || t,
                i = function(t) {
                    var i, n = "com.greensock.utils".split("."),
                        r = e;
                    for (i = 0; i < n.length; i++) r[n[i]] = r = r[n[i]] || {};
                    return r
                }(),
                n = function t(e) {
                    var i = e.nodeType,
                        n = "";
                    if (1 === i || 9 === i || 11 === i) {
                        if ("string" == typeof e.textContent) return e.textContent;
                        for (e = e.firstChild; e; e = e.nextSibling) n += t(e)
                    } else if (3 === i || 4 === i) return e.nodeValue;
                    return n
                },
                r = document,
                o = r.defaultView ? r.defaultView.getComputedStyle : function() {},
                a = /([A-Z])/g,
                s = function(t, e, i, n) {
                    var r;
                    return (i = i || o(t, null)) ? r = (t = i.getPropertyValue(e.replace(a, "-$1").toLowerCase())) || i.length ? t : i[e] : t.currentStyle && (r = (i = t.currentStyle)[e]), n ? r : parseInt(r, 10) || 0
                },
                l = function(t) {
                    return !!(t.length && t[0] && (t[0].nodeType && t[0].style && !t.nodeType || t[0].length && t[0][0]))
                },
                h = ")eefec303079ad17405c",
                c = /(?:<br>|<br\/>|<br \/>)/gi,
                u = "<div style='position:relative;display:inline-block;" + (r.all && !r.addEventListener ? "*display:inline;*zoom:1;'" : "'"),
                p = function(t) {
                    var e = -1 !== (t = t || "").indexOf("++"),
                        i = 1;
                    return e && (t = t.split("++").join("")),
                        function() {
                            return u + (t ? " class='" + t + (e ? i++ : "") + "'>" : ">")
                        }
                },
                d = i.SplitText = e.SplitText = function(t, e) {
                    if ("string" == typeof t && (t = d.selector(t)), !t) throw "cannot split a null element.";
                    this.elements = l(t) ? function(t) {
                        var e, i, n, r = [],
                            o = t.length;
                        for (e = 0; e < o; e++)
                            if (i = t[e], l(i))
                                for (n = i.length, n = 0; n < i.length; n++) r.push(i[n]);
                            else r.push(i);
                        return r
                    }(t) : [t], this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e)
                },
                f = function(t, e) {
                    for (var i = e.length; --i > -1;) t.push(e[i])
                },
                m = function(t, e, i, a, l) {
                    c.test(t.innerHTML) && (t.innerHTML = t.innerHTML.replace(c, h));
                    var u, d, m, v, g, y, _, x, b, w, T, E, M, S, A = n(t),
                        C = e.type || e.split || "chars,words,lines",
                        R = -1 !== C.indexOf("lines") ? [] : null,
                        P = -1 !== C.indexOf("words"),
                        L = -1 !== C.indexOf("chars"),
                        O = "absolute" === e.position || !0 === e.absolute,
                        B = O ? "&#173; " : " ",
                        I = -999,
                        N = o(t),
                        z = s(t, "paddingLeft", N),
                        F = s(t, "borderBottomWidth", N) + s(t, "borderTopWidth", N),
                        D = s(t, "borderLeftWidth", N) + s(t, "borderRightWidth", N),
                        U = s(t, "paddingTop", N) + s(t, "paddingBottom", N),
                        k = s(t, "paddingLeft", N) + s(t, "paddingRight", N),
                        V = s(t, "textAlign", N, !0),
                        H = t.clientHeight,
                        G = t.clientWidth,
                        j = p(e.wordsClass),
                        W = p(e.charsClass),
                        q = -1 !== (e.linesClass || "").indexOf("++"),
                        X = e.linesClass,
                        Y = -1 !== A.indexOf("<"),
                        Z = !0,
                        J = [],
                        K = [],
                        Q = [];
                    for (q && (X = X.split("++").join("")), Y && (A = A.split("<").join("{{LT}}")), u = A.length, v = j(), g = 0; g < u; g++)
                        if (")" === (_ = A.charAt(g)) && A.substr(g, 20) === h) v += (Z ? "</div>" : "") + "<BR/>", Z = !1, g !== u - 20 && A.substr(g + 20, 20) !== h && (v += " " + j(), Z = !0), g += 19;
                        else if (" " === _ && " " !== A.charAt(g - 1) && g !== u - 1 && A.substr(g - 20, 20) !== h) {
                        for (v += Z ? "</div>" : "", Z = !1;
                            " " === A.charAt(g + 1);) v += B, g++;
                        ")" === A.charAt(g + 1) && A.substr(g + 1, 20) === h || (v += B + j(), Z = !0)
                    } else v += L && " " !== _ ? W() + _ + "</div>" : _;
                    for (t.innerHTML = v + (Z ? "</div>" : ""), Y && function t(e, i, n) {
                            var r = e.nodeType;
                            if (1 === r || 9 === r || 11 === r)
                                for (e = e.firstChild; e; e = e.nextSibling) t(e, i, n);
                            else 3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(i).join(n))
                        }(t, "{{LT}}", "<"), u = (y = t.getElementsByTagName("*")).length, x = [], g = 0; g < u; g++) x[g] = y[g];
                    if (R || O)
                        for (g = 0; g < u; g++)((m = (b = x[g]).parentNode === t) || O || L && !P) && (w = b.offsetTop, R && m && w !== I && "BR" !== b.nodeName && (d = [], R.push(d), I = w), O && (b._x = b.offsetLeft, b._y = w, b._w = b.offsetWidth, b._h = b.offsetHeight), R && (P !== m && L || (d.push(b), b._x -= z), m && g && (x[g - 1]._wordEnd = !0), "BR" === b.nodeName && b.nextSibling && "BR" === b.nextSibling.nodeName && R.push([])));
                    for (g = 0; g < u; g++) m = (b = x[g]).parentNode === t, "BR" !== b.nodeName ? (O && (E = b.style, P || m || (b._x += b.parentNode._x, b._y += b.parentNode._y), E.left = b._x + "px", E.top = b._y + "px", E.position = "absolute", E.display = "block", E.width = b._w + 1 + "px", E.height = b._h + "px"), P ? m && "" !== b.innerHTML ? K.push(b) : L && J.push(b) : m ? (t.removeChild(b), x.splice(g--, 1), u--) : !m && L && (w = !R && !O && b.nextSibling, t.appendChild(b), w || t.appendChild(r.createTextNode(" ")), J.push(b))) : R || O ? (t.removeChild(b), x.splice(g--, 1), u--) : P || t.appendChild(b);
                    if (R) {
                        for (O && (T = r.createElement("div"), t.appendChild(T), M = T.offsetWidth + "px", w = T.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(T)), E = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                        for (S = !O || !P && !L, g = 0; g < R.length; g++) {
                            for (d = R[g], (T = r.createElement("div")).style.cssText = "display:block;text-align:" + V + ";position:" + (O ? "absolute;" : "relative;"), X && (T.className = X + (q ? g + 1 : "")), Q.push(T), u = d.length, y = 0; y < u; y++) "BR" !== d[y].nodeName && (b = d[y], T.appendChild(b), S && (b._wordEnd || P) && T.appendChild(r.createTextNode(" ")), O && (0 === y && (T.style.top = b._y + "px", T.style.left = z + w + "px"), b.style.top = "0px", w && (b.style.left = b._x - w + "px")));
                            0 === u && (T.innerHTML = "&nbsp;"), P || L || (T.innerHTML = n(T).split(String.fromCharCode(160)).join(" ")), O && (T.style.width = M, T.style.height = b._h + "px"), t.appendChild(T)
                        }
                        t.style.cssText = E
                    }
                    O && (H > t.clientHeight && (t.style.height = H - U + "px", t.clientHeight < H && (t.style.height = H + F + "px")), G > t.clientWidth && (t.style.width = G - k + "px", t.clientWidth < G && (t.style.width = G + D + "px"))), f(i, J), f(a, K), f(l, Q)
                },
                v = d.prototype;
            v.split = function(t) {
                this.isSplit && this.revert(), this.vars = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                for (var e = this.elements.length; --e > -1;) this._originals[e] = this.elements[e].innerHTML, m(this.elements[e], this.vars, this.chars, this.words, this.lines);
                return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
            }, v.revert = function() {
                if (!this._originals) throw "revert() call wasn't scoped properly.";
                for (var t = this._originals.length; --t > -1;) this.elements[t].innerHTML = this._originals[t];
                return this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
            }, d.selector = t.$ || t.jQuery || function(e) {
                var i = t.$ || t.jQuery;
                return i ? (d.selector = i, i(e)) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e)
            }, d.version = "0.3.3"
        }(void 0 !== t && t.exports && void 0 !== e ? e : this || window)
    }).call(this, i(18))
}, function(t, e, i) {
    (function(i) {
        var n, r = void 0 !== t && t.exports && void 0 !== i ? i : this || window;
        (r._gsQueue || (r._gsQueue = [])).push(function() {
                "use strict";
                var t, e, i, n, o, a, s, l, h, c, u, p, d, f;
                r._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            r = function(t, e, i) {
                                var n, r, o = t.cycle;
                                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            o = function(t, e, n) {
                                i.call(this, t, e, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = o.prototype.render
                            },
                            a = i._internals,
                            s = a.isSelector,
                            l = a.isArray,
                            h = o.prototype = i.to({}, .1, {}),
                            c = [];
                        o.version = "2.0.0", h.constructor = o, h.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, h.invalidate = function() {
                            return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this)
                        }, h.updateTo = function(t, e) {
                            var n, r = this.ratio,
                                o = this.vars.immediateRender || t.immediateRender;
                            for (n in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[n] = t[n];
                            if (this._initted || o)
                                if (e) this._initted = !1, o && this.render(0, !0, !0);
                                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                var a = this._totalTime;
                                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                            } else if (this._initted = !1, this._init(), this._time > 0 || o)
                                for (var s, l = 1 / (1 - r), h = this._firstPT; h;) s = h.s + h.c, h.c *= l, h.s = s - h.c, h = h._next;
                            return this
                        }, h.render = function(t, e, n) {
                            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                            var r, o, s, l, h, c, u, p, d, f = this._dirty ? this.totalDuration() : this._totalDuration,
                                m = this._time,
                                v = this._totalTime,
                                g = this._cycle,
                                y = this._duration,
                                _ = this._rawPrevTime;
                            if (t >= f - 1e-7 && t >= 0 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, o = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-7 || 1e-10 === _ && "isPause" !== this.data) && _ !== t && (n = !0, _ > 1e-10 && (o = "onReverseComplete")), this._rawPrevTime = p = !e || t || _ === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === y && _ > 0) && (o = "onReverseComplete", r = this._reversed), t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (_ >= 0 && (n = !0), this._rawPrevTime = p = !e || t || _ === t ? t : 1e-10)), this._initted || (n = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (l = y + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (d = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== d || this._initted ? this._yoyoEase = d = !0 === d ? this._ease : d instanceof Ease ? d : Ease.map[d] : (d = this.vars.ease, this._yoyoEase = d = d ? d instanceof Ease ? d : "function" == typeof d ? new Ease(d, this.vars.easeParams) : Ease.map[d] || i.defaultEase : i.defaultEase)), this.ratio = d ? 1 - d.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !d ? (h = this._time / y, c = this._easeType, u = this._easePower, (1 === c || 3 === c && h >= .5) && (h = 1 - h), 3 === c && (h *= 2), 1 === u ? h *= h : 2 === u ? h *= h * h : 3 === u ? h *= h * h * h : 4 === u && (h *= h * h * h * h), 1 === c ? this.ratio = 1 - h : 2 === c ? this.ratio = h : this._time / y < .5 ? this.ratio = h / 2 : this.ratio = 1 - h / 2) : d || (this.ratio = this._ease.getRatio(this._time / y))), m !== this._time || n || g !== this._cycle) {
                                if (!this._initted) {
                                    if (this._init(), !this._initted || this._gc) return;
                                    if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = v, this._rawPrevTime = _, this._cycle = g, a.lazyTweens.push(this), void(this._lazy = [t, e]);
                                    !this._time || r || d ? r && this._ease._calcEnd && !d && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
                                }
                                for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === v && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : o || (o = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                                this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, n), e || (this._totalTime !== v || o) && this._callback("onUpdate")), this._cycle !== g && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), o && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o), 0 === y && 1e-10 === this._rawPrevTime && 1e-10 !== p && (this._rawPrevTime = 0)))
                            } else v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                        }, o.to = function(t, e, i) {
                            return new o(t, e, i)
                        }, o.from = function(t, e, i) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(t, e, i)
                        }, o.fromTo = function(t, e, i, n) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new o(t, e, n)
                        }, o.staggerTo = o.allTo = function(t, e, a, h, u, p, d) {
                            h = h || 0;
                            var f, m, v, g, y = 0,
                                _ = [],
                                x = function() {
                                    a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), u.apply(d || a.callbackScope || this, p || c)
                                },
                                b = a.cycle,
                                w = a.startAt && a.startAt.cycle;
                            for (l(t) || ("string" == typeof t && (t = i.selector(t) || t), s(t) && (t = n(t))), t = t || [], h < 0 && ((t = n(t)).reverse(), h *= -1), f = t.length - 1, v = 0; v <= f; v++) {
                                for (g in m = {}, a) m[g] = a[g];
                                if (b && (r(m, t, v), null != m.duration && (e = m.duration, delete m.duration)), w) {
                                    for (g in w = m.startAt = {}, a.startAt) w[g] = a.startAt[g];
                                    r(m.startAt, t, v)
                                }
                                m.delay = y + (m.delay || 0), v === f && u && (m.onComplete = x), _[v] = new o(t[v], e, m), y += h
                            }
                            return _
                        }, o.staggerFrom = o.allFrom = function(t, e, i, n, r, a, s) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(t, e, i, n, r, a, s)
                        }, o.staggerFromTo = o.allFromTo = function(t, e, i, n, r, a, s, l) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, o.staggerTo(t, e, n, r, a, s, l)
                        }, o.delayedCall = function(t, e, i, n, r) {
                            return new o(e, 0, {
                                delay: t,
                                onComplete: e,
                                onCompleteParams: i,
                                callbackScope: n,
                                onReverseComplete: e,
                                onReverseCompleteParams: i,
                                immediateRender: !1,
                                useFrames: r,
                                overwrite: 0
                            })
                        }, o.set = function(t, e) {
                            return new o(t, 0, e)
                        }, o.isTweening = function(t) {
                            return i.getTweensOf(t, !0).length > 0
                        };
                        var u = function(t, e) {
                                for (var n = [], r = 0, o = t._first; o;) o instanceof i ? n[r++] = o : (e && (n[r++] = o), r = (n = n.concat(u(o, e))).length), o = o._next;
                                return n
                            },
                            p = o.getAllTweens = function(e) {
                                return u(t._rootTimeline, e).concat(u(t._rootFramesTimeline, e))
                            };
                        o.killAll = function(t, i, n, r) {
                            null == i && (i = !0), null == n && (n = !0);
                            var o, a, s, l = p(0 != r),
                                h = l.length,
                                c = i && n && r;
                            for (s = 0; s < h; s++) a = l[s], (c || a instanceof e || (o = a.target === a.vars.onComplete) && n || i && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                        }, o.killChildTweensOf = function(t, e) {
                            if (null != t) {
                                var r, h, c, u, p, d = a.tweenLookup;
                                if ("string" == typeof t && (t = i.selector(t) || t), s(t) && (t = n(t)), l(t))
                                    for (u = t.length; --u > -1;) o.killChildTweensOf(t[u], e);
                                else {
                                    for (c in r = [], d)
                                        for (h = d[c].target.parentNode; h;) h === t && (r = r.concat(d[c].tweens)), h = h.parentNode;
                                    for (p = r.length, u = 0; u < p; u++) e && r[u].totalTime(r[u].totalDuration()), r[u]._enabled(!1, !1)
                                }
                            }
                        };
                        var d = function(t, i, n, r) {
                            i = !1 !== i, n = !1 !== n;
                            for (var o, a, s = p(r = !1 !== r), l = i && n && r, h = s.length; --h > -1;) a = s[h], (l || a instanceof e || (o = a.target === a.vars.onComplete) && n || i && !o) && a.paused(t)
                        };
                        return o.pauseAll = function(t, e, i) {
                            d(!0, t, e, i)
                        }, o.resumeAll = function(t, e, i) {
                            d(!1, t, e, i)
                        }, o.globalTimeScale = function(e) {
                            var n = t._rootTimeline,
                                r = i.ticker.time;
                            return arguments.length ? (e = e || 1e-10, n._startTime = r - (r - n._startTime) * n._timeScale / e, n = t._rootFramesTimeline, r = i.ticker.frame, n._startTime = r - (r - n._startTime) * n._timeScale / e, n._timeScale = t._rootTimeline._timeScale = e, e) : n._timeScale
                        }, h.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                        }, h.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                        }, h.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, h.duration = function(e) {
                            return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                        }, h.totalDuration = function(t) {
                            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                        }, h.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, h.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, h.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, o
                    }, !0), r._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                var i, n, r = this.vars;
                                for (n in r) i = r[n], l(i) && -1 !== i.join("").indexOf("{self}") && (r[n] = this._swapSelfInParams(i));
                                l(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                            },
                            o = i._internals,
                            a = n._internals = {},
                            s = o.isSelector,
                            l = o.isArray,
                            h = o.lazyTweens,
                            c = o.lazyRender,
                            u = r._gsDefine.globals,
                            p = function(t) {
                                var e, i = {};
                                for (e in t) i[e] = t[e];
                                return i
                            },
                            d = function(t, e, i) {
                                var n, r, o = t.cycle;
                                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            f = a.pauseCallback = function() {},
                            m = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            v = n.prototype = new e;
                        return n.version = "2.0.0", v.constructor = n, v.kill()._gc = v._forcingPlayhead = v._hasPause = !1, v.to = function(t, e, n, r) {
                            var o = n.repeat && u.TweenMax || i;
                            return e ? this.add(new o(t, e, n), r) : this.set(t, n, r)
                        }, v.from = function(t, e, n, r) {
                            return this.add((n.repeat && u.TweenMax || i).from(t, e, n), r)
                        }, v.fromTo = function(t, e, n, r, o) {
                            var a = r.repeat && u.TweenMax || i;
                            return e ? this.add(a.fromTo(t, e, n, r), o) : this.set(t, r, o)
                        }, v.staggerTo = function(t, e, r, o, a, l, h, c) {
                            var u, f, v = new n({
                                    onComplete: l,
                                    onCompleteParams: h,
                                    callbackScope: c,
                                    smoothChildTiming: this.smoothChildTiming
                                }),
                                g = r.cycle;
                            for ("string" == typeof t && (t = i.selector(t) || t), s(t = t || []) && (t = m(t)), (o = o || 0) < 0 && ((t = m(t)).reverse(), o *= -1), f = 0; f < t.length; f++)(u = p(r)).startAt && (u.startAt = p(u.startAt), u.startAt.cycle && d(u.startAt, t, f)), g && (d(u, t, f), null != u.duration && (e = u.duration, delete u.duration)), v.to(t[f], e, u, f * o);
                            return this.add(v, a)
                        }, v.staggerFrom = function(t, e, i, n, r, o, a, s) {
                            return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, o, a, s)
                        }, v.staggerFromTo = function(t, e, i, n, r, o, a, s, l) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, o, a, s, l)
                        }, v.call = function(t, e, n, r) {
                            return this.add(i.delayedCall(0, t, e, n), r)
                        }, v.set = function(t, e, n) {
                            return n = this._parseTimeOrLabel(n, 0, !0), null == e.immediateRender && (e.immediateRender = n === this._time && !this._paused), this.add(new i(t, 0, e), n)
                        }, n.exportRoot = function(t, e) {
                            null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                            var r, o, a, s, l = new n(t),
                                h = l._timeline;
                            for (null == e && (e = !0), h._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = h._time, a = h._first; a;) s = a._next, e && a instanceof i && a.target === a.vars.onComplete || ((o = a._startTime - a._delay) < 0 && (r = 1), l.add(a, o)), a = s;
                            return h.add(l, 0), r && l.totalDuration(), l
                        }, v.add = function(r, o, a, s) {
                            var h, c, u, p, d, f;
                            if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, r)), !(r instanceof t)) {
                                if (r instanceof Array || r && r.push && l(r)) {
                                    for (a = a || "normal", s = s || 0, h = o, c = r.length, u = 0; u < c; u++) l(p = r[u]) && (p = new n({
                                        tweens: p
                                    })), this.add(p, h), "string" != typeof p && "function" != typeof p && ("sequence" === a ? h = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), h += s;
                                    return this._uncache(!0)
                                }
                                if ("string" == typeof r) return this.addLabel(r, o);
                                if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                                r = i.delayedCall(0, r)
                            }
                            if (e.prototype.add.call(this, r, o), r._time && r.render((this.rawTime() - r._startTime) * r._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                for (f = (d = this).rawTime() > r._startTime; d._timeline;) f && d._timeline.smoothChildTiming ? d.totalTime(d._totalTime, !0) : d._gc && d._enabled(!0, !1), d = d._timeline;
                            return this
                        }, v.remove = function(e) {
                            if (e instanceof t) {
                                this._remove(e, !1);
                                var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                                return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                            }
                            if (e instanceof Array || e && e.push && l(e)) {
                                for (var n = e.length; --n > -1;) this.remove(e[n]);
                                return this
                            }
                            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                        }, v._remove = function(t, i) {
                            return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                        }, v.append = function(t, e) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                        }, v.insert = v.insertMultiple = function(t, e, i, n) {
                            return this.add(t, e || 0, i, n)
                        }, v.appendMultiple = function(t, e, i, n) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
                        }, v.addLabel = function(t, e) {
                            return this._labels[t] = this._parseTimeOrLabel(e), this
                        }, v.addPause = function(t, e, n, r) {
                            var o = i.delayedCall(0, f, n, r || this);
                            return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
                        }, v.removeLabel = function(t) {
                            return delete this._labels[t], this
                        }, v.getLabelTime = function(t) {
                            return null != this._labels[t] ? this._labels[t] : -1
                        }, v._parseTimeOrLabel = function(e, i, n, r) {
                            var o, a;
                            if (r instanceof t && r.timeline === this) this.remove(r);
                            else if (r && (r instanceof Array || r.push && l(r)))
                                for (a = r.length; --a > -1;) r[a] instanceof t && r[a].timeline === this && this.remove(r[a]);
                            if (o = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - o : 0, n);
                            if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = o);
                            else {
                                if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? n ? this._labels[e] = o + i : i : this._labels[e] + i;
                                i = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, n) : o
                            }
                            return Number(e) + i
                        }, v.seek = function(t, e) {
                            return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
                        }, v.stop = function() {
                            return this.paused(!0)
                        }, v.gotoAndPlay = function(t, e) {
                            return this.play(t, e)
                        }, v.gotoAndStop = function(t, e) {
                            return this.pause(t, e)
                        }, v.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, r, o, a, s, l, u, p = this._time,
                                d = this._dirty ? this.totalDuration() : this._totalDuration,
                                f = this._startTime,
                                m = this._timeScale,
                                v = this._paused;
                            if (p !== this._time && (t += this._time - p), t >= d - 1e-7 && t >= 0) this._totalTime = this._time = d, this._reversed || this._hasPausedChild() || (r = !0, a = "onComplete", s = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (s = !0, this._rawPrevTime > 1e-10 && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = d + 1e-4;
                            else if (t < 1e-7)
                                if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && 1e-10 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (a = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (s = r = !0, a = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (s = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    t = 0, this._initted || (s = !0)
                                }
                            else {
                                if (this._hasPause && !this._forcingPlayhead && !e) {
                                    if (t >= p)
                                        for (n = this._first; n && n._startTime <= t && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next;
                                    else
                                        for (n = this._last; n && n._startTime >= t && !l;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (l = n), n = n._prev;
                                    l && (this._time = t = l._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                this._totalTime = this._time = this._rawPrevTime = t
                            }
                            if (this._time !== p && this._first || i || s || l) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && t > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (u = this._time) >= p)
                                    for (n = this._first; n && (o = n._next, u === this._time && (!this._paused || v));)(n._active || n._startTime <= u && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o;
                                else
                                    for (n = this._last; n && (o = n._prev, u === this._time && (!this._paused || v));) {
                                        if (n._active || n._startTime <= p && !n._paused && !n._gc) {
                                            if (l === n) {
                                                for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (t - l._startTime) * l._timeScale : (t - l._startTime) * l._timeScale, e, i), l = l._prev;
                                                l = null, this.pause()
                                            }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                        }
                                        n = o
                                    }
                                this._onUpdate && (e || (h.length && c(), this._callback("onUpdate"))), a && (this._gc || f !== this._startTime && m === this._timeScale || (0 === this._time || d >= this.totalDuration()) && (r && (h.length && c(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                            }
                        }, v._hasPausedChild = function() {
                            for (var t = this._first; t;) {
                                if (t._paused || t instanceof n && t._hasPausedChild()) return !0;
                                t = t._next
                            }
                            return !1
                        }, v.getChildren = function(t, e, n, r) {
                            r = r || -9999999999;
                            for (var o = [], a = this._first, s = 0; a;) a._startTime < r || (a instanceof i ? !1 !== e && (o[s++] = a) : (!1 !== n && (o[s++] = a), !1 !== t && (s = (o = o.concat(a.getChildren(!0, e, n))).length))), a = a._next;
                            return o
                        }, v.getTweensOf = function(t, e) {
                            var n, r, o = this._gc,
                                a = [],
                                s = 0;
                            for (o && this._enabled(!0, !0), r = (n = i.getTweensOf(t)).length; --r > -1;)(n[r].timeline === this || e && this._contains(n[r])) && (a[s++] = n[r]);
                            return o && this._enabled(!1, !0), a
                        }, v.recent = function() {
                            return this._recent
                        }, v._contains = function(t) {
                            for (var e = t.timeline; e;) {
                                if (e === this) return !0;
                                e = e.timeline
                            }
                            return !1
                        }, v.shiftChildren = function(t, e, i) {
                            i = i || 0;
                            for (var n, r = this._first, o = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                            if (e)
                                for (n in o) o[n] >= i && (o[n] += t);
                            return this._uncache(!0)
                        }, v._kill = function(t, e) {
                            if (!t && !e) return this._enabled(!1, !1);
                            for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                            return r
                        }, v.clear = function(t) {
                            var e = this.getChildren(!1, !0, !0),
                                i = e.length;
                            for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                            return !1 !== t && (this._labels = {}), this._uncache(!0)
                        }, v.invalidate = function() {
                            for (var e = this._first; e;) e.invalidate(), e = e._next;
                            return t.prototype.invalidate.call(this)
                        }, v._enabled = function(t, i) {
                            if (t === this._gc)
                                for (var n = this._first; n;) n._enabled(t, !0), n = n._next;
                            return e.prototype._enabled.call(this, t, i)
                        }, v.totalTime = function(e, i, n) {
                            this._forcingPlayhead = !0;
                            var r = t.prototype.totalTime.apply(this, arguments);
                            return this._forcingPlayhead = !1, r
                        }, v.duration = function(t) {
                            return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                        }, v.totalDuration = function(t) {
                            if (!arguments.length) {
                                if (this._dirty) {
                                    for (var e, i, n = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : o = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), (i = r._startTime + r._totalDuration / r._timeScale) > n && (n = i), r = e;
                                    this._duration = this._totalDuration = n, this._dirty = !1
                                }
                                return this._totalDuration
                            }
                            return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                        }, v.paused = function(e) {
                            if (!e)
                                for (var i = this._first, n = this._time; i;) i._startTime === n && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                            return t.prototype.paused.apply(this, arguments)
                        }, v.usesFrames = function() {
                            for (var e = this._timeline; e._timeline;) e = e._timeline;
                            return e === t._rootFramesTimeline
                        }, v.rawTime = function(t) {
                            return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                        }, n
                    }, !0), r._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
                        var n = function(e) {
                                t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
                            },
                            o = e._internals,
                            a = o.lazyTweens,
                            s = o.lazyRender,
                            l = r._gsDefine.globals,
                            h = new i(null, null, 1, 0),
                            c = n.prototype = new t;
                        return c.constructor = n, c.kill()._gc = !1, n.version = "2.0.0", c.invalidate = function() {
                            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                        }, c.addCallback = function(t, i, n, r) {
                            return this.add(e.delayedCall(0, t, n, r), i)
                        }, c.removeCallback = function(t, e) {
                            if (t)
                                if (null == e) this._kill(null, t);
                                else
                                    for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                            return this
                        }, c.removePause = function(e) {
                            return this.removeCallback(t._internals.pauseCallback, e)
                        }, c.tweenTo = function(t, i) {
                            i = i || {};
                            var n, r, o, a = {
                                    ease: h,
                                    useFrames: this.usesFrames(),
                                    immediateRender: !1,
                                    lazy: !1
                                },
                                s = i.repeat && l.TweenMax || e;
                            for (r in i) a[r] = i[r];
                            return a.time = this._parseTimeOrLabel(t), n = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new s(this, n, a), a.onStart = function() {
                                o.target.paused(!0), o.vars.time === o.target.time() || n !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || o, i.onStartParams || [])
                            }, o
                        }, c.tweenFromTo = function(t, e, i) {
                            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                                onComplete: this.seek,
                                onCompleteParams: [t],
                                callbackScope: this
                            }, i.immediateRender = !1 !== i.immediateRender;
                            var n = this.tweenTo(e, i);
                            return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
                        }, c.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, r, o, l, h, c, u, p, d = this._time,
                                f = this._dirty ? this.totalDuration() : this._totalDuration,
                                m = this._duration,
                                v = this._totalTime,
                                g = this._startTime,
                                y = this._timeScale,
                                _ = this._rawPrevTime,
                                x = this._paused,
                                b = this._cycle;
                            if (d !== this._time && (t += this._time - d), t >= f - 1e-7 && t >= 0) this._locked || (this._totalTime = f, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, l = "onComplete", h = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || _ < 0 || 1e-10 === _) && _ !== t && this._first && (h = !0, _ > 1e-10 && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = m, t = m + 1e-4);
                            else if (t < 1e-7)
                                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== d || 0 === m && 1e-10 !== _ && (_ > 0 || t < 0 && _ >= 0) && !this._locked) && (l = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (h = r = !0, l = "onReverseComplete") : _ >= 0 && this._first && (h = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = m || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    t = 0, this._initted || (h = !0)
                                }
                            else if (0 === m && _ < 0 && (h = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (c = m + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = m - this._time), this._time > m ? (this._time = m, t = m + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                                if ((t = this._time) >= d || this._repeat && b !== this._cycle)
                                    for (n = this._first; n && n._startTime <= t && !u;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (u = n), n = n._next;
                                else
                                    for (n = this._last; n && n._startTime >= t && !u;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (u = n), n = n._prev;
                                u && u._startTime < m && (this._time = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                            }
                            if (this._cycle !== b && !this._locked) {
                                var w = this._yoyo && 0 != (1 & b),
                                    T = w === (this._yoyo && 0 != (1 & this._cycle)),
                                    E = this._totalTime,
                                    M = this._cycle,
                                    S = this._rawPrevTime,
                                    A = this._time;
                                if (this._totalTime = b * m, this._cycle < b ? w = !w : this._totalTime += m, this._time = d, this._rawPrevTime = 0 === m ? _ - 1e-4 : _, this._cycle = b, this._locked = !0, d = w ? 0 : m, this.render(d, e, 0 === m), e || this._gc || this.vars.onRepeat && (this._cycle = M, this._locked = !1, this._callback("onRepeat")), d !== this._time) return;
                                if (T && (this._cycle = b, this._locked = !0, d = w ? m + 1e-4 : -1e-4, this.render(d, !0, !1)), this._locked = !1, this._paused && !x) return;
                                this._time = A, this._totalTime = E, this._cycle = M, this._rawPrevTime = S
                            }
                            if (this._time !== d && this._first || i || h || u) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (p = this._time) >= d)
                                    for (n = this._first; n && (o = n._next, p === this._time && (!this._paused || x));)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (u === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o;
                                else
                                    for (n = this._last; n && (o = n._prev, p === this._time && (!this._paused || x));) {
                                        if (n._active || n._startTime <= d && !n._paused && !n._gc) {
                                            if (u === n) {
                                                for (u = n._prev; u && u.endTime() > this._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, i), u = u._prev;
                                                u = null, this.pause()
                                            }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                        }
                                        n = o
                                    }
                                this._onUpdate && (e || (a.length && s(), this._callback("onUpdate"))), l && (this._locked || this._gc || g !== this._startTime && y === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (r && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[l] && this._callback(l)))
                            } else v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                        }, c.getActive = function(t, e, i) {
                            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                            var n, r, o = [],
                                a = this.getChildren(t, e, i),
                                s = 0,
                                l = a.length;
                            for (n = 0; n < l; n++)(r = a[n]).isActive() && (o[s++] = r);
                            return o
                        }, c.getLabelAfter = function(t) {
                            t || 0 !== t && (t = this._time);
                            var e, i = this.getLabelsArray(),
                                n = i.length;
                            for (e = 0; e < n; e++)
                                if (i[e].time > t) return i[e].name;
                            return null
                        }, c.getLabelBefore = function(t) {
                            null == t && (t = this._time);
                            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                                if (e[i].time < t) return e[i].name;
                            return null
                        }, c.getLabelsArray = function() {
                            var t, e = [],
                                i = 0;
                            for (t in this._labels) e[i++] = {
                                time: this._labels[t],
                                name: t
                            };
                            return e.sort(function(t, e) {
                                return t.time - e.time
                            }), e
                        }, c.invalidate = function() {
                            return this._locked = !1, t.prototype.invalidate.call(this)
                        }, c.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
                        }, c.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
                        }, c.totalDuration = function(e) {
                            return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                        }, c.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, c.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, c.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, c.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, c.currentLabel = function(t) {
                            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                        }, n
                    }, !0), t = 180 / Math.PI, e = [], i = [], n = [], o = {}, a = r._gsDefine.globals, s = function(t, e, i, n) {
                        i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
                    }, l = function(t, e, i, n) {
                        var r = {
                                a: t
                            },
                            o = {},
                            a = {},
                            s = {
                                c: n
                            },
                            l = (t + e) / 2,
                            h = (e + i) / 2,
                            c = (i + n) / 2,
                            u = (l + h) / 2,
                            p = (h + c) / 2,
                            d = (p - u) / 8;
                        return r.b = l + (t - l) / 4, o.b = u + d, r.c = o.a = (r.b + o.b) / 2, o.c = a.a = (u + p) / 2, a.b = p - d, s.b = c + (n - c) / 4, a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
                    }, h = function(t, r, o, a, s) {
                        var h, c, u, p, d, f, m, v, g, y, _, x, b, w = t.length - 1,
                            T = 0,
                            E = t[0].a;
                        for (h = 0; h < w; h++) c = (d = t[T]).a, u = d.d, p = t[T + 1].d, s ? (_ = e[h], b = ((x = i[h]) + _) * r * .25 / (a ? .5 : n[h] || .5), v = u - ((f = u - (u - c) * (a ? .5 * r : 0 !== _ ? b / _ : 0)) + (((m = u + (p - u) * (a ? .5 * r : 0 !== x ? b / x : 0)) - f) * (3 * _ / (_ + x) + .5) / 4 || 0))) : v = u - ((f = u - (u - c) * r * .5) + (m = u + (p - u) * r * .5)) / 2, f += v, m += v, d.c = g = f, d.b = 0 !== h ? E : E = d.a + .6 * (d.c - d.a), d.da = u - c, d.ca = g - c, d.ba = E - c, o ? (y = l(c, E, g, u), t.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++, E = m;
                        (d = t[T]).b = E, d.c = E + .4 * (d.d - E), d.da = d.d - d.a, d.ca = d.c - d.a, d.ba = E - d.a, o && (y = l(d.a, E, d.c, d.d), t.splice(T, 1, y[0], y[1], y[2], y[3]))
                    }, c = function(t, n, r, o) {
                        var a, l, h, c, u, p, d = [];
                        if (o)
                            for (l = (t = [o].concat(t)).length; --l > -1;) "string" == typeof(p = t[l][n]) && "=" === p.charAt(1) && (t[l][n] = o[n] + Number(p.charAt(0) + p.substr(2)));
                        if ((a = t.length - 2) < 0) return d[0] = new s(t[0][n], 0, 0, t[0][n]), d;
                        for (l = 0; l < a; l++) h = t[l][n], c = t[l + 1][n], d[l] = new s(h, 0, 0, c), r && (u = t[l + 2][n], e[l] = (e[l] || 0) + (c - h) * (c - h), i[l] = (i[l] || 0) + (u - c) * (u - c));
                        return d[l] = new s(t[l][n], 0, 0, t[l + 1][n]), d
                    }, u = function(t, r, a, s, l, u) {
                        var p, d, f, m, v, g, y, _, x = {},
                            b = [],
                            w = u || t[0];
                        for (d in l = "string" == typeof l ? "," + l + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == r && (r = 1), t[0]) b.push(d);
                        if (t.length > 1) {
                            for (_ = t[t.length - 1], y = !0, p = b.length; --p > -1;)
                                if (d = b[p], Math.abs(w[d] - _[d]) > .05) {
                                    y = !1;
                                    break
                                }
                            y && (t = t.concat(), u && t.unshift(u), t.push(t[1]), u = t[t.length - 3])
                        }
                        for (e.length = i.length = n.length = 0, p = b.length; --p > -1;) d = b[p], o[d] = -1 !== l.indexOf("," + d + ","), x[d] = c(t, d, o[d], u);
                        for (p = e.length; --p > -1;) e[p] = Math.sqrt(e[p]), i[p] = Math.sqrt(i[p]);
                        if (!s) {
                            for (p = b.length; --p > -1;)
                                if (o[d])
                                    for (g = (f = x[b[p]]).length - 1, m = 0; m < g; m++) v = f[m + 1].da / i[m] + f[m].da / e[m] || 0, n[m] = (n[m] || 0) + v * v;
                            for (p = n.length; --p > -1;) n[p] = Math.sqrt(n[p])
                        }
                        for (p = b.length, m = a ? 4 : 1; --p > -1;) f = x[d = b[p]], h(f, r, a, s, o[d]), y && (f.splice(0, m), f.splice(f.length - m, m));
                        return x
                    }, p = function(t, e, i) {
                        for (var n, r, o, a, s, l, h, c, u, p, d, f = 1 / i, m = t.length; --m > -1;)
                            for (o = (p = t[m]).a, a = p.d - o, s = p.c - o, l = p.b - o, n = r = 0, c = 1; c <= i; c++) n = r - (r = ((h = f * c) * h * a + 3 * (u = 1 - h) * (h * s + u * l)) * h), e[d = m * i + c - 1] = (e[d] || 0) + n * n
                    }, d = r._gsDefine.plugin({
                        propName: "bezier",
                        priority: -1,
                        version: "1.3.8",
                        API: 2,
                        global: !0,
                        init: function(t, e, i) {
                            this._target = t, e instanceof Array && (e = {
                                values: e
                            }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                            var n, r, o, a, l, h = e.values || [],
                                c = {},
                                d = h[0],
                                f = e.autoRotate || i.vars.orientToBezier;
                            for (n in this._autoRotate = f ? f instanceof Array ? f : [
                                    ["x", "y", "rotation", !0 === f ? 0 : Number(f) || 0]
                                ] : null, d) this._props.push(n);
                            for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], c[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), l || c[n] !== h[0][n] && (l = c);
                            if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, l) : function(t, e, i) {
                                    var n, r, o, a, l, h, c, u, p, d, f, m = {},
                                        v = "cubic" === (e = e || "soft") ? 3 : 2,
                                        g = "soft" === e,
                                        y = [];
                                    if (g && i && (t = [i].concat(t)), null == t || t.length < v + 1) throw "invalid Bezier data";
                                    for (p in t[0]) y.push(p);
                                    for (h = y.length; --h > -1;) {
                                        for (m[p = y[h]] = l = [], d = 0, u = t.length, c = 0; c < u; c++) n = null == i ? t[c][p] : "string" == typeof(f = t[c][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && c > 1 && c < u - 1 && (l[d++] = (n + l[d - 2]) / 2), l[d++] = n;
                                        for (u = d - v + 1, d = 0, c = 0; c < u; c += v) n = l[c], r = l[c + 1], o = l[c + 2], a = 2 === v ? 0 : l[c + 3], l[d++] = f = 3 === v ? new s(n, r, o, a) : new s(n, (2 * r + n) / 3, (2 * r + o) / 3, o);
                                        l.length = d
                                    }
                                    return m
                                }(h, e.type, c), this._segCount = this._beziers[n].length, this._timeRes) {
                                var m = function(t, e) {
                                    var i, n, r, o, a = [],
                                        s = [],
                                        l = 0,
                                        h = 0,
                                        c = (e = e >> 0 || 6) - 1,
                                        u = [],
                                        d = [];
                                    for (i in t) p(t[i], a, e);
                                    for (r = a.length, n = 0; n < r; n++) l += Math.sqrt(a[n]), d[o = n % e] = l, o === c && (h += l, u[o = n / e >> 0] = d, s[o] = h, l = 0, d = []);
                                    return {
                                        length: h,
                                        lengths: s,
                                        segments: u
                                    }
                                }(this._beziers, this._timeRes);
                                this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                            }
                            if (f = this._autoRotate)
                                for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), o = f.length; --o > -1;) {
                                    for (a = 0; a < 3; a++) n = f[o][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                                    n = f[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                                }
                            return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                        },
                        set: function(e) {
                            var i, n, r, o, a, s, l, h, c, u, p = this._segCount,
                                d = this._func,
                                f = this._target,
                                m = e !== this._startRatio;
                            if (this._timeRes) {
                                if (c = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && r < p - 1) {
                                    for (h = p - 1; r < h && (this._l2 = c[++r]) <= e;);
                                    this._l1 = c[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                                } else if (e < this._l1 && r > 0) {
                                    for (; r > 0 && (this._l1 = c[--r]) >= e;);
                                    0 === r && e < this._l1 ? this._l1 = 0 : r++, this._l2 = c[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                }
                                if (i = r, e -= this._l1, r = this._si, e > this._s2 && r < u.length - 1) {
                                    for (h = u.length - 1; r < h && (this._s2 = u[++r]) <= e;);
                                    this._s1 = u[r - 1], this._si = r
                                } else if (e < this._s1 && r > 0) {
                                    for (; r > 0 && (this._s1 = u[--r]) >= e;);
                                    0 === r && e < this._s1 ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                                }
                                s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                            } else s = (e - (i = e < 0 ? 0 : e >= 1 ? p - 1 : p * e >> 0) * (1 / p)) * p;
                            for (n = 1 - s, r = this._props.length; --r > -1;) o = this._props[r], l = (s * s * (a = this._beziers[o][i]).da + 3 * n * (s * a.ca + n * a.ba)) * s + a.a, this._mod[o] && (l = this._mod[o](l, f)), d[o] ? f[o](l) : f[o] = l;
                            if (this._autoRotate) {
                                var v, g, y, _, x, b, w, T = this._autoRotate;
                                for (r = T.length; --r > -1;) o = T[r][2], b = T[r][3] || 0, w = !0 === T[r][4] ? 1 : t, a = this._beziers[T[r][0]], v = this._beziers[T[r][1]], a && v && (a = a[i], v = v[i], g = a.a + (a.b - a.a) * s, g += ((_ = a.b + (a.c - a.b) * s) - g) * s, _ += (a.c + (a.d - a.c) * s - _) * s, y = v.a + (v.b - v.a) * s, y += ((x = v.b + (v.c - v.b) * s) - y) * s, x += (v.c + (v.d - v.c) * s - x) * s, l = m ? Math.atan2(x - y, _ - g) * w + b : this._initialRotations[r], this._mod[o] && (l = this._mod[o](l, f)), d[o] ? f[o](l) : f[o] = l)
                            }
                        }
                    }), f = d.prototype, d.bezierThrough = u, d.cubicToQuadratic = l, d._autoCSS = !0, d.quadraticToCubic = function(t, e, i) {
                        return new s(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
                    }, d._cssRegister = function() {
                        var t = a.CSSPlugin;
                        if (t) {
                            var e = t._internals,
                                i = e._parseToProxy,
                                n = e._setPluginRatio,
                                r = e.CSSPropTween;
                            e._registerComplexSpecialProp("bezier", {
                                parser: function(t, e, o, a, s, l) {
                                    e instanceof Array && (e = {
                                        values: e
                                    }), l = new d;
                                    var h, c, u, p = e.values,
                                        f = p.length - 1,
                                        m = [],
                                        v = {};
                                    if (f < 0) return s;
                                    for (h = 0; h <= f; h++) u = i(t, p[h], a, s, l, f !== h), m[h] = u.end;
                                    for (c in e) v[c] = e[c];
                                    return v.values = m, (s = new r(t, "bezier", 0, 0, u.pt, 2)).data = u, s.plugin = l, s.setRatio = n, 0 === v.autoRotate && (v.autoRotate = !0), !v.autoRotate || v.autoRotate instanceof Array || (h = !0 === v.autoRotate ? 0 : Number(v.autoRotate), v.autoRotate = null != u.end.left ? [
                                        ["left", "top", "rotation", h, !1]
                                    ] : null != u.end.x && [
                                        ["x", "y", "rotation", h, !1]
                                    ]), v.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), l._onInitTween(u.proxy, v, a._tween), s
                                }
                            })
                        }
                    }, f._mod = function(t) {
                        for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
                    }, f._kill = function(t) {
                        var e, i, n = this._props;
                        for (e in this._beziers)
                            if (e in t)
                                for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
                        if (n = this._autoRotate)
                            for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
                        return this._super._kill.call(this, t)
                    }, r._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                        var i, n, o, a, s = function() {
                                t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                            },
                            l = r._gsDefine.globals,
                            h = {},
                            c = s.prototype = new t("css");
                        c.constructor = s, s.version = "1.20.5", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, c = "px", s.suffixMap = {
                            top: c,
                            right: c,
                            bottom: c,
                            left: c,
                            width: c,
                            height: c,
                            fontSize: c,
                            padding: c,
                            margin: c,
                            perspective: c,
                            lineHeight: ""
                        };
                        var u, p, d, f, m, v, g, y, _ = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            T = /(?:\d|\-|\+|=|#|\.)*/g,
                            E = /opacity *= *([^)]*)/i,
                            M = /opacity:([^;]*)/i,
                            S = /alpha\(opacity *=.+?\)/i,
                            A = /^(rgb|hsl)/,
                            C = /([A-Z])/g,
                            R = /-([a-z])/gi,
                            P = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            L = function(t, e) {
                                return e.toUpperCase()
                            },
                            O = /(?:Left|Right|Width)/i,
                            B = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            I = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            N = /,(?=[^\)]*(?:\(|$))/gi,
                            z = /[\s,\(]/i,
                            F = Math.PI / 180,
                            D = 180 / Math.PI,
                            U = {},
                            k = {
                                style: {}
                            },
                            V = r.document || {
                                createElement: function() {
                                    return k
                                }
                            },
                            H = function(t, e) {
                                return V.createElementNS ? V.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : V.createElement(t)
                            },
                            G = H("div"),
                            j = H("img"),
                            W = s._internals = {
                                _specialProps: h
                            },
                            q = (r.navigator || {}).userAgent || "",
                            X = function() {
                                var t = q.indexOf("Android"),
                                    e = H("a");
                                return d = -1 !== q.indexOf("Safari") && -1 === q.indexOf("Chrome") && (-1 === t || parseFloat(q.substr(t + 8, 2)) > 3), m = d && parseFloat(q.substr(q.indexOf("Version/") + 8, 2)) < 6, f = -1 !== q.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(q) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(q)) && (v = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                            }(),
                            Y = function(t) {
                                return E.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                            },
                            Z = function(t) {
                                r.console && console.log(t)
                            },
                            J = "",
                            K = "",
                            Q = function(t, e) {
                                var i, n, r = (e = e || G).style;
                                if (void 0 !== r[t]) return t;
                                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                                return n >= 0 ? (J = "-" + (K = 3 === n ? "ms" : i[n]).toLowerCase() + "-", K + t) : null
                            },
                            $ = ("undefined" != typeof window ? window : V.defaultView || {
                                getComputedStyle: function() {}
                            }).getComputedStyle,
                            tt = s.getStyle = function(t, e, i, n, r) {
                                var o;
                                return X || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || $(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(C, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : Y(t)
                            },
                            et = W.convertToPixels = function(t, i, n, r, o) {
                                if ("px" === r || !r && "lineHeight" !== i) return n;
                                if ("auto" === r || !n) return 0;
                                var a, l, h, c = O.test(i),
                                    u = t,
                                    p = G.style,
                                    d = n < 0,
                                    f = 1 === n;
                                if (d && (n = -n), f && (n *= 100), "lineHeight" !== i || r)
                                    if ("%" === r && -1 !== i.indexOf("border")) a = n / 100 * (c ? t.clientWidth : t.clientHeight);
                                    else {
                                        if (p.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) p[c ? "borderLeftWidth" : "borderTopWidth"] = n + r;
                                        else {
                                            if (u = t.parentNode || V.body, -1 !== tt(u, "display").indexOf("flex") && (p.position = "absolute"), l = u._gsCache, h = e.ticker.frame, l && c && l.time === h) return l.width * n / 100;
                                            p[c ? "width" : "height"] = n + r
                                        }
                                        u.appendChild(G), a = parseFloat(G[c ? "offsetWidth" : "offsetHeight"]), u.removeChild(G), c && "%" === r && !1 !== s.cacheWidths && ((l = u._gsCache = u._gsCache || {}).time = h, l.width = a / n * 100), 0 !== a || o || (a = et(t, i, n, r, !0))
                                    }
                                else l = $(t).lineHeight, t.style.lineHeight = n, a = parseFloat($(t).lineHeight), t.style.lineHeight = l;
                                return f && (a /= 100), d ? -a : a
                            },
                            it = W.calculateOffset = function(t, e, i) {
                                if ("absolute" !== tt(t, "position", i)) return 0;
                                var n = "left" === e ? "Left" : "Top",
                                    r = tt(t, "margin" + n, i);
                                return t["offset" + n] - (et(t, e, parseFloat(r), r.replace(T, "")) || 0)
                            },
                            nt = function(t, e) {
                                var i, n, r, o = {};
                                if (e = e || $(t, null))
                                    if (i = e.length)
                                        for (; --i > -1;) - 1 !== (r = e[i]).indexOf("-transform") && It !== r || (o[r.replace(R, L)] = e.getPropertyValue(r));
                                    else
                                        for (i in e) - 1 !== i.indexOf("Transform") && Bt !== i || (o[i] = e[i]);
                                else if (e = t.currentStyle || t.style)
                                    for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(R, L)] = e[i]);
                                return X || (o.opacity = Y(t)), n = Xt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, zt && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
                            },
                            rt = function(t, e, i, n, r) {
                                var o, a, s, l = {},
                                    h = t.style;
                                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(w, "") ? o : 0 : it(t, a), void 0 !== h[a] && (s = new _t(h, a, h[a], s))));
                                if (n)
                                    for (a in n) "className" !== a && (l[a] = n[a]);
                                return {
                                    difs: l,
                                    firstMPT: s
                                }
                            },
                            ot = {
                                width: ["Left", "Right"],
                                height: ["Top", "Bottom"]
                            },
                            at = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            st = function(t, e, i) {
                                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || $(t))[e] || 0;
                                if (t.getCTM && jt(t)) return t.getBBox()[e] || 0;
                                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                                    r = ot[e],
                                    o = r.length;
                                for (i = i || $(t, null); --o > -1;) n -= parseFloat(tt(t, "padding" + r[o], i, !0)) || 0, n -= parseFloat(tt(t, "border" + r[o] + "Width", i, !0)) || 0;
                                return n
                            },
                            lt = function(t, e) {
                                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                                null != t && "" !== t || (t = "0 0");
                                var i, n = t.split(" "),
                                    r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                                    o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                                if (n.length > 3 && !e) {
                                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(lt(n[i]));
                                    return t.join(",")
                                }
                                return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(w, "")), e.oy = parseFloat(o.replace(w, "")), e.v = t), e || t
                            },
                            ht = function(t, e) {
                                return "function" == typeof t && (t = t(y, g)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                            },
                            ct = function(t, e) {
                                return "function" == typeof t && (t = t(y, g)), null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                            },
                            ut = function(t, e, i, n) {
                                var r, o, a, s, l;
                                return "function" == typeof t && (t = t(y, g)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, o = t.split("_"), a = ((l = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : D) - (l ? 0 : e), o.length && (n && (n[i] = e + a), -1 !== t.indexOf("short") && (a %= r) != a % (r / 2) && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), s = e + a), s < 1e-6 && s > -1e-6 && (s = 0), s
                            },
                            pt = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0]
                            },
                            dt = function(t, e, i) {
                                return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                            },
                            ft = s.parseColor = function(t, e) {
                                var i, n, r, o, a, s, l, h, c, u, p;
                                if (t)
                                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                                    else {
                                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), pt[t]) i = pt[t];
                                        else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (o = t.charAt(3)) + o), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                                        else if ("hsl" === t.substr(0, 3))
                                            if (i = p = t.match(_), e) {
                                                if (-1 !== t.indexOf("=")) return t.match(x)
                                            } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (s + 1) : l + s - l * s), i.length > 3 && (i[3] = Number(i[3])), i[0] = dt(a + 1 / 3, n, r), i[1] = dt(a, n, r), i[2] = dt(a - 1 / 3, n, r);
                                        else i = t.match(_) || pt.transparent;
                                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                                    }
                                else i = pt.black;
                                return e && !p && (n = i[0] / 255, r = i[1] / 255, o = i[2] / 255, l = ((h = Math.max(n, r, o)) + (c = Math.min(n, r, o))) / 2, h === c ? a = s = 0 : (u = h - c, s = l > .5 ? u / (2 - h - c) : u / (h + c), a = h === n ? (r - o) / u + (r < o ? 6 : 0) : h === r ? (o - n) / u + 2 : (n - r) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
                            },
                            mt = function(t, e) {
                                var i, n, r, o = t.match(vt) || [],
                                    a = 0,
                                    s = "";
                                if (!o.length) return t;
                                for (i = 0; i < o.length; i++) n = o[i], a += (r = t.substr(a, t.indexOf(n, a) - a)).length + n.length, 3 === (n = ft(n, e)).length && n.push(1), s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                                return s + t.substr(a)
                            },
                            vt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                        for (c in pt) vt += "|" + c + "\\b";
                        vt = new RegExp(vt + ")", "gi"), s.colorStringFilter = function(t) {
                            var e, i = t[0] + " " + t[1];
                            vt.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = mt(t[0], e), t[1] = mt(t[1], e)), vt.lastIndex = 0
                        }, e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
                        var gt = function(t, e, i, n) {
                                if (null == t) return function(t) {
                                    return t
                                };
                                var r, o = e ? (t.match(vt) || [""])[0] : "",
                                    a = t.split(o).join("").match(b) || [],
                                    s = t.substr(0, t.indexOf(a[0])),
                                    l = ")" === t.charAt(t.length - 1) ? ")" : "",
                                    h = -1 !== t.indexOf(" ") ? " " : ",",
                                    c = a.length,
                                    u = c > 0 ? a[0].replace(_, "") : "";
                                return c ? r = e ? function(t) {
                                    var e, p, d, f;
                                    if ("number" == typeof t) t += u;
                                    else if (n && N.test(t)) {
                                        for (f = t.replace(N, "|").split("|"), d = 0; d < f.length; d++) f[d] = r(f[d]);
                                        return f.join(",")
                                    }
                                    if (e = (t.match(vt) || [o])[0], d = (p = t.split(e).join("").match(b) || []).length, c > d--)
                                        for (; ++d < c;) p[d] = i ? p[(d - 1) / 2 | 0] : a[d];
                                    return s + p.join(h) + h + e + l + (-1 !== t.indexOf("inset") ? " inset" : "")
                                } : function(t) {
                                    var e, o, p;
                                    if ("number" == typeof t) t += u;
                                    else if (n && N.test(t)) {
                                        for (o = t.replace(N, "|").split("|"), p = 0; p < o.length; p++) o[p] = r(o[p]);
                                        return o.join(",")
                                    }
                                    if (p = (e = t.match(b) || []).length, c > p--)
                                        for (; ++p < c;) e[p] = i ? e[(p - 1) / 2 | 0] : a[p];
                                    return s + e.join(h) + l
                                } : function(t) {
                                    return t
                                }
                            },
                            yt = function(t) {
                                return t = t.split(","),
                                    function(e, i, n, r, o, a, s) {
                                        var l, h = (i + "").split(" ");
                                        for (s = {}, l = 0; l < 4; l++) s[t[l]] = h[l] = h[l] || h[(l - 1) / 2 >> 0];
                                        return r.parse(e, s, o, a)
                                    }
                            },
                            _t = (W._setPluginRatio = function(t) {
                                this.plugin.setRatio(t);
                                for (var e, i, n, r, o, a = this.data, s = a.proxy, l = a.firstMPT; l;) e = s[l.v], l.r ? e = l.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), l.t[l.p] = e, l = l._next;
                                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t)
                                    for (l = a.firstMPT, o = 1 === t ? "e" : "b"; l;) {
                                        if ((i = l.t).type) {
                                            if (1 === i.type) {
                                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                                i[o] = r
                                            }
                                        } else i[o] = i.s + i.xs0;
                                        l = l._next
                                    }
                            }, function(t, e, i, n, r) {
                                this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
                            }),
                            xt = (W._parseToProxy = function(t, e, i, n, r, o) {
                                var a, s, l, h, c, u = n,
                                    p = {},
                                    d = {},
                                    f = i._transform,
                                    m = U;
                                for (i._transform = null, U = e, n = c = i.parse(t, e, n, r), U = m, o && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                                    if (n.type <= 1 && (d[s = n.p] = n.s + n.c, p[s] = n.s, o || (h = new _t(n, "s", s, h, n.r), n.c = 0), 1 === n.type))
                                        for (a = n.l; --a > 0;) l = "xn" + a, d[s = n.p + "_" + l] = n.data[l], p[s] = n[l], o || (h = new _t(n, l, s, h, n.rxp[l]));
                                    n = n._next
                                }
                                return {
                                    proxy: p,
                                    end: d,
                                    firstMPT: h,
                                    pt: c
                                }
                            }, W.CSSPropTween = function(t, e, n, r, o, s, l, h, c, u, p) {
                                this.t = t, this.p = e, this.s = n, this.c = r, this.n = l || e, t instanceof xt || a.push(this.n), this.r = h ? "function" == typeof h ? h : Math.round : h, this.type = s || 0, c && (this.pr = c, i = !0), this.b = void 0 === u ? n : u, this.e = void 0 === p ? n + r : p, o && (this._next = o, o._prev = this)
                            }),
                            bt = function(t, e, i, n, r, o) {
                                var a = new xt(t, e, i, n - i, r, -1, o);
                                return a.b = i, a.e = a.xs0 = n, a
                            },
                            wt = s.parseComplex = function(t, e, i, n, r, o, a, l, h, c) {
                                i = i || o || "", "function" == typeof n && (n = n(y, g)), a = new xt(t, e, 0, 0, a, c ? 2 : 1, null, !1, l, i, n), n += "", r && vt.test(n + i) && (n = [i, n], s.colorStringFilter(n), i = n[0], n = n[1]);
                                var p, d, f, m, v, b, w, T, E, M, S, A, C, R = i.split(", ").join(",").split(" "),
                                    P = n.split(", ").join(",").split(" "),
                                    L = R.length,
                                    O = !1 !== u;
                                for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (R = R.join(" ").replace(N, ", ").split(" "), P = P.join(" ").replace(N, ", ").split(" ")) : (R = R.join(" ").split(",").join(", ").split(" "), P = P.join(" ").split(",").join(", ").split(" ")), L = R.length), L !== P.length && (L = (R = (o || "").split(" ")).length), a.plugin = h, a.setRatio = c, vt.lastIndex = 0, p = 0; p < L; p++)
                                    if (m = R[p], v = P[p] + "", (T = parseFloat(m)) || 0 === T) a.appendXtra("", T, ht(v, T), v.replace(x, ""), !(!O || -1 === v.indexOf("px")) && Math.round, !0);
                                    else if (r && vt.test(m)) A = ")" + ((A = v.indexOf(")") + 1) ? v.substr(A) : ""), C = -1 !== v.indexOf("hsl") && X, M = v, m = ft(m, C), v = ft(v, C), (E = m.length + v.length > 6) && !X && 0 === v[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(P[p]).join("transparent")) : (X || (E = !1), C ? a.appendXtra(M.substr(0, M.indexOf("hsl")) + (E ? "hsla(" : "hsl("), m[0], ht(v[0], m[0]), ",", !1, !0).appendXtra("", m[1], ht(v[1], m[1]), "%,", !1).appendXtra("", m[2], ht(v[2], m[2]), E ? "%," : "%" + A, !1) : a.appendXtra(M.substr(0, M.indexOf("rgb")) + (E ? "rgba(" : "rgb("), m[0], v[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], v[1] - m[1], ",", Math.round).appendXtra("", m[2], v[2] - m[2], E ? "," : A, Math.round), E && (m = m.length < 4 ? 1 : m[3], a.appendXtra("", m, (v.length < 4 ? 1 : v[3]) - m, A, !1))), vt.lastIndex = 0;
                                else if (b = m.match(_)) {
                                    if (!(w = v.match(x)) || w.length !== b.length) return a;
                                    for (f = 0, d = 0; d < b.length; d++) S = b[d], M = m.indexOf(S, f), a.appendXtra(m.substr(f, M - f), Number(S), ht(w[d], S), "", !(!O || "px" !== m.substr(M + S.length, 2)) && Math.round, 0 === d), f = M + S.length;
                                    a["xs" + a.l] += m.substr(f)
                                } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + v : v;
                                if (-1 !== n.indexOf("=") && a.data) {
                                    for (A = a.xs0 + a.data.s, p = 1; p < a.l; p++) A += a["xs" + p] + a.data["xn" + p];
                                    a.e = A + a["xs" + p]
                                }
                                return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                            },
                            Tt = 9;
                        for ((c = xt.prototype).l = c.pr = 0; --Tt > 0;) c["xn" + Tt] = 0, c["xs" + Tt] = "";
                        c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function(t, e, i, n, r, o) {
                            var a = this,
                                s = a.l;
                            return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", s > 0 ? (a.data["xn" + s] = e + i, a.rxp["xn" + s] = r, a["xn" + s] = e, a.plugin || (a.xfirst = new xt(a, "xn" + s, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                s: e + i
                            }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + s] += e + (n || ""), a)
                        };
                        var Et = function(t, e) {
                                e = e || {}, this.p = e.prefix && Q(t) || t, h[t] = h[this.p] = this, this.format = e.formatter || gt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                            },
                            Mt = W._registerComplexSpecialProp = function(t, e, i) {
                                "object" != typeof e && (e = {
                                    parser: i
                                });
                                var n, r = t.split(","),
                                    o = e.defaultValue;
                                for (i = i || [o], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, new Et(r[n], e)
                            },
                            St = W._registerPluginProp = function(t) {
                                if (!h[t]) {
                                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                                    Mt(t, {
                                        parser: function(t, i, n, r, o, a, s) {
                                            var c = l.com.greensock.plugins[e];
                                            return c ? (c._cssRegister(), h[n].parse(t, i, n, r, o, a, s)) : (Z("Error: " + e + " js file not loaded."), o)
                                        }
                                    })
                                }
                            };
                        (c = Et.prototype).parseComplex = function(t, e, i, n, r, o) {
                            var a, s, l, h, c, u, p = this.keyword;
                            if (this.multi && (N.test(i) || N.test(e) ? (s = e.replace(N, "|").split("|"), l = i.replace(N, "|").split("|")) : p && (s = [e], l = [i])), l) {
                                for (h = l.length > s.length ? l.length : s.length, a = 0; a < h; a++) e = s[a] = s[a] || this.dflt, i = l[a] = l[a] || this.dflt, p && (c = e.indexOf(p)) !== (u = i.indexOf(p)) && (-1 === u ? s[a] = s[a].split(p).join("") : -1 === c && (s[a] += " " + p));
                                e = s.join(", "), i = l.join(", ")
                            }
                            return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, o)
                        }, c.parse = function(t, e, i, n, r, a, s) {
                            return this.parseComplex(t.style, this.format(tt(t, this.p, o, !1, this.dflt)), this.format(e), r, a)
                        }, s.registerSpecialProp = function(t, e, i) {
                            Mt(t, {
                                parser: function(t, n, r, o, a, s, l) {
                                    var h = new xt(t, r, 0, 0, a, 2, r, !1, i);
                                    return h.plugin = s, h.setRatio = e(t, n, o._tween, r), h
                                },
                                priority: i
                            })
                        }, s.useSVGTransformAttr = !0;
                        var At, Ct, Rt, Pt, Lt, Ot = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            Bt = Q("transform"),
                            It = J + "transform",
                            Nt = Q("transformOrigin"),
                            zt = null !== Q("perspective"),
                            Ft = W.Transform = function() {
                                this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = !(!1 === s.defaultForce3D || !zt) && (s.defaultForce3D || "auto")
                            },
                            Dt = r.SVGElement,
                            Ut = function(t, e, i) {
                                var n, r = V.createElementNS("http://www.w3.org/2000/svg", t),
                                    o = /([a-z])([A-Z])/g;
                                for (n in i) r.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
                                return e.appendChild(r), r
                            },
                            kt = V.documentElement || {},
                            Vt = (Lt = v || /Android/i.test(q) && !r.chrome, V.createElementNS && !Lt && (Pt = (Rt = Ut("rect", Ct = Ut("svg", kt), {
                                width: 100,
                                height: 50,
                                x: 100
                            })).getBoundingClientRect().width, Rt.style[Nt] = "50% 50%", Rt.style[Bt] = "scaleX(0.5)", Lt = Pt === Rt.getBoundingClientRect().width && !(f && zt), kt.removeChild(Ct)), Lt),
                            Ht = function(t, e, i, n, r, o) {
                                var a, l, h, c, u, p, d, f, m, v, g, y, _, x, b = t._gsTransform,
                                    w = qt(t, !0);
                                b && (_ = b.xOrigin, x = b.yOrigin), (!n || (a = n.split(" ")).length < 2) && (0 === (d = t.getBBox()).x && 0 === d.y && d.width + d.height === 0 && (d = {
                                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                                    width: 0,
                                    height: 0
                                }), a = [(-1 !== (e = lt(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * d.width : parseFloat(e[0])) + d.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * d.height : parseFloat(e[1])) + d.y]), i.xOrigin = c = parseFloat(a[0]), i.yOrigin = u = parseFloat(a[1]), n && w !== Wt && (p = w[0], d = w[1], f = w[2], m = w[3], v = w[4], g = w[5], (y = p * m - d * f) && (l = c * (m / y) + u * (-f / y) + (f * g - m * v) / y, h = c * (-d / y) + u * (p / y) - (p * g - d * v) / y, c = i.xOrigin = a[0] = l, u = i.yOrigin = a[1] = h)), b && (o && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== s.defaultSmoothOrigin ? (l = c - _, h = u - x, b.xOffset += l * w[0] + h * w[2] - l, b.yOffset += l * w[1] + h * w[3] - h) : b.xOffset = b.yOffset = 0), o || t.setAttribute("data-svg-origin", a.join(" "))
                            },
                            Gt = function(t) {
                                var e, i = H("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                    n = this.parentNode,
                                    r = this.nextSibling,
                                    o = this.style.cssText;
                                if (kt.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Gt
                                } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                                return r ? n.insertBefore(this, r) : n.appendChild(this), kt.removeChild(i), this.style.cssText = o, e
                            },
                            jt = function(t) {
                                return !(!Dt || !t.getCTM || t.parentNode && !t.ownerSVGElement || ! function(t) {
                                    try {
                                        return t.getBBox()
                                    } catch (e) {
                                        return Gt.call(t, !0)
                                    }
                                }(t))
                            },
                            Wt = [1, 0, 0, 1, 0, 0],
                            qt = function(t, e) {
                                var i, n, r, o, a, s, l = t._gsTransform || new Ft,
                                    h = t.style;
                                if (Bt ? n = tt(t, It, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(B)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !Bt || !(s = !$(t) || "none" === $(t).display) && t.parentNode || (s && (o = h.display, h.display = "block"), t.parentNode || (a = 1, kt.appendChild(t)), i = !(n = tt(t, It, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? h.display = o : s && Kt(h, "display"), a && kt.removeChild(t)), (l.svg || t.getCTM && jt(t)) && (i && -1 !== (h[Bt] + "").indexOf("matrix") && (n = h[Bt], i = 0), r = t.getAttribute("transform"), i && r && (n = "matrix(" + (r = t.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return Wt;
                                for (r = (n || "").match(_) || [], Tt = r.length; --Tt > -1;) o = Number(r[Tt]), r[Tt] = (a = o - (o |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + o : o;
                                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                            },
                            Xt = W.getTransform = function(t, i, n, r) {
                                if (t._gsTransform && n && !r) return t._gsTransform;
                                var o, a, l, h, c, u, p = n && t._gsTransform || new Ft,
                                    d = p.scaleX < 0,
                                    f = zt && (parseFloat(tt(t, Nt, i, !1, "0 0 0").split(" ")[2]) || p.zOrigin) || 0,
                                    m = parseFloat(s.defaultTransformPerspective) || 0;
                                if (p.svg = !(!t.getCTM || !jt(t)), p.svg && (Ht(t, tt(t, Nt, i, !1, "50% 50%") + "", p, t.getAttribute("data-svg-origin")), At = s.useSVGTransformAttr || Vt), (o = qt(t)) !== Wt) {
                                    if (16 === o.length) {
                                        var v, g, y, _, x, b = o[0],
                                            w = o[1],
                                            T = o[2],
                                            E = o[3],
                                            M = o[4],
                                            S = o[5],
                                            A = o[6],
                                            C = o[7],
                                            R = o[8],
                                            P = o[9],
                                            L = o[10],
                                            O = o[12],
                                            B = o[13],
                                            I = o[14],
                                            N = o[11],
                                            z = Math.atan2(A, L);
                                        p.zOrigin && (O = R * (I = -p.zOrigin) - o[12], B = P * I - o[13], I = L * I + p.zOrigin - o[14]), p.rotationX = z * D, z && (v = M * (_ = Math.cos(-z)) + R * (x = Math.sin(-z)), g = S * _ + P * x, y = A * _ + L * x, R = M * -x + R * _, P = S * -x + P * _, L = A * -x + L * _, N = C * -x + N * _, M = v, S = g, A = y), z = Math.atan2(-T, L), p.rotationY = z * D, z && (g = w * (_ = Math.cos(-z)) - P * (x = Math.sin(-z)), y = T * _ - L * x, P = w * x + P * _, L = T * x + L * _, N = E * x + N * _, b = v = b * _ - R * x, w = g, T = y), z = Math.atan2(w, b), p.rotation = z * D, z && (v = b * (_ = Math.cos(z)) + w * (x = Math.sin(z)), g = M * _ + S * x, y = R * _ + P * x, w = w * _ - b * x, S = S * _ - M * x, P = P * _ - R * x, b = v, M = g, R = y), p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0, p.rotationY = 180 - p.rotationY), z = Math.atan2(M, S), p.scaleX = (1e5 * Math.sqrt(b * b + w * w + T * T) + .5 | 0) / 1e5, p.scaleY = (1e5 * Math.sqrt(S * S + A * A) + .5 | 0) / 1e5, p.scaleZ = (1e5 * Math.sqrt(R * R + P * P + L * L) + .5 | 0) / 1e5, b /= p.scaleX, M /= p.scaleY, w /= p.scaleX, S /= p.scaleY, Math.abs(z) > 2e-5 ? (p.skewX = z * D, M = 0, "simple" !== p.skewType && (p.scaleY *= 1 / Math.cos(z))) : p.skewX = 0, p.perspective = N ? 1 / (N < 0 ? -N : N) : 0, p.x = O, p.y = B, p.z = I, p.svg && (p.x -= p.xOrigin - (p.xOrigin * b - p.yOrigin * M), p.y -= p.yOrigin - (p.yOrigin * w - p.xOrigin * S))
                                    } else if (!zt || r || !o.length || p.x !== o[4] || p.y !== o[5] || !p.rotationX && !p.rotationY) {
                                        var F = o.length >= 6,
                                            U = F ? o[0] : 1,
                                            k = o[1] || 0,
                                            V = o[2] || 0,
                                            H = F ? o[3] : 1;
                                        p.x = o[4] || 0, p.y = o[5] || 0, l = Math.sqrt(U * U + k * k), h = Math.sqrt(H * H + V * V), c = U || k ? Math.atan2(k, U) * D : p.rotation || 0, u = V || H ? Math.atan2(V, H) * D + c : p.skewX || 0, p.scaleX = l, p.scaleY = h, p.rotation = c, p.skewX = u, zt && (p.rotationX = p.rotationY = p.z = 0, p.perspective = m, p.scaleZ = 1), p.svg && (p.x -= p.xOrigin - (p.xOrigin * U + p.yOrigin * V), p.y -= p.yOrigin - (p.xOrigin * k + p.yOrigin * H))
                                    }
                                    for (a in Math.abs(p.skewX) > 90 && Math.abs(p.skewX) < 270 && (d ? (p.scaleX *= -1, p.skewX += p.rotation <= 0 ? 180 : -180, p.rotation += p.rotation <= 0 ? 180 : -180) : (p.scaleY *= -1, p.skewX += p.skewX <= 0 ? 180 : -180)), p.zOrigin = f, p) p[a] < 2e-5 && p[a] > -2e-5 && (p[a] = 0)
                                }
                                return n && (t._gsTransform = p, p.svg && (At && t.style[Bt] ? e.delayedCall(.001, function() {
                                    Kt(t.style, Bt)
                                }) : !At && t.getAttribute("transform") && e.delayedCall(.001, function() {
                                    t.removeAttribute("transform")
                                }))), p
                            },
                            Yt = function(t) {
                                var e, i, n = this.data,
                                    r = -n.rotation * F,
                                    o = r + n.skewX * F,
                                    a = (Math.cos(r) * n.scaleX * 1e5 | 0) / 1e5,
                                    s = (Math.sin(r) * n.scaleX * 1e5 | 0) / 1e5,
                                    l = (Math.sin(o) * -n.scaleY * 1e5 | 0) / 1e5,
                                    h = (Math.cos(o) * n.scaleY * 1e5 | 0) / 1e5,
                                    c = this.t.style,
                                    u = this.t.currentStyle;
                                if (u) {
                                    i = s, s = -l, l = -i, e = u.filter, c.filter = "";
                                    var p, d, f = this.t.offsetWidth,
                                        m = this.t.offsetHeight,
                                        g = "absolute" !== u.position,
                                        y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + s + ", M21=" + l + ", M22=" + h,
                                        _ = n.x + f * n.xPercent / 100,
                                        x = n.y + m * n.yPercent / 100;
                                    if (null != n.ox && (_ += (p = (n.oxp ? f * n.ox * .01 : n.ox) - f / 2) - (p * a + (d = (n.oyp ? m * n.oy * .01 : n.oy) - m / 2) * s), x += d - (p * l + d * h)), y += g ? ", Dx=" + ((p = f / 2) - (p * a + (d = m / 2) * s) + _) + ", Dy=" + (d - (p * l + d * h) + x) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = e.replace(I, y) : c.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === s && 0 === l && 1 === h && (g && -1 === y.indexOf("Dx=0, Dy=0") || E.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && c.removeAttribute("filter")), !g) {
                                        var b, w, M, S = v < 8 ? 1 : -1;
                                        for (p = n.ieOffsetX || 0, d = n.ieOffsetY || 0, n.ieOffsetX = Math.round((f - ((a < 0 ? -a : a) * f + (s < 0 ? -s : s) * m)) / 2 + _), n.ieOffsetY = Math.round((m - ((h < 0 ? -h : h) * m + (l < 0 ? -l : l) * f)) / 2 + x), Tt = 0; Tt < 4; Tt++) M = (i = -1 !== (b = u[w = at[Tt]]).indexOf("px") ? parseFloat(b) : et(this.t, w, parseFloat(b), b.replace(T, "")) || 0) !== n[w] ? Tt < 2 ? -n.ieOffsetX : -n.ieOffsetY : Tt < 2 ? p - n.ieOffsetX : d - n.ieOffsetY, c[w] = (n[w] = Math.round(i - M * (0 === Tt || 2 === Tt ? 1 : S))) + "px"
                                    }
                                }
                            },
                            Zt = W.set3DTransformRatio = W.setTransformRatio = function(t) {
                                var e, i, n, r, o, a, s, l, h, c, u, p, d, m, v, g, y, _, x, b, w, T = this.data,
                                    E = this.t.style,
                                    M = T.rotation,
                                    S = T.rotationX,
                                    A = T.rotationY,
                                    C = T.scaleX,
                                    R = T.scaleY,
                                    P = T.scaleZ,
                                    L = T.x,
                                    O = T.y,
                                    B = T.z,
                                    I = T.svg,
                                    N = T.perspective,
                                    z = T.force3D,
                                    D = T.skewY,
                                    U = T.skewX;
                                if (D && (U += D, M += D), !((1 !== t && 0 !== t || "auto" !== z || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && z || B || N || A || S || 1 !== P) || At && I || !zt) M || U || I ? (M *= F, b = U * F, w = 1e5, i = Math.cos(M) * C, o = Math.sin(M) * C, n = Math.sin(M - b) * -R, a = Math.cos(M - b) * R, b && "simple" === T.skewType && (e = Math.tan(b - D * F), n *= e = Math.sqrt(1 + e * e), a *= e, D && (e = Math.tan(D * F), i *= e = Math.sqrt(1 + e * e), o *= e)), I && (L += T.xOrigin - (T.xOrigin * i + T.yOrigin * n) + T.xOffset, O += T.yOrigin - (T.xOrigin * o + T.yOrigin * a) + T.yOffset, At && (T.xPercent || T.yPercent) && (v = this.t.getBBox(), L += .01 * T.xPercent * v.width, O += .01 * T.yPercent * v.height), L < (v = 1e-6) && L > -v && (L = 0), O < v && O > -v && (O = 0)), x = (i * w | 0) / w + "," + (o * w | 0) / w + "," + (n * w | 0) / w + "," + (a * w | 0) / w + "," + L + "," + O + ")", I && At ? this.t.setAttribute("transform", "matrix(" + x) : E[Bt] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + x) : E[Bt] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + C + ",0,0," + R + "," + L + "," + O + ")";
                                else {
                                    if (f && (C < (v = 1e-4) && C > -v && (C = P = 2e-5), R < v && R > -v && (R = P = 2e-5), !N || T.z || T.rotationX || T.rotationY || (N = 0)), M || U) M *= F, g = i = Math.cos(M), y = o = Math.sin(M), U && (M -= U * F, g = Math.cos(M), y = Math.sin(M), "simple" === T.skewType && (e = Math.tan((U - D) * F), g *= e = Math.sqrt(1 + e * e), y *= e, T.skewY && (e = Math.tan(D * F), i *= e = Math.sqrt(1 + e * e), o *= e))), n = -y, a = g;
                                    else {
                                        if (!(A || S || 1 !== P || N || I)) return void(E[Bt] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) translate3d(" : "translate3d(") + L + "px," + O + "px," + B + "px)" + (1 !== C || 1 !== R ? " scale(" + C + "," + R + ")" : ""));
                                        i = a = 1, n = o = 0
                                    }
                                    c = 1, r = s = l = h = u = p = 0, d = N ? -1 / N : 0, m = T.zOrigin, v = 1e-6, (M = A * F) && (g = Math.cos(M), l = -(y = Math.sin(M)), u = d * -y, r = i * y, s = o * y, c = g, d *= g, i *= g, o *= g), (M = S * F) && (e = n * (g = Math.cos(M)) + r * (y = Math.sin(M)), _ = a * g + s * y, h = c * y, p = d * y, r = n * -y + r * g, s = a * -y + s * g, c *= g, d *= g, n = e, a = _), 1 !== P && (r *= P, s *= P, c *= P, d *= P), 1 !== R && (n *= R, a *= R, h *= R, p *= R), 1 !== C && (i *= C, o *= C, l *= C, u *= C), (m || I) && (m && (L += r * -m, O += s * -m, B += c * -m + m), I && (L += T.xOrigin - (T.xOrigin * i + T.yOrigin * n) + T.xOffset, O += T.yOrigin - (T.xOrigin * o + T.yOrigin * a) + T.yOffset), L < v && L > -v && (L = "0"), O < v && O > -v && (O = "0"), B < v && B > -v && (B = 0)), x = T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < v && i > -v ? "0" : i) + "," + (o < v && o > -v ? "0" : o) + "," + (l < v && l > -v ? "0" : l), x += "," + (u < v && u > -v ? "0" : u) + "," + (n < v && n > -v ? "0" : n) + "," + (a < v && a > -v ? "0" : a), S || A || 1 !== P ? (x += "," + (h < v && h > -v ? "0" : h) + "," + (p < v && p > -v ? "0" : p) + "," + (r < v && r > -v ? "0" : r), x += "," + (s < v && s > -v ? "0" : s) + "," + (c < v && c > -v ? "0" : c) + "," + (d < v && d > -v ? "0" : d) + ",") : x += ",0,0,0,0,1,0,", x += L + "," + O + "," + B + "," + (N ? 1 + -B / N : 1) + ")", E[Bt] = x
                                }
                            };
                        (c = Ft.prototype).x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, Mt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                            parser: function(t, e, i, n, r, a, l) {
                                if (n._lastParsedTransform === l) return r;
                                n._lastParsedTransform = l;
                                var h, c = l.scale && "function" == typeof l.scale ? l.scale : 0;
                                "function" == typeof l[i] && (h = l[i], l[i] = e), c && (l.scale = c(y, t));
                                var u, p, d, f, m, v, _, x, b, w = t._gsTransform,
                                    T = t.style,
                                    E = Ot.length,
                                    M = l,
                                    S = {},
                                    A = Xt(t, o, !0, M.parseTransform),
                                    C = M.transform && ("function" == typeof M.transform ? M.transform(y, g) : M.transform);
                                if (A.skewType = M.skewType || A.skewType || s.defaultSkewType, n._transform = A, C && "string" == typeof C && Bt)(p = G.style)[Bt] = C, p.display = "block", p.position = "absolute", -1 !== C.indexOf("%") && (p.width = tt(t, "width"), p.height = tt(t, "height")), V.body.appendChild(G), u = Xt(G, null, !1), "simple" === A.skewType && (u.scaleY *= Math.cos(u.skewX * F)), A.svg && (v = A.xOrigin, _ = A.yOrigin, u.x -= A.xOffset, u.y -= A.yOffset, (M.transformOrigin || M.svgOrigin) && (C = {}, Ht(t, lt(M.transformOrigin), C, M.svgOrigin, M.smoothOrigin, !0), v = C.xOrigin, _ = C.yOrigin, u.x -= C.xOffset - A.xOffset, u.y -= C.yOffset - A.yOffset), (v || _) && (x = qt(G, !0), u.x -= v - (v * x[0] + _ * x[2]), u.y -= _ - (v * x[1] + _ * x[3]))), V.body.removeChild(G), u.perspective || (u.perspective = A.perspective), null != M.xPercent && (u.xPercent = ct(M.xPercent, A.xPercent)), null != M.yPercent && (u.yPercent = ct(M.yPercent, A.yPercent));
                                else if ("object" == typeof M) {
                                    if (u = {
                                            scaleX: ct(null != M.scaleX ? M.scaleX : M.scale, A.scaleX),
                                            scaleY: ct(null != M.scaleY ? M.scaleY : M.scale, A.scaleY),
                                            scaleZ: ct(M.scaleZ, A.scaleZ),
                                            x: ct(M.x, A.x),
                                            y: ct(M.y, A.y),
                                            z: ct(M.z, A.z),
                                            xPercent: ct(M.xPercent, A.xPercent),
                                            yPercent: ct(M.yPercent, A.yPercent),
                                            perspective: ct(M.transformPerspective, A.perspective)
                                        }, null != (m = M.directionalRotation))
                                        if ("object" == typeof m)
                                            for (p in m) M[p] = m[p];
                                        else M.rotation = m;
                                    "string" == typeof M.x && -1 !== M.x.indexOf("%") && (u.x = 0, u.xPercent = ct(M.x, A.xPercent)), "string" == typeof M.y && -1 !== M.y.indexOf("%") && (u.y = 0, u.yPercent = ct(M.y, A.yPercent)), u.rotation = ut("rotation" in M ? M.rotation : "shortRotation" in M ? M.shortRotation + "_short" : "rotationZ" in M ? M.rotationZ : A.rotation, A.rotation, "rotation", S), zt && (u.rotationX = ut("rotationX" in M ? M.rotationX : "shortRotationX" in M ? M.shortRotationX + "_short" : A.rotationX || 0, A.rotationX, "rotationX", S), u.rotationY = ut("rotationY" in M ? M.rotationY : "shortRotationY" in M ? M.shortRotationY + "_short" : A.rotationY || 0, A.rotationY, "rotationY", S)), u.skewX = ut(M.skewX, A.skewX), u.skewY = ut(M.skewY, A.skewY)
                                }
                                for (zt && null != M.force3D && (A.force3D = M.force3D, f = !0), (d = A.force3D || A.z || A.rotationX || A.rotationY || u.z || u.rotationX || u.rotationY || u.perspective) || null == M.scale || (u.scaleZ = 1); --E > -1;)((C = u[b = Ot[E]] - A[b]) > 1e-6 || C < -1e-6 || null != M[b] || null != U[b]) && (f = !0, r = new xt(A, b, A[b], C, r), b in S && (r.e = S[b]), r.xs0 = 0, r.plugin = a, n._overwriteProps.push(r.n));
                                return C = M.transformOrigin, A.svg && (C || M.svgOrigin) && (v = A.xOffset, _ = A.yOffset, Ht(t, lt(C), u, M.svgOrigin, M.smoothOrigin), r = bt(A, "xOrigin", (w ? A : u).xOrigin, u.xOrigin, r, "transformOrigin"), r = bt(A, "yOrigin", (w ? A : u).yOrigin, u.yOrigin, r, "transformOrigin"), v === A.xOffset && _ === A.yOffset || (r = bt(A, "xOffset", w ? v : A.xOffset, A.xOffset, r, "transformOrigin"), r = bt(A, "yOffset", w ? _ : A.yOffset, A.yOffset, r, "transformOrigin")), C = "0px 0px"), (C || zt && d && A.zOrigin) && (Bt ? (f = !0, b = Nt, C = (C || tt(t, b, o, !1, "50% 50%")) + "", (r = new xt(T, b, 0, 0, r, -1, "transformOrigin")).b = T[b], r.plugin = a, zt ? (p = A.zOrigin, C = C.split(" "), A.zOrigin = (C.length > 2 && (0 === p || "0px" !== C[2]) ? parseFloat(C[2]) : p) || 0, r.xs0 = r.e = C[0] + " " + (C[1] || "50%") + " 0px", (r = new xt(A, "zOrigin", 0, 0, r, -1, r.n)).b = p, r.xs0 = r.e = A.zOrigin) : r.xs0 = r.e = C) : lt(C + "", A)), f && (n._transformType = A.svg && At || !d && 3 !== this._transformType ? 2 : 3), h && (l[i] = h), c && (l.scale = c), r
                            },
                            prefix: !0
                        }), Mt("boxShadow", {
                            defaultValue: "0px 0px 0px 0px #999",
                            prefix: !0,
                            color: !0,
                            multi: !0,
                            keyword: "inset"
                        }), Mt("borderRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, r, a, s) {
                                e = this.format(e);
                                var l, h, c, u, p, d, f, m, v, g, y, _, x, b, w, T, E = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                    M = t.style;
                                for (v = parseFloat(t.offsetWidth), g = parseFloat(t.offsetHeight), l = e.split(" "), h = 0; h < E.length; h++) this.p.indexOf("border") && (E[h] = Q(E[h])), -1 !== (p = u = tt(t, E[h], o, !1, "0px")).indexOf(" ") && (p = (u = p.split(" "))[0], u = u[1]), d = c = l[h], f = parseFloat(p), _ = p.substr((f + "").length), (x = "=" === d.charAt(1)) ? (m = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), m *= parseFloat(d), y = d.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(d), y = d.substr((m + "").length)), "" === y && (y = n[i] || _), y !== _ && (b = et(t, "borderLeft", f, _), w = et(t, "borderTop", f, _), "%" === y ? (p = b / v * 100 + "%", u = w / g * 100 + "%") : "em" === y ? (p = b / (T = et(t, "borderLeft", 1, "em")) + "em", u = w / T + "em") : (p = b + "px", u = w + "px"), x && (d = parseFloat(p) + m + y, c = parseFloat(u) + m + y)), a = wt(M, E[h], p + " " + u, d + " " + c, !1, "0px", a);
                                return a
                            },
                            prefix: !0,
                            formatter: gt("0px 0px 0px 0px", !1, !0)
                        }), Mt("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, n, r, a) {
                                return wt(t.style, i, this.format(tt(t, i, o, !1, "0px 0px")), this.format(e), !1, "0px", r)
                            },
                            prefix: !0,
                            formatter: gt("0px 0px", !1, !0)
                        }), Mt("backgroundPosition", {
                            defaultValue: "0 0",
                            parser: function(t, e, i, n, r, a) {
                                var s, l, h, c, u, p, d = "background-position",
                                    f = o || $(t, null),
                                    m = this.format((f ? v ? f.getPropertyValue(d + "-x") + " " + f.getPropertyValue(d + "-y") : f.getPropertyValue(d) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                    g = this.format(e);
                                if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && g.split(",").length < 2 && (p = tt(t, "backgroundImage").replace(P, "")) && "none" !== p) {
                                    for (s = m.split(" "), l = g.split(" "), j.setAttribute("src", p), h = 2; --h > -1;)(c = -1 !== (m = s[h]).indexOf("%")) != (-1 !== l[h].indexOf("%")) && (u = 0 === h ? t.offsetWidth - j.width : t.offsetHeight - j.height, s[h] = c ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                    m = s.join(" ")
                                }
                                return this.parseComplex(t.style, m, g, r, a)
                            },
                            formatter: lt
                        }), Mt("backgroundSize", {
                            defaultValue: "0 0",
                            formatter: function(t) {
                                return "co" === (t += "").substr(0, 2) ? t : lt(-1 === t.indexOf(" ") ? t + " " + t : t)
                            }
                        }), Mt("perspective", {
                            defaultValue: "0px",
                            prefix: !0
                        }), Mt("perspectiveOrigin", {
                            defaultValue: "50% 50%",
                            prefix: !0
                        }), Mt("transformStyle", {
                            prefix: !0
                        }), Mt("backfaceVisibility", {
                            prefix: !0
                        }), Mt("userSelect", {
                            prefix: !0
                        }), Mt("margin", {
                            parser: yt("marginTop,marginRight,marginBottom,marginLeft")
                        }), Mt("padding", {
                            parser: yt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                        }), Mt("clip", {
                            defaultValue: "rect(0px,0px,0px,0px)",
                            parser: function(t, e, i, n, r, a) {
                                var s, l, h;
                                return v < 9 ? (l = t.currentStyle, h = v < 8 ? " " : ",", s = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")", e = this.format(e).split(",").join(h)) : (s = this.format(tt(t, this.p, o, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, r, a)
                            }
                        }), Mt("textShadow", {
                            defaultValue: "0px 0px 0px #999",
                            color: !0,
                            multi: !0
                        }), Mt("autoRound,strictUnits", {
                            parser: function(t, e, i, n, r) {
                                return r
                            }
                        }), Mt("border", {
                            defaultValue: "0px solid #000",
                            parser: function(t, e, i, n, r, a) {
                                var s = tt(t, "borderTopWidth", o, !1, "0px"),
                                    l = this.format(e).split(" "),
                                    h = l[0].replace(T, "");
                                return "px" !== h && (s = parseFloat(s) / et(t, "borderTopWidth", 1, h) + h), this.parseComplex(t.style, this.format(s + " " + tt(t, "borderTopStyle", o, !1, "solid") + " " + tt(t, "borderTopColor", o, !1, "#000")), l.join(" "), r, a)
                            },
                            color: !0,
                            formatter: function(t) {
                                var e = t.split(" ");
                                return e[0] + " " + (e[1] || "solid") + " " + (t.match(vt) || ["#000"])[0]
                            }
                        }), Mt("borderWidth", {
                            parser: yt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                        }), Mt("float,cssFloat,styleFloat", {
                            parser: function(t, e, i, n, r, o) {
                                var a = t.style,
                                    s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                return new xt(a, s, 0, 0, r, -1, i, !1, 0, a[s], e)
                            }
                        });
                        var Jt = function(t) {
                            var e, i = this.t,
                                n = i.filter || tt(this.data, "filter") || "",
                                r = this.s + this.c * t | 0;
                            100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !tt(this.data, "filter")) : (i.filter = n.replace(S, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(E, "opacity=" + r))
                        };
                        Mt("opacity,alpha,autoAlpha", {
                            defaultValue: "1",
                            parser: function(t, e, i, n, r, a) {
                                var s = parseFloat(tt(t, "opacity", o, !1, "1")),
                                    l = t.style,
                                    h = "autoAlpha" === i;
                                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), h && 1 === s && "hidden" === tt(t, "visibility", o) && 0 !== e && (s = 0), X ? r = new xt(l, "opacity", s, e - s, r) : ((r = new xt(l, "opacity", 100 * s, 100 * (e - s), r)).xn1 = h ? 1 : 0, l.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = t, r.plugin = a, r.setRatio = Jt), h && ((r = new xt(l, "visibility", 0, 0, r, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(r.n), n._overwriteProps.push(i)), r
                            }
                        });
                        var Kt = function(t, e) {
                                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(C, "-$1").toLowerCase())) : t.removeAttribute(e))
                            },
                            Qt = function(t) {
                                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Kt(i, e.p), e = e._next;
                                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                            };
                        Mt("className", {
                            parser: function(t, e, n, r, a, s, l) {
                                var h, c, u, p, d, f = t.getAttribute("class") || "",
                                    m = t.style.cssText;
                                if ((a = r._classNamePT = new xt(t, n, 0, 0, a, 2)).setRatio = Qt, a.pr = -11, i = !0, a.b = f, c = nt(t, o), u = t._gsClassPT) {
                                    for (p = {}, d = u.data; d;) p[d.p] = 1, d = d._next;
                                    u.setRatio(1)
                                }
                                return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), h = rt(t, c, nt(t), l, p), t.setAttribute("class", f), a.data = h.firstMPT, t.style.cssText = m, a.xfirst = r.parse(t, h.difs, a, s)
                            }
                        });
                        var $t = function(t) {
                            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                var e, i, n, r, o, a = this.t.style,
                                    s = h.transform.parse;
                                if ("all" === this.e) a.cssText = "", r = !0;
                                else
                                    for (n = (e = this.e.split(" ").join("").split(",")).length; --n > -1;) i = e[n], h[i] && (h[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Nt : h[i].p), Kt(a, i);
                                r && (Kt(a, Bt), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                            }
                        };
                        for (Mt("clearProps", {
                                parser: function(t, e, n, r, o) {
                                    return (o = new xt(t, n, 0, 0, o, 2)).setRatio = $t, o.e = e, o.pr = -10, o.data = r._tween, i = !0, o
                                }
                            }), c = "bezier,throwProps,physicsProps,physics2D".split(","), Tt = c.length; Tt--;) St(c[Tt]);
                        (c = s.prototype)._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function(t, e, r, l) {
                            if (!t.nodeType) return !1;
                            this._target = g = t, this._tween = r, this._vars = e, y = l, u = e.autoRound, i = !1, n = e.suffixMap || s.suffixMap, o = $(t, ""), a = this._overwriteProps;
                            var c, f, v, _, x, b, w, T, E, S = t.style;
                            if (p && "" === S.zIndex && ("auto" !== (c = tt(t, "zIndex", o)) && "" !== c || this._addLazySet(S, "zIndex", 0)), "string" == typeof e && (_ = S.cssText, c = nt(t, o), S.cssText = _ + ";" + e, c = rt(t, c, nt(t)).difs, !X && M.test(e) && (c.opacity = parseFloat(RegExp.$1)), e = c, S.cssText = _), e.className ? this._firstPT = f = h.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null), this._transformType) {
                                for (E = 3 === this._transformType, Bt ? d && (p = !0, "" === S.zIndex && ("auto" !== (w = tt(t, "zIndex", o)) && "" !== w || this._addLazySet(S, "zIndex", 0)), m && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (E ? "visible" : "hidden"))) : S.zoom = 1, v = f; v && v._next;) v = v._next;
                                T = new xt(t, "transform", 0, 0, null, 2), this._linkCSSP(T, null, v), T.setRatio = Bt ? Zt : Yt, T.data = this._transform || Xt(t, o, !0), T.tween = r, T.pr = -1, a.pop()
                            }
                            if (i) {
                                for (; f;) {
                                    for (b = f._next, v = _; v && v.pr > f.pr;) v = v._next;
                                    (f._prev = v ? v._prev : x) ? f._prev._next = f: _ = f, (f._next = v) ? v._prev = f : x = f, f = b
                                }
                                this._firstPT = _
                            }
                            return !0
                        }, c.parse = function(t, e, i, r) {
                            var a, s, l, c, p, d, f, m, v, _, x = t.style;
                            for (a in e) {
                                if ("function" == typeof(d = e[a]) && (d = d(y, g)), s = h[a]) i = s.parse(t, d, a, this, i, r, e);
                                else {
                                    if ("--" === a.substr(0, 2)) {
                                        this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", $(t).getPropertyValue(a) + "", d + "", a, !1, a);
                                        continue
                                    }
                                    p = tt(t, a, o) + "", v = "string" == typeof d, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || v && A.test(d) ? (v || (d = ((d = ft(d)).length > 3 ? "rgba(" : "rgb(") + d.join(",") + ")"), i = wt(x, a, p, d, !0, "transparent", i, 0, r)) : v && z.test(d) ? i = wt(x, a, p, d, !0, null, i, 0, r) : (f = (l = parseFloat(p)) || 0 === l ? p.substr((l + "").length) : "", "" !== p && "auto" !== p || ("width" === a || "height" === a ? (l = st(t, a, o), f = "px") : "left" === a || "top" === a ? (l = it(t, a, o), f = "px") : (l = "opacity" !== a ? 0 : 1, f = "")), (_ = v && "=" === d.charAt(1)) ? (c = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), c *= parseFloat(d), m = d.replace(T, "")) : (c = parseFloat(d), m = v ? d.replace(T, "") : ""), "" === m && (m = a in n ? n[a] : f), d = c || 0 === c ? (_ ? c + l : c) + m : e[a], f !== m && ("" === m && "lineHeight" !== a || (c || 0 === c) && l && (l = et(t, a, l, f), "%" === m ? (l /= et(t, a, 100, "%") / 100, !0 !== e.strictUnits && (p = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= et(t, a, 1, m) : "px" !== m && (c = et(t, a, c, m), m = "px"), _ && (c || 0 === c) && (d = c + l + m))), _ && (c += l), !l && 0 !== l || !c && 0 !== c ? void 0 !== x[a] && (d || d + "" != "NaN" && null != d) ? (i = new xt(x, a, c || l || 0, 0, i, -1, a, !1, 0, p, d)).xs0 = "none" !== d || "display" !== a && -1 === a.indexOf("Style") ? d : p : Z("invalid " + a + " tween value: " + e[a]) : (i = new xt(x, a, l, c - l, i, 0, a, !1 !== u && ("px" === m || "zIndex" === a), 0, p, d)).xs0 = m)
                                }
                                r && i && !i.plugin && (i.plugin = r)
                            }
                            return i
                        }, c.setRatio = function(t) {
                            var e, i, n, r = this._firstPT;
                            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                                    for (; r;) {
                                        if (e = r.c * t + r.s, r.r ? e = r.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type)
                                            if (1 === r.type)
                                                if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                                else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                        else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                        else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                        else {
                                            for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i
                                        } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                        else r.t[r.p] = e + r.xs0;
                                        r = r._next
                                    } else
                                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                                else
                                    for (; r;) {
                                        if (2 !== r.type)
                                            if (r.r && -1 !== r.type)
                                                if (e = r.r(r.s + r.c), r.type) {
                                                    if (1 === r.type) {
                                                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                                        r.t[r.p] = i
                                                    }
                                                } else r.t[r.p] = e + r.xs0;
                                        else r.t[r.p] = r.e;
                                        else r.setRatio(t);
                                        r = r._next
                                    }
                        }, c._enableTransforms = function(t) {
                            this._transform = this._transform || Xt(this._target, o, !0), this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3
                        };
                        var te = function(t) {
                            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                        };
                        c._addLazySet = function(t, e, i) {
                            var n = this._firstPT = new xt(t, e, 0, 0, this._firstPT, 2);
                            n.e = i, n.setRatio = te, n.data = this
                        }, c._linkCSSP = function(t, e, i, n) {
                            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                        }, c._mod = function(t) {
                            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
                        }, c._kill = function(e) {
                            var i, n, r, o = e;
                            if (e.autoAlpha || e.alpha) {
                                for (n in o = {}, e) o[n] = e[n];
                                o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                            }
                            for (e.className && (i = this._classNamePT) && ((r = i.xfirst) && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e), n = i.plugin), i = i._next;
                            return t.prototype._kill.call(this, o)
                        };
                        var ee = function(t, e, i) {
                            var n, r, o, a;
                            if (t.slice)
                                for (r = t.length; --r > -1;) ee(t[r], e, i);
                            else
                                for (r = (n = t.childNodes).length; --r > -1;) a = (o = n[r]).type, o.style && (e.push(nt(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || ee(o, e, i)
                        };
                        return s.cascadeTo = function(t, i, n) {
                            var r, o, a, s, l = e.to(t, i, n),
                                h = [l],
                                c = [],
                                u = [],
                                p = [],
                                d = e._internals.reservedProps;
                            for (t = l._targets || l.target, ee(t, c, p), l.render(i, !0, !0), ee(t, u), l.render(0, !0, !0), l._enabled(!0), r = p.length; --r > -1;)
                                if ((o = rt(p[r], c[r], u[r])).firstMPT) {
                                    for (a in o = o.difs, n) d[a] && (o[a] = n[a]);
                                    for (a in s = {}, o) s[a] = c[r][a];
                                    h.push(e.fromTo(p[r], i, s, o))
                                }
                            return h
                        }, t.activate([s]), s
                    }, !0),
                    function() {
                        var t = function(t) {
                                var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                                return function(i) {
                                    return (Math.round(i / t) * t * e | 0) / e
                                }
                            },
                            e = function(t, e) {
                                for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
                            },
                            i = r._gsDefine.plugin({
                                propName: "roundProps",
                                version: "1.7.0",
                                priority: -1,
                                API: 2,
                                init: function(t, e, i) {
                                    return this._tween = i, !0
                                }
                            }).prototype;
                        i._onInitAllProps = function() {
                            var i, n, r, o, a = this._tween,
                                s = a.vars.roundProps,
                                l = {},
                                h = a._propLookup.roundProps;
                            if ("object" != typeof s || s.push)
                                for ("string" == typeof s && (s = s.split(",")), r = s.length; --r > -1;) l[s[r]] = Math.round;
                            else
                                for (o in s) l[o] = t(s[o]);
                            for (o in l)
                                for (i = a._firstPT; i;) n = i._next, i.pg ? i.t._mod(l) : i.n === o && (2 === i.f && i.t ? e(i.t._firstPT, l[o]) : (this._add(i.t, o, i.s, i.c, l[o]), n && (n._prev = i._prev), i._prev ? i._prev._next = n : a._firstPT === i && (a._firstPT = n), i._next = i._prev = null, a._propLookup[o] = h)), i = n;
                            return !1
                        }, i._add = function(t, e, i, n, r) {
                            this._addTween(t, e, i, i + n, e, r || Math.round), this._overwriteProps.push(e)
                        }
                    }(), r._gsDefine.plugin({
                        propName: "attr",
                        API: 2,
                        version: "0.6.1",
                        init: function(t, e, i, n) {
                            var r, o;
                            if ("function" != typeof t.setAttribute) return !1;
                            for (r in e) "function" == typeof(o = e[r]) && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                            return !0
                        }
                    }), r._gsDefine.plugin({
                        propName: "directionalRotation",
                        version: "0.3.1",
                        API: 2,
                        init: function(t, e, i, n) {
                            "object" != typeof e && (e = {
                                rotation: e
                            }), this.finals = {};
                            var r, o, a, s, l, h, c = !0 === e.useRadians ? 2 * Math.PI : 360;
                            for (r in e) "useRadians" !== r && ("function" == typeof(s = e[r]) && (s = s(n, t)), o = (h = (s + "").split("_"))[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), l = (s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - a, h.length && (-1 !== (o = h.join("_")).indexOf("short") && (l %= c) != l % (c / 2) && (l = l < 0 ? l + c : l - c), -1 !== o.indexOf("_cw") && l < 0 ? l = (l + 9999999999 * c) % c - (l / c | 0) * c : -1 !== o.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * c) % c - (l / c | 0) * c)), (l > 1e-6 || l < -1e-6) && (this._addTween(t, r, a, a + l, r), this._overwriteProps.push(r)));
                            return !0
                        },
                        set: function(t) {
                            var e;
                            if (1 !== t) this._super.setRatio.call(this, t);
                            else
                                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                        }
                    })._autoCSS = !0, r._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                        var e, i, n, o, a = r.GreenSockGlobals || r,
                            s = a.com.greensock,
                            l = 2 * Math.PI,
                            h = Math.PI / 2,
                            c = s._class,
                            u = function(e, i) {
                                var n = c("easing." + e, function() {}, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, n
                            },
                            p = t.register || function() {},
                            d = function(t, e, i, n, r) {
                                var o = c("easing." + t, {
                                    easeOut: new e,
                                    easeIn: new i,
                                    easeInOut: new n
                                }, !0);
                                return p(o, t), o
                            },
                            f = function(t, e, i) {
                                this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                            },
                            m = function(e, i) {
                                var n = c("easing." + e, function(t) {
                                        this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                                    }, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, r.config = function(t) {
                                    return new n(t)
                                }, n
                            },
                            v = d("Back", m("BackOut", function(t) {
                                return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                            }), m("BackIn", function(t) {
                                return t * t * ((this._p1 + 1) * t - this._p1)
                            }), m("BackInOut", function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                            })),
                            g = c("easing.SlowMo", function(t, e, i) {
                                e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                            }, !0),
                            y = g.prototype = new t;
                        return y.constructor = g, y.getRatio = function(t) {
                            var e = t + (.5 - t) * this._p;
                            return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                        }, g.ease = new g(.7, .7), y.config = g.config = function(t, e, i) {
                            return new g(t, e, i)
                        }, (y = (e = c("easing.SteppedEase", function(t, e) {
                            t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
                        }, !0)).prototype = new t).constructor = e, y.getRatio = function(t) {
                            return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
                        }, y.config = e.config = function(t, i) {
                            return new e(t, i)
                        }, (y = (i = c("easing.ExpoScaleEase", function(t, e, i) {
                            this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
                        }, !0)).prototype = new t).constructor = i, y.getRatio = function(t) {
                            return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
                        }, y.config = i.config = function(t, e, n) {
                            return new i(t, e, n)
                        }, (y = (n = c("easing.RoughEase", function(e) {
                            for (var i, n, r, o, a, s, l = (e = e || {}).taper || "none", h = [], c = 0, u = 0 | (e.points || 20), p = u, d = !1 !== e.randomize, m = !0 === e.clamp, v = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --p > -1;) i = d ? Math.random() : 1 / u * p, n = v ? v.getRatio(i) : i, r = "none" === l ? g : "out" === l ? (o = 1 - i) * o * g : "in" === l ? i * i * g : i < .5 ? (o = 2 * i) * o * .5 * g : (o = 2 * (1 - i)) * o * .5 * g, d ? n += Math.random() * r - .5 * r : p % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : n < 0 && (n = 0)), h[c++] = {
                                x: i,
                                y: n
                            };
                            for (h.sort(function(t, e) {
                                    return t.x - e.x
                                }), s = new f(1, 1, null), p = u; --p > -1;) a = h[p], s = new f(a.x, a.y, s);
                            this._prev = new f(0, 0, 0 !== s.t ? s : s.next)
                        }, !0)).prototype = new t).constructor = n, y.getRatio = function(t) {
                            var e = this._prev;
                            if (t > e.t) {
                                for (; e.next && t >= e.t;) e = e.next;
                                e = e.prev
                            } else
                                for (; e.prev && t <= e.t;) e = e.prev;
                            return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                        }, y.config = function(t) {
                            return new n(t)
                        }, n.ease = new n, d("Bounce", u("BounceOut", function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }), u("BounceIn", function(t) {
                            return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                        }), u("BounceInOut", function(t) {
                            var e = t < .5;
                            return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                        })), d("Circ", u("CircOut", function(t) {
                            return Math.sqrt(1 - (t -= 1) * t)
                        }), u("CircIn", function(t) {
                            return -(Math.sqrt(1 - t * t) - 1)
                        }), u("CircInOut", function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        })), d("Elastic", (o = function(e, i, n) {
                            var r = c("easing." + e, function(t, e) {
                                    this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (t < 1 ? t : 1), this._p3 = this._p2 / l * (Math.asin(1 / this._p1) || 0), this._p2 = l / this._p2
                                }, !0),
                                o = r.prototype = new t;
                            return o.constructor = r, o.getRatio = i, o.config = function(t, e) {
                                return new r(t, e)
                            }, r
                        })("ElasticOut", function(t) {
                            return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                        }, .3), o("ElasticIn", function(t) {
                            return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
                        }, .3), o("ElasticInOut", function(t) {
                            return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                        }, .45)), d("Expo", u("ExpoOut", function(t) {
                            return 1 - Math.pow(2, -10 * t)
                        }), u("ExpoIn", function(t) {
                            return Math.pow(2, 10 * (t - 1)) - .001
                        }), u("ExpoInOut", function(t) {
                            return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        })), d("Sine", u("SineOut", function(t) {
                            return Math.sin(t * h)
                        }), u("SineIn", function(t) {
                            return 1 - Math.cos(t * h)
                        }), u("SineInOut", function(t) {
                            return -.5 * (Math.cos(Math.PI * t) - 1)
                        })), c("easing.EaseLookup", {
                            find: function(e) {
                                return t.map[e]
                            }
                        }, !0), p(a.SlowMo, "SlowMo", "ease,"), p(n, "RoughEase", "ease,"), p(e, "SteppedEase", "ease,"), v
                    }, !0)
            }), r._gsDefine && r._gsQueue.pop()(),
            function(i, r) {
                "use strict";
                var o = {},
                    a = i.document,
                    s = i.GreenSockGlobals = i.GreenSockGlobals || i;
                if (s.TweenLite) return s.TweenLite;
                var l, h, c, u, p, d, f, m = function(t) {
                        var e, i = t.split("."),
                            n = s;
                        for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                        return n
                    },
                    v = m("com.greensock"),
                    g = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    y = function() {},
                    _ = (d = Object.prototype.toString, f = d.call([]), function(t) {
                        return null != t && (t instanceof Array || "object" == typeof t && !!t.push && d.call(t) === f)
                    }),
                    x = {},
                    b = function(i, r, a, l) {
                        this.sc = x[i] ? x[i].sc : [], x[i] = this, this.gsClass = null, this.func = a;
                        var h = [];
                        this.check = function(c) {
                            for (var u, p, d, f, v = r.length, g = v; --v > -1;)(u = x[r[v]] || new b(r[v], [])).gsClass ? (h[v] = u.gsClass, g--) : c && u.sc.push(this);
                            if (0 === g && a) {
                                if (d = (p = ("com.greensock." + i).split(".")).pop(), f = m(p.join("."))[d] = this.gsClass = a.apply(a, h), l)
                                    if (s[d] = o[d] = f, void 0 !== t && t.exports)
                                        if ("TweenMax" === i)
                                            for (v in t.exports = o.TweenMax = f, o) f[v] = o[v];
                                        else o.TweenMax && (o.TweenMax[d] = f);
                                else void 0 === (n = function() {
                                    return f
                                }.apply(e, [])) || (t.exports = n);
                                for (v = 0; v < this.sc.length; v++) this.sc[v].check()
                            }
                        }, this.check(!0)
                    },
                    w = i._gsDefine = function(t, e, i, n) {
                        return new b(t, e, i, n)
                    },
                    T = v._class = function(t, e, i) {
                        return e = e || function() {}, w(t, [], function() {
                            return e
                        }, i), e
                    };
                w.globals = s;
                var E = [0, 0, 1, 1],
                    M = T("easing.Ease", function(t, e, i, n) {
                        this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? E.concat(e) : E
                    }, !0),
                    S = M.map = {},
                    A = M.register = function(t, e, i, n) {
                        for (var r, o, a, s, l = e.split(","), h = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --h > -1;)
                            for (o = l[h], r = n ? T("easing." + o, null, !0) : v.easing[o] || {}, a = c.length; --a > -1;) s = c[a], S[o + "." + s] = S[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                    };
                for ((c = M.prototype)._calcEnd = !1, c.getRatio = function(t) {
                        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                        var e = this._type,
                            i = this._power,
                            n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                    }, h = (l = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --h > -1;) c = l[h] + ",Power" + h, A(new M(null, null, 1, h), c, "easeOut", !0), A(new M(null, null, 2, h), c, "easeIn" + (0 === h ? ",easeNone" : "")), A(new M(null, null, 3, h), c, "easeInOut");
                S.linear = v.easing.Linear.easeIn, S.swing = v.easing.Quad.easeInOut;
                var C = T("events.EventDispatcher", function(t) {
                    this._listeners = {}, this._eventTarget = t || this
                });
                (c = C.prototype).addEventListener = function(t, e, i, n, r) {
                    r = r || 0;
                    var o, a, s = this._listeners[t],
                        l = 0;
                    for (this !== u || p || u.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;)(o = s[a]).c === e && o.s === i ? s.splice(a, 1) : 0 === l && o.pr < r && (l = a + 1);
                    s.splice(l, 0, {
                        c: e,
                        s: i,
                        up: n,
                        pr: r
                    })
                }, c.removeEventListener = function(t, e) {
                    var i, n = this._listeners[t];
                    if (n)
                        for (i = n.length; --i > -1;)
                            if (n[i].c === e) return void n.splice(i, 1)
                }, c.dispatchEvent = function(t) {
                    var e, i, n, r = this._listeners[t];
                    if (r)
                        for ((e = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                            type: t,
                            target: i
                        }) : n.c.call(n.s || i))
                };
                var R = i.requestAnimationFrame,
                    P = i.cancelAnimationFrame,
                    L = Date.now || function() {
                        return (new Date).getTime()
                    },
                    O = L();
                for (h = (l = ["ms", "moz", "webkit", "o"]).length; --h > -1 && !R;) R = i[l[h] + "RequestAnimationFrame"], P = i[l[h] + "CancelAnimationFrame"] || i[l[h] + "CancelRequestAnimationFrame"];
                T("Ticker", function(t, e) {
                    var i, n, r, o, s, l = this,
                        h = L(),
                        c = !(!1 === e || !R) && "auto",
                        d = 500,
                        f = 33,
                        m = function(t) {
                            var e, a, c = L() - O;
                            c > d && (h += c - f), O += c, l.time = (O - h) / 1e3, e = l.time - s, (!i || e > 0 || !0 === t) && (l.frame++, s += e + (e >= o ? .004 : o - e), a = !0), !0 !== t && (r = n(m)), a && l.dispatchEvent("tick")
                        };
                    C.call(l), l.time = l.frame = 0, l.tick = function() {
                        m(!0)
                    }, l.lagSmoothing = function(t, e) {
                        if (!arguments.length) return d < 1e10;
                        d = t || 1e10, f = Math.min(e, d, 0)
                    }, l.sleep = function() {
                        null != r && (c && P ? P(r) : clearTimeout(r), n = y, r = null, l === u && (p = !1))
                    }, l.wake = function(t) {
                        null !== r ? l.sleep() : t ? h += -O + (O = L()) : l.frame > 10 && (O = L() - d + 5), n = 0 === i ? y : c && R ? R : function(t) {
                            return setTimeout(t, 1e3 * (s - l.time) + 1 | 0)
                        }, l === u && (p = !0), m(2)
                    }, l.fps = function(t) {
                        if (!arguments.length) return i;
                        o = 1 / ((i = t) || 60), s = this.time + o, l.wake()
                    }, l.useRAF = function(t) {
                        if (!arguments.length) return c;
                        l.sleep(), c = t, l.fps(i)
                    }, l.fps(t), setTimeout(function() {
                        "auto" === c && l.frame < 5 && "hidden" !== (a || {}).visibilityState && l.useRAF(!1)
                    }, 1500)
                }), (c = v.Ticker.prototype = new v.events.EventDispatcher).constructor = v.Ticker;
                var B = T("core.Animation", function(t, e) {
                    if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, Q) {
                        p || u.wake();
                        var i = this.vars.useFrames ? K : Q;
                        i.add(this, i._time), this.vars.paused && this.paused(!0)
                    }
                });
                u = B.ticker = new v.Ticker, (c = B.prototype)._dirty = c._gc = c._initted = c._paused = !1, c._totalTime = c._time = 0, c._rawPrevTime = -1, c._next = c._last = c._onUpdate = c._timeline = c.timeline = null, c._paused = !1;
                var I = function() {
                    p && L() - O > 2e3 && ("hidden" !== (a || {}).visibilityState || !u.lagSmoothing()) && u.wake();
                    var t = setTimeout(I, 2e3);
                    t.unref && t.unref()
                };
                I(), c.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, c.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, c.resume = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!1)
                }, c.seek = function(t, e) {
                    return this.totalTime(Number(t), !1 !== e)
                }, c.restart = function(t, e) {
                    return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                }, c.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, c.render = function(t, e, i) {}, c.invalidate = function() {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, c.isActive = function() {
                    var t, e = this._timeline,
                        i = this._startTime;
                    return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                }, c._enabled = function(t, e) {
                    return p || u.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                }, c._kill = function(t, e) {
                    return this._enabled(!1, !1)
                }, c.kill = function(t, e) {
                    return this._kill(t, e), this
                }, c._uncache = function(t) {
                    for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                    return this
                }, c._swapSelfInParams = function(t) {
                    for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                    return i
                }, c._callback = function(t) {
                    var e = this.vars,
                        i = e[t],
                        n = e[t + "Params"],
                        r = e[t + "Scope"] || e.callbackScope || this;
                    switch (n ? n.length : 0) {
                        case 0:
                            i.call(r);
                            break;
                        case 1:
                            i.call(r, n[0]);
                            break;
                        case 2:
                            i.call(r, n[0], n[1]);
                            break;
                        default:
                            i.apply(r, n)
                    }
                }, c.eventCallback = function(t, e, i, n) {
                    if ("on" === (t || "").substr(0, 2)) {
                        var r = this.vars;
                        if (1 === arguments.length) return r[t];
                        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = _(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                    }
                    return this
                }, c.delay = function(t) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                }, c.duration = function(t) {
                    return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, c.totalDuration = function(t) {
                    return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                }, c.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                }, c.totalTime = function(t, e, i) {
                    if (p || u.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var n = this._totalDuration,
                                r = this._timeline;
                            if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (D.length && tt(), this.render(t, e, !1), D.length && tt())
                    }
                    return this
                }, c.progress = c.totalProgress = function(t, e) {
                    var i = this.duration();
                    return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                }, c.startTime = function(t) {
                    return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                }, c.endTime = function(t) {
                    return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                }, c.timeScale = function(t) {
                    if (!arguments.length) return this._timeScale;
                    var e, i;
                    for (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                    return this
                }, c.reversed = function(t) {
                    return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, c.paused = function(t) {
                    if (!arguments.length) return this._paused;
                    var e, i, n = this._timeline;
                    return t != this._paused && n && (p || t || u.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                };
                var N = T("core.SimpleTimeline", function(t) {
                    B.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                });
                (c = N.prototype = new B).constructor = N, c.kill()._gc = !1, c._first = c._last = c._recent = null, c._sortChildren = !1, c.add = c.insert = function(t, e, i, n) {
                    var r, o;
                    if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                        for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                    return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                }, c._remove = function(t, e) {
                    return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, c.render = function(t, e, i) {
                    var n, r = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                }, c.rawTime = function() {
                    return p || u.wake(), this._totalTime
                };
                var z = T("TweenLite", function(t, e, n) {
                        if (B.call(this, e, n), this.render = z.prototype.render, null == t) throw "Cannot tween a null target.";
                        this.target = t = "string" != typeof t ? t : z.selector(t) || t;
                        var r, o, a, s = t.jquery || t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType),
                            l = this.vars.overwrite;
                        if (this._overwrite = l = null == l ? J[z.defaultOverwrite] : "number" == typeof l ? l >> 0 : J[l], (s || t instanceof Array || t.push && _(t)) && "number" != typeof t[0])
                            for (this._targets = a = g(t), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++)(o = a[r]) ? "string" != typeof o ? o.length && o !== i && o[0] && (o[0] === i || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(g(o))) : (this._siblings[r] = et(o, this, !1), 1 === l && this._siblings[r].length > 1 && nt(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = a[r--] = z.selector(o)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                        else this._propLookup = {}, this._siblings = et(t, this, !1), 1 === l && this._siblings.length > 1 && nt(t, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === e && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
                    }, !0),
                    F = function(t) {
                        return t && t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType)
                    };
                (c = z.prototype = new B).constructor = z, c.kill()._gc = !1, c.ratio = 0, c._firstPT = c._targets = c._overwrittenProps = c._startAt = null, c._notifyPluginsOfEnabled = c._lazy = !1, z.version = "2.0.0", z.defaultEase = c._ease = new M(null, null, 1, 1), z.defaultOverwrite = "auto", z.ticker = u, z.autoSleep = 120, z.lagSmoothing = function(t, e) {
                    u.lagSmoothing(t, e)
                }, z.selector = i.$ || i.jQuery || function(t) {
                    var e = i.$ || i.jQuery;
                    return e ? (z.selector = e, e(t)) : (a || (a = i.document), a ? a.querySelectorAll ? a.querySelectorAll(t) : a.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
                };
                var D = [],
                    U = {},
                    k = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    V = /[\+-]=-?[\.\d]/,
                    H = function(t) {
                        for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                    },
                    G = function(t, e, i, n) {
                        var r, o, a, s, l, h, c, u = [],
                            p = 0,
                            d = "",
                            f = 0;
                        for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(k) || [], o = e.match(k) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = o.length, s = 0; s < l; s++) c = o[s], d += (h = e.substr(p, e.indexOf(c, p) - p)) || !s ? h : ",", p += h.length, f ? f = (f + 1) % 5 : "rgba(" === h.substr(-5) && (f = 1), c === r[s] || r.length <= s ? d += c : (d && (u.push(d), d = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                            _next: u._firstPT,
                            t: u,
                            p: u.length - 1,
                            s: a,
                            c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - a) || 0,
                            f: 0,
                            m: f && f < 4 ? Math.round : 0
                        }), p += c.length;
                        return (d += e.substr(p)) && u.push(d), u.setRatio = H, V.test(e) && (u.end = null), u
                    },
                    j = function(t, e, i, n, r, o, a, s, l) {
                        "function" == typeof n && (n = n(l || 0, t));
                        var h = typeof t[e],
                            c = "function" !== h ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                            u = "get" !== i ? i : c ? a ? t[c](a) : t[c]() : t[e],
                            p = "string" == typeof n && "=" === n.charAt(1),
                            d = {
                                t: t,
                                p: e,
                                s: u,
                                f: "function" === h,
                                pg: 0,
                                n: r || e,
                                m: o ? "function" == typeof o ? o : Math.round : 0,
                                pr: 0,
                                c: p ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0
                            };
                        if (("number" != typeof u || "number" != typeof n && !p) && (a || isNaN(u) || !p && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (d.fp = a, d = {
                                t: G(u, p ? parseFloat(d.s) + d.c + (d.s + "").replace(/[0-9\-\.]/g, "") : n, s || z.defaultStringFilter, d),
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 2,
                                pg: 0,
                                n: r || e,
                                pr: 0,
                                m: 0
                            }) : (d.s = parseFloat(u), p || (d.c = parseFloat(n) - d.s || 0))), d.c) return (d._next = this._firstPT) && (d._next._prev = d), this._firstPT = d, d
                    },
                    W = z._internals = {
                        isArray: _,
                        isSelector: F,
                        lazyTweens: D,
                        blobDif: G
                    },
                    q = z._plugins = {},
                    X = W.tweenLookup = {},
                    Y = 0,
                    Z = W.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    J = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    K = B._rootFramesTimeline = new N,
                    Q = B._rootTimeline = new N,
                    $ = 30,
                    tt = W.lazyRender = function() {
                        var t, e = D.length;
                        for (U = {}; --e > -1;)(t = D[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        D.length = 0
                    };
                Q._startTime = u.time, K._startTime = u.frame, Q._active = K._active = !0, setTimeout(tt, 1), B._updateRoot = z.render = function() {
                    var t, e, i;
                    if (D.length && tt(), Q.render((u.time - Q._startTime) * Q._timeScale, !1, !1), K.render((u.frame - K._startTime) * K._timeScale, !1, !1), D.length && tt(), u.frame >= $) {
                        for (i in $ = u.frame + (parseInt(z.autoSleep, 10) || 120), X) {
                            for (t = (e = X[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                            0 === e.length && delete X[i]
                        }
                        if ((!(i = Q._first) || i._paused) && z.autoSleep && !K._first && 1 === u._listeners.tick.length) {
                            for (; i && i._paused;) i = i._next;
                            i || u.sleep()
                        }
                    }
                }, u.addEventListener("tick", B._updateRoot);
                var et = function(t, e, i) {
                        var n, r, o = t._gsTweenID;
                        if (X[o || (t._gsTweenID = o = "t" + Y++)] || (X[o] = {
                                target: t,
                                tweens: []
                            }), e && ((n = X[o].tweens)[r = n.length] = e, i))
                            for (; --r > -1;) n[r] === e && n.splice(r, 1);
                        return X[o].tweens
                    },
                    it = function(t, e, i, n) {
                        var r, o, a = t.vars.onOverwrite;
                        return a && (r = a(t, e, i, n)), (a = z.onOverwrite) && (o = a(t, e, i, n)), !1 !== r && !1 !== o
                    },
                    nt = function(t, e, i, n, r) {
                        var o, a, s, l;
                        if (1 === n || n >= 4) {
                            for (l = r.length, o = 0; o < l; o++)
                                if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                else if (5 === n) break;
                            return a
                        }
                        var h, c = e._startTime + 1e-10,
                            u = [],
                            p = 0,
                            d = 0 === e._duration;
                        for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (h = h || rt(e, 0, d), 0 === rt(s, h, d) && (u[p++] = s)) : s._startTime <= c && s._startTime + s.totalDuration() / s._timeScale > c && ((d || !s._initted) && c - s._startTime <= 2e-10 || (u[p++] = s)));
                        for (o = p; --o > -1;)
                            if (s = u[o], 2 === n && s._kill(i, t, e) && (a = !0), 2 !== n || !s._firstPT && s._initted) {
                                if (2 !== n && !it(s, e)) continue;
                                s._enabled(!1, !1) && (a = !0)
                            }
                        return a
                    },
                    rt = function(t, e, i) {
                        for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                            if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                            n = n._timeline
                        }
                        return (o /= r) > e ? o - e : i && o === e || !t._initted && o - e < 2e-10 ? 1e-10 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : o - e - 1e-10
                    };
                c._init = function() {
                    var t, e, i, n, r, o, a = this.vars,
                        s = this._overwrittenProps,
                        l = this._duration,
                        h = !!a.immediateRender,
                        c = a.ease;
                    if (a.startAt) {
                        for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, a.startAt) r[n] = a.startAt[n];
                        if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = h && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = z.to(this.target || {}, 0, r), h)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== l) return
                    } else if (a.runBackwards && 0 !== l)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            for (n in 0 !== this._time && (h = !1), i = {}, a) Z[n] && "autoCSS" !== n || (i[n] = a[n]);
                            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && !1 !== a.lazy, i.immediateRender = h, this._startAt = z.to(this.target, 0, i), h) {
                                if (0 === this._time) return
                            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                        }
                    if (this._ease = c = c ? c instanceof M ? c : "function" == typeof c ? new M(c, a.easeParams) : S[c] || z.defaultEase : z.defaultEase, a.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                    else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                    if (e && z._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                        for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, c._initProps = function(t, e, n, r, o) {
                    var a, s, l, h, c, u;
                    if (null == t) return !1;
                    for (a in U[t._gsTweenID] && tt(), this.vars.css || t.style && t !== i && t.nodeType && q.css && !1 !== this.vars.autoCSS && function(t, e) {
                            var i, n = {};
                            for (i in t) Z[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!q[i] || q[i] && q[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                            t.css = n
                        }(this.vars, t), this.vars)
                        if (u = this.vars[a], Z[a]) u && (u instanceof Array || u.push && _(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                        else if (q[a] && (h = new q[a])._onInitTween(t, this.vars[a], this, o)) {
                        for (this._firstPT = c = {
                                _next: this._firstPT,
                                t: h,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: a,
                                pg: 1,
                                pr: h._priority,
                                m: 0
                            }, s = h._overwriteProps.length; --s > -1;) e[h._overwriteProps[s]] = this._firstPT;
                        (h._priority || h._onInitAllProps) && (l = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c)
                    } else e[a] = j.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                    return r && this._kill(r, t) ? this._initProps(t, e, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && nt(t, this, e, this._overwrite, n) ? (this._kill(e, t), this._initProps(t, e, n, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (U[t._gsTweenID] = !0), l)
                }, c.render = function(t, e, i) {
                    var n, r, o, a, s = this._time,
                        l = this._duration,
                        h = this._rawPrevTime;
                    if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (h < 0 || t <= 0 && t >= -1e-7 || 1e-10 === h && "isPause" !== this.data) && h !== t && (i = !0, h > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || h === t ? t : 1e-10);
                    else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && h > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (h >= 0 && (1e-10 !== h || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || h === t ? t : 1e-10)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                    else if (this._totalTime = this._time = t, this._easeType) {
                        var c = t / l,
                            u = this._easeType,
                            p = this._easePower;
                        (1 === u || 3 === u && c >= .5) && (c = 1 - c), 3 === u && (c *= 2), 1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c), this.ratio = 1 === u ? 1 - c : 2 === u ? c : t / l < .5 ? c / 2 : 1 - c / 2
                    } else this.ratio = this._ease.getRatio(t / l);
                    if (this._time !== s || i) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = h, D.push(this), void(this._lazy = [t, e]);
                            this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                        this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === l && 1e-10 === this._rawPrevTime && 1e-10 !== a && (this._rawPrevTime = 0)))
                    }
                }, c._kill = function(t, e, i) {
                    if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    e = "string" != typeof e ? e || this._targets || this.target : z.selector(e) || e;
                    var n, r, o, a, s, l, h, c, u, p = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                    if ((_(e) || F(e)) && "number" != typeof e[0])
                        for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
                    else {
                        if (this._targets) {
                            for (n = this._targets.length; --n > -1;)
                                if (e === this._targets[n]) {
                                    s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                    break
                                }
                        } else {
                            if (e !== this.target) return !1;
                            s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                        }
                        if (s) {
                            if (h = t || s, c = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (z.onOverwrite || this.vars.onOverwrite)) {
                                for (o in h) s[o] && (u || (u = []), u.push(o));
                                if ((u || !t) && !it(this, i, e, u)) return !1
                            }
                            for (o in h)(a = s[o]) && (p && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(h) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), c && (r[o] = 1);
                            !this._firstPT && this._initted && this._enabled(!1, !1)
                        }
                    }
                    return l
                }, c.invalidate = function() {
                    return this._notifyPluginsOfEnabled && z._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], B.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
                }, c._enabled = function(t, e) {
                    if (p || u.wake(), t && this._gc) {
                        var i, n = this._targets;
                        if (n)
                            for (i = n.length; --i > -1;) this._siblings[i] = et(n[i], this, !0);
                        else this._siblings = et(this.target, this, !0)
                    }
                    return B.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && z._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                }, z.to = function(t, e, i) {
                    return new z(t, e, i)
                }, z.from = function(t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new z(t, e, i)
                }, z.fromTo = function(t, e, i, n) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new z(t, e, n)
                }, z.delayedCall = function(t, e, i, n, r) {
                    return new z(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: n,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: r,
                        overwrite: 0
                    })
                }, z.set = function(t, e) {
                    return new z(t, 0, e)
                }, z.getTweensOf = function(t, e) {
                    if (null == t) return [];
                    var i, n, r, o;
                    if (t = "string" != typeof t ? t : z.selector(t) || t, (_(t) || F(t)) && "number" != typeof t[0]) {
                        for (i = t.length, n = []; --i > -1;) n = n.concat(z.getTweensOf(t[i], e));
                        for (i = n.length; --i > -1;)
                            for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
                    } else if (t._gsTweenID)
                        for (i = (n = et(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                    return n || []
                }, z.killTweensOf = z.killDelayedCallsTo = function(t, e, i) {
                    "object" == typeof e && (i = e, e = !1);
                    for (var n = z.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                };
                var ot = T("plugins.TweenPlugin", function(t, e) {
                    this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = ot.prototype
                }, !0);
                if (c = ot.prototype, ot.version = "1.19.0", ot.API = 2, c._firstPT = null, c._addTween = j, c.setRatio = H, c._kill = function(t) {
                        var e, i = this._overwriteProps,
                            n = this._firstPT;
                        if (null != t[this._propName]) this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                        for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                        return !1
                    }, c._mod = c._roundProps = function(t) {
                        for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                    }, z._onPluginEvent = function(t, e) {
                        var i, n, r, o, a, s = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; s;) {
                                for (a = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                                (s._prev = n ? n._prev : o) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : o = s, s = a
                            }
                            s = e._firstPT = r
                        }
                        for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                        return i
                    }, ot.activate = function(t) {
                        for (var e = t.length; --e > -1;) t[e].API === ot.API && (q[(new t[e])._propName] = t[e]);
                        return !0
                    }, w.plugin = function(t) {
                        if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                        var e, i = t.propName,
                            n = t.priority || 0,
                            r = t.overwriteProps,
                            o = {
                                init: "_onInitTween",
                                set: "setRatio",
                                kill: "_kill",
                                round: "_mod",
                                mod: "_mod",
                                initAll: "_onInitAllProps"
                            },
                            a = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                ot.call(this, i, n), this._overwriteProps = r || []
                            }, !0 === t.global),
                            s = a.prototype = new ot(i);
                        for (e in s.constructor = a, a.API = t.API, o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                        return a.version = t.version, ot.activate([a]), a
                    }, l = i._gsQueue) {
                    for (h = 0; h < l.length; h++) l[h]();
                    for (c in x) x[c].func || i.console.log("GSAP encountered missing dependency: " + c)
                }
                p = !1
            }(void 0 !== t && t.exports && void 0 !== i ? i : this || window)
    }).call(this, i(18))
}, function(t, e, i) {
    (function(e, i) {
        var n;
        n = function() {
            "use strict";

            function t(t) {
                return "function" == typeof t
            }
            var n = Array.isArray ? Array.isArray : function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                },
                r = 0,
                o = void 0,
                a = void 0,
                s = function(t, e) {
                    f[r] = t, f[r + 1] = e, 2 === (r += 2) && (a ? a(m) : x())
                },
                l = "undefined" != typeof window ? window : void 0,
                h = l || {},
                c = h.MutationObserver || h.WebKitMutationObserver,
                u = "undefined" == typeof self && void 0 !== e && "[object process]" === {}.toString.call(e),
                p = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel;

            function d() {
                var t = setTimeout;
                return function() {
                    return t(m, 1)
                }
            }
            var f = new Array(1e3);

            function m() {
                for (var t = 0; t < r; t += 2)(0, f[t])(f[t + 1]), f[t] = void 0, f[t + 1] = void 0;
                r = 0
            }
            var v, g, y, _, x = void 0;

            function b(t, e) {
                var i = this,
                    n = new this.constructor(E);
                void 0 === n[T] && U(n);
                var r = i._state;
                if (r) {
                    var o = arguments[r - 1];
                    s(function() {
                        return F(r, n, o, i._result)
                    })
                } else N(i, n, t, e);
                return n
            }

            function w(t) {
                if (t && "object" == typeof t && t.constructor === this) return t;
                var e = new this(E);
                return L(e, t), e
            }
            u ? x = function() {
                return e.nextTick(m)
            } : c ? (g = 0, y = new c(m), _ = document.createTextNode(""), y.observe(_, {
                characterData: !0
            }), x = function() {
                _.data = g = ++g % 2
            }) : p ? ((v = new MessageChannel).port1.onmessage = m, x = function() {
                return v.port2.postMessage(0)
            }) : x = void 0 === l ? function() {
                try {
                    var t = Function("return this")().require("vertx");
                    return void 0 !== (o = t.runOnLoop || t.runOnContext) ? function() {
                        o(m)
                    } : d()
                } catch (t) {
                    return d()
                }
            }() : d();
            var T = Math.random().toString(36).substring(2);

            function E() {}
            var M = void 0,
                S = 1,
                A = 2,
                C = {
                    error: null
                };

            function R(t) {
                try {
                    return t.then
                } catch (t) {
                    return C.error = t, C
                }
            }

            function P(e, i, n) {
                i.constructor === e.constructor && n === b && i.constructor.resolve === w ? function(t, e) {
                    e._state === S ? B(t, e._result) : e._state === A ? I(t, e._result) : N(e, void 0, function(e) {
                        return L(t, e)
                    }, function(e) {
                        return I(t, e)
                    })
                }(e, i) : n === C ? (I(e, C.error), C.error = null) : void 0 === n ? B(e, i) : t(n) ? function(t, e, i) {
                    s(function(t) {
                        var n = !1,
                            r = function(t, e, i, n) {
                                try {
                                    t.call(e, i, n)
                                } catch (t) {
                                    return t
                                }
                            }(i, e, function(i) {
                                n || (n = !0, e !== i ? L(t, i) : B(t, i))
                            }, function(e) {
                                n || (n = !0, I(t, e))
                            }, t._label);
                        !n && r && (n = !0, I(t, r))
                    }, t)
                }(e, i, n) : B(e, i)
            }

            function L(t, e) {
                var i, n;
                t === e ? I(t, new TypeError("You cannot resolve a promise with itself")) : (n = typeof(i = e), null === i || "object" !== n && "function" !== n ? B(t, e) : P(t, e, R(e)))
            }

            function O(t) {
                t._onerror && t._onerror(t._result), z(t)
            }

            function B(t, e) {
                t._state === M && (t._result = e, t._state = S, 0 !== t._subscribers.length && s(z, t))
            }

            function I(t, e) {
                t._state === M && (t._state = A, t._result = e, s(O, t))
            }

            function N(t, e, i, n) {
                var r = t._subscribers,
                    o = r.length;
                t._onerror = null, r[o] = e, r[o + S] = i, r[o + A] = n, 0 === o && t._state && s(z, t)
            }

            function z(t) {
                var e = t._subscribers,
                    i = t._state;
                if (0 !== e.length) {
                    for (var n = void 0, r = void 0, o = t._result, a = 0; a < e.length; a += 3) n = e[a], r = e[a + i], n ? F(i, n, r, o) : r(o);
                    t._subscribers.length = 0
                }
            }

            function F(e, i, n, r) {
                var o = t(n),
                    a = void 0,
                    s = void 0,
                    l = void 0,
                    h = void 0;
                if (o) {
                    if ((a = function(t, e) {
                            try {
                                return t(e)
                            } catch (t) {
                                return C.error = t, C
                            }
                        }(n, r)) === C ? (h = !0, s = a.error, a.error = null) : l = !0, i === a) return void I(i, new TypeError("A promises callback cannot return that same promise."))
                } else a = r, l = !0;
                i._state !== M || (o && l ? L(i, a) : h ? I(i, s) : e === S ? B(i, a) : e === A && I(i, a))
            }
            var D = 0;

            function U(t) {
                t[T] = D++, t._state = void 0, t._result = void 0, t._subscribers = []
            }
            var k = function() {
                    function t(t, e) {
                        this._instanceConstructor = t, this.promise = new t(E), this.promise[T] || U(this.promise), n(e) ? (this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), 0 === this.length ? B(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(e), 0 === this._remaining && B(this.promise, this._result))) : I(this.promise, new Error("Array Methods must be provided an Array"))
                    }
                    return t.prototype._enumerate = function(t) {
                        for (var e = 0; this._state === M && e < t.length; e++) this._eachEntry(t[e], e)
                    }, t.prototype._eachEntry = function(t, e) {
                        var i = this._instanceConstructor,
                            n = i.resolve;
                        if (n === w) {
                            var r = R(t);
                            if (r === b && t._state !== M) this._settledAt(t._state, e, t._result);
                            else if ("function" != typeof r) this._remaining--, this._result[e] = t;
                            else if (i === V) {
                                var o = new i(E);
                                P(o, t, r), this._willSettleAt(o, e)
                            } else this._willSettleAt(new i(function(e) {
                                return e(t)
                            }), e)
                        } else this._willSettleAt(n(t), e)
                    }, t.prototype._settledAt = function(t, e, i) {
                        var n = this.promise;
                        n._state === M && (this._remaining--, t === A ? I(n, i) : this._result[e] = i), 0 === this._remaining && B(n, this._result)
                    }, t.prototype._willSettleAt = function(t, e) {
                        var i = this;
                        N(t, void 0, function(t) {
                            return i._settledAt(S, e, t)
                        }, function(t) {
                            return i._settledAt(A, e, t)
                        })
                    }, t
                }(),
                V = function() {
                    function t(e) {
                        this[T] = D++, this._result = this._state = void 0, this._subscribers = [], E !== e && ("function" != typeof e && function() {
                            throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
                        }(), this instanceof t ? function(t, e) {
                            try {
                                e(function(e) {
                                    L(t, e)
                                }, function(e) {
                                    I(t, e)
                                })
                            } catch (e) {
                                I(t, e)
                            }
                        }(this, e) : function() {
                            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
                        }())
                    }
                    return t.prototype.catch = function(t) {
                        return this.then(null, t)
                    }, t.prototype.finally = function(t) {
                        var e = this.constructor;
                        return this.then(function(i) {
                            return e.resolve(t()).then(function() {
                                return i
                            })
                        }, function(i) {
                            return e.resolve(t()).then(function() {
                                throw i
                            })
                        })
                    }, t
                }();
            return V.prototype.then = b, V.all = function(t) {
                return new k(this, t).promise
            }, V.race = function(t) {
                var e = this;
                return n(t) ? new e(function(i, n) {
                    for (var r = t.length, o = 0; o < r; o++) e.resolve(t[o]).then(i, n)
                }) : new e(function(t, e) {
                    return e(new TypeError("You must pass an array to race."))
                })
            }, V.resolve = w, V.reject = function(t) {
                var e = new this(E);
                return I(e, t), e
            }, V._setScheduler = function(t) {
                a = t
            }, V._setAsap = function(t) {
                s = t
            }, V._asap = s, V.polyfill = function() {
                var t = void 0;
                if (void 0 !== i) t = i;
                else if ("undefined" != typeof self) t = self;
                else try {
                    t = Function("return this")()
                } catch (t) {
                    throw new Error("polyfill failed because global object is unavailable in this environment")
                }
                var e = t.Promise;
                if (e) {
                    var n = null;
                    try {
                        n = Object.prototype.toString.call(e.resolve())
                    } catch (t) {}
                    if ("[object Promise]" === n && !e.cast) return
                }
                t.Promise = V
            }, V.Promise = V, V
        }, t.exports = n()
    }).call(this, i(38), i(18))
}, function(t, e, i) {
    "use strict";
    t.exports = i(228).polyfill()
}, function(t, e, i) {
    "use strict";
    i(229), i(227), i(226);
    var n = function(t) {
        if (t && t.__esModule) return t;
        var e = {};
        if (null != t)
            for (var i in t)
                if (Object.prototype.hasOwnProperty.call(t, i)) {
                    var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, i) : {};
                    n.get || n.set ? Object.defineProperty(e, i, n) : e[i] = t[i]
                }
        return e.default = t, e
    }(i(135));
    i(225);
    var r = a(i(224)),
        o = a(i(202));

    function a(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    window.THREE = n, window.CANNON = r.default, window.dat = o.default
}]);